<!DOCTYPE html>
<html lang="en">
<head>
<title>The iOS Apprentice 2: Checklists (Part 1)</title>
<meta charset="utf-8">
<!--[if lt IE 9]>
<script src="HTML/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="HTML/style.css"/>
<link rel="stylesheet" type="text/css" href="HTML/print.css" media="print"/>
<link rel="stylesheet" type="text/css" href="HTML/objc.css"/>
</head>
<body>
<section>
<article>

<div id="topheader">The iOS Apprentice 2</div>

<h1>Checklists (Part 1)</h1>



<p>To-do list apps are one of the most popular types of app on the App Store, second only to fart apps. Apple even included their own Reminders app with iOS 5 (but fortunately no built-in fart app). Building a to-do list app is somewhat of a rite of passage for budding iOS developers, so it makes sense that we create one as well.</p>

<p>Our own to-do list app, Checklists, will look like this when we’re finished:</p>

<figure class="image"><figcaption>The finished Checklists app</figcaption><img src="HTML/Figures/Finished_app.png" alt="The finished Checklists app"/></figure>

<p>The app lets you organize to-do items into lists and then check off these items once you’re done with them. You can set a reminder on a to-do item that will make the iPhone pop up an alert on the due date, even when the app isn’t running.</p>

<p>As far as to-do list apps go, Checklists is very basic, but don’t let that fool you. Even a simple app such as this already has six different screens and a lot of complexity behind the scenes.</p>

<h3>Table views and navigation controllers</h3>

<p>This tutorial will introduce you to two of the most commonly used UI (user interface) elements in iOS apps: the <em>table view</em> and the <em>navigation controller</em>.</p>

<ul>
<li>A table view shows a list of things. All three of the screens above use a table view. In fact, all six of the app’s screens are made with table views. This component is extremely versatile and the most important one to master in iOS development. With iOS 5, table views have become easier to use and even more powerful, and we’ll put that to our advantage.</li>

<li>The navigation controller allows you to build a hierarchy of screens that lead from one to another. It adds a navigation bar at the top of the screen with a title and optional buttons. In our app, tapping on the name of a checklist &mdash; “To Do”, for example &mdash; slides in the screen that contains the to-do items from that list. A tap on the “back button” in the upper-left corner takes you back to the previous screen with a swift animation. That is the navigation controller at work; you have no doubt seen it before in other apps.</li>
</ul>

<p>Navigation controllers and table views are often used together:</p>

<figure class="image"><figcaption>The blue bar at the top is the navigation bar. The list is the table view.</figcaption><img src="HTML/Figures/Navigation_bar_and_table_view.png" alt="The blue bar at the top is the navigation bar. The list is the table view."/></figure>

<p>If you take a look at the apps that come with your iPhone &mdash; Calendar, Notes, Contacts, Mail, YouTube &mdash; you’ll notice that even though they look slightly different, all these apps still work in very much the same way. That’s because they all use table views and navigation controllers. (Some of the apps in the picture also have a tab bar at the bottom, something we’ll talk about in the next tutorial.)</p>

<figure class="image"><figcaption>These are all table views inside navigation controllers: YouTube, Calendar, Notes, iPod/Music</figcaption><img src="HTML/Figures/Standard_apps.png" alt="These are all table views inside navigation controllers: YouTube, Calendar, Notes, iPod/Music"/></figure>

<p>If you want to learn how to program iOS apps, you need to master these two components as they make an appearance in almost every app. That’s exactly what we’ll focus on in this tutorial. You’ll also learn how to pass data from one screen to another, a very important topic that often puzzles beginners.</p>

<p>When you’re done with this lesson, the concepts <em>view controller</em>, <em>table view</em> and <em>delegate</em> will be so familiar to you that you can program them in your sleep (although I hope you’ll dream of other things).</p>

<p>This is a very long read with a lot of source code, so take your time to let it all sink in. I encourage you to experiment with the code that we will be writing. Change stuff and see what it does, even if it breaks the app. Playing with the code is the quickest way to learn!</p>

<h3>The Checklists design</h3>

<p>Just so you know what you’re in for, here is an overview of how the Checklists app will work:</p>

<figure class="image"><figcaption>All the screens of the Checklists app</figcaption><img src="HTML/Figures/App_overview.png" alt="All the screens of the Checklists app"/></figure>

<p>The main screen of the app shows all your checklists (1). You can create multiple lists to organize your to-do items. A checklist has a name, an icon, and zero or more items. You can edit the name and icon of a checklist in the Add/Edit Checklist screen (2) and (3).</p>

<p>You tap on the checklist’s name to view its to-do items (4). An item has a description, a checkmark to mark the item as done, and an optional due date. You can edit the item in the Add/Edit Item screen (5) and (6).</p>

<p>The app uses local notifications to automatically notify the user of checklist items that have their “remind me” option set, even if the app isn’t running (7). Pretty cool.</p>

<hr>

<h2>Playing with table views</h2>

<p>Seeing as table views are so important, we will start our app by examining how table views work. Because I always like to split up the workload into small, simple steps, this is what we’re going to do in this first section:</p>

<ol>
<li>Put a table view on our app’s screen</li>
<li>Put data into that table view</li>
<li>Allow the user to tap on a row in the table to toggle a checkmark on and off</li>
</ol>

<p>Once we have these basics up and running, we’ll keep adding new functionality to it over the course of this tutorial until we end up with the full-blown app.</p>

<p><strong>&raquo;</strong> Launch Xcode and start a new project. Choose the Single View Application template:</p>

<figure class="image"><figcaption>Choosing the Xcode template</figcaption><img src="HTML/Figures/Xcode_Single_View_Application_template.png" alt="Choosing the Xcode template"/></figure>

<p>Xcode will ask you to fill out a few options:</p>

<figure class="image"><figcaption>Choosing the template options</figcaption><img src="HTML/Figures/Xcode_app_template_options.png" alt="Choosing the template options"/></figure>

<p><strong>&raquo;</strong> Fill out these options as follows:</p>

<ul>
<li>Product Name: Checklists</li>
<li>Company Identifier: Use your own identifier here, using reverse domain name notation</li>
<li>Class Prefix: Checklists</li>
<li>Device Family: iPhone</li>
<li>Use Storyboard: Check this item</li>
<li>Use Automatic Reference Counting: Check this item</li>
<li>Include Unit Tests: Do not check this item</li>
</ul>

<p><strong>&raquo;</strong> Press Next and choose a location for the project.</p>

<p>These steps are similar to what we did in the previous tutorial, except that now we enabled the Use Storyboard option.</p>

<p>You can run the app if you want but at this point it just consists of a white screen.</p>

<p>Our app will run in portrait orientation only but the project that Xcode just generated also includes the landscape orientation.</p>

<p><strong>&raquo;</strong> Click on the Checklists project item at the top of the Project Navigator, then on the Checklists target and select the Summary tab. Under Supported Device Orientations, de-select the Landscape Left and Landscape Right buttons so that only Portrait is selected.</p>

<figure class="image"><figcaption>The Supported Device Orientations setting</figcaption><a href="HTML/Figures/Supported_device_orientations.png" target="_blank"><img src="HTML/Figures/Thumbnail-Supported_device_orientations.png" alt="The Supported Device Orientations setting"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Supported_device_orientations.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>Just changing this setting is not enough. As you’ve seen in the previous tutorial we also need to alter the <code class="objc">shouldAutorotateToInterfaceOrientation</code> method.</p>

<p><strong>&raquo;</strong> Open ChecklistsViewController.m in the editor and make the following change:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>shouldAutorotateToInterfaceOrientation<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIInterfaceOrientation</span><span class="br0">&#41;</span>interfaceOrientation
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#40;</span>interfaceOrientation <span class="sy0">==</span> <span class="kw7">UIInterfaceOrientationPortrait</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We’ve done this before, so this should be no problem for you. The difference is that this time we only allow portrait instead of landscape.</p>

<p>Note: Make sure it says <code class="objc"><span class="sy0">==</span></code> and not <code class="objc"><span class="sy0">!=</span></code>. The Xcode template already put in a version of this method that uses the <code class="objc"><span class="sy0">!=</span></code> operator, but that is the wrong way round.</p>

<aside>
<h3>Upside down</h3>

<p>There is also a Portrait Upside Down orientation but we won’t use it. If your app supports Portrait Upside Down, then users are able to rotate their iPhone so that the Home button is at the top of the screen instead of at the bottom. That may be confusing, especially when the user receives a phone call. If they were to answer with the phone upside down, the microphone is at the wrong end. iPad apps, on the other hand, are supposed to support all four orientations including portrait upside-down.</p>

</aside>

<p>Important: If you’re using Xcode 4.5 or better, make sure you set the Deployment Target to 5.0 and not 6.0 or higher:</p>

<figure class="image"><figcaption>Setting the Deployment Target version number for the project</figcaption><img src="HTML/Figures/Change_Deployment_Target.png" alt="Setting the Deployment Target version number for the project"/></figure>

<p>It’s always best to compile against the latest version of the SDK (Software Development Kit). In Xcode 4.5 that is the iOS 6.0 SDK. You can still make apps that run on older versions of iOS, but in order to enable that you must set the Deployment Target field to the oldest version that you wish to support.</p>

<h3>Storyboards</h3>

<p>For this app we will use <em>storyboarding</em>, a new technique introduced with iOS 5 that makes apps easier and quicker to write. Before iOS 5 you had to make a separate nib file for each  of your app’s screens but with storyboarding the designs for all your view controllers are combined into a single Storyboard file.</p>

<p>As you can see in the Project Navigator on the left side of the screen, Xcode automatically made the ChecklistsViewController.h and .m files for us, which contain the view controller for the main screen, but there is no corresponding ChecklistsViewController.xib. Because we chose “Use Storyboard” when we created the project, this nib has been replaced by MainStoryboard.storyboard.</p>

<figure class="image"><figcaption>The Storyboard file in the Project Navigator</figcaption><img src="HTML/Figures/Storyboard_in_Project_Navigator.png" alt="The Storyboard file in the Project Navigator"/></figure>

<p><strong>&raquo;</strong> Click on MainStoryboard.storyboard to select it.</p>

<p>The Xcode window turns into something that looks a lot like the Interface Builder we’ve seen before. This is the Storyboard editor. It works almost the same way except that you can have multiple view controllers in the same canvas. Recall that a view controller represents one screen of your app. In storyboard terminology, each view controller is named a “scene”.</p>

<figure class="image"><figcaption>The Storyboard editor with our app’s only scene</figcaption><a href="HTML/Figures/MainStoryboard.png" target="_blank"><img src="HTML/Figures/Thumbnail-MainStoryboard.png" alt="The Storyboard editor with our app’s only scene"/></a><br><span class="enlarge-image"><a href="HTML/Figures/MainStoryboard.png" target="_blank">(Click to enlarge)</a></span></figure>

<aside>

<p>Important: If you’re using Xcode 4.5 or better, you should first disable Auto Layout. This is a new feature from iOS 6 for making advanced user interface designs. Auto Layout is enabled by default on Xcode 4.5 and up, but we won’t need it in these tutorials. Auto Layout only works on iOS 6 and later, so by turning it off our apps will also be able to run on iOS 5.</p>

<p><strong>&raquo;</strong> Open the Utilities pane and go to the File Inspector. Uncheck the Use Autolayout option:</p>

<figure class="image"><figcaption>Disabling Auto Layout (Xcode 4.5 and better only)</figcaption><img src="HTML/Figures/Disable_Auto_Layout.png" alt="Disabling Auto Layout (Xcode 4.5 and better only)"/></figure>

<p>The Auto Layout setting applies to the entire storyboard, so you only have to do this once.</p>

</aside>

<p><strong>&raquo;</strong> Remove the Checklists View Controller scene from the storyboard so that the canvas is empty (the pane to the left should say “No Scenes”).</p>

<p>We’re deleting this scene because we don’t want a regular view controller but a so-called <em>table view controller</em>. This is a special type of view controller that makes working with table views a little easier.</p>

<p>To change <code class="objc">ChecklistsViewController</code>’s type to a table view controller, we first have to edit its .h file.</p>

<p><strong>&raquo;</strong> Click on ChecklistsViewController.h to open it in the source code editor and change the <code class="objc"><span class="kw1">@interface</span></code> line from this:</p>

<figure class="code"><figcaption>ChecklistsViewController.h</figcaption><pre class="objc"><span class="kw1">@interface</span> ChecklistsViewController <span class="sy0">:</span> <span class="kw7">UIViewController</span></pre></figure>

<p>to this:</p>

<figure class="code"><figcaption>ChecklistsViewController.h</figcaption><pre class="objc"><span class="kw1">@interface</span> ChecklistsViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span></pre></figure>

<p>With this change we tell the Objective-C compiler that the view controller is now a <code class="objc"><span class="kw7">UITableViewController</span></code> instead of a regular <code class="objc"><span class="kw7">UIViewController</span></code>.</p>

<p><strong>&raquo;</strong> Go back to the Storyboard editor and drag a Table View Controller from the Object Library (bottom-right corner) into the canvas:</p>

<figure class="image"><figcaption>Dragging a Table View Controller into the Storyboard editor</figcaption><a href="HTML/Figures/Drag_Table_View_Controller_into_Storyboard.png" target="_blank"><img src="HTML/Figures/Thumbnail-Drag_Table_View_Controller_into_Storyboard.png" alt="Dragging a Table View Controller into the Storyboard editor"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Drag_Table_View_Controller_into_Storyboard.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>This adds a Table View Controller scene to the storyboard.</p>

<p><strong>&raquo;</strong> Go to the Identity Inspector (the third tab in the inspectors pane on the right of the Xcode window) and under Custom Class type “ChecklistsViewController” (or choose it using the blue arrow).</p>

<p>The name of the scene in the Scene List on the left changes to “Checklists View Controller Scene”. (When you do this, make sure the actual Table View Controller is selected, not the Table View inside it. There should be a fat blue border around the scene.)</p>

<figure class="image"><figcaption>Changing the Custom Class of the Table View Controller</figcaption><a href="HTML/Figures/ChecklistsViewController_custom_class.png" target="_blank"><img src="HTML/Figures/Thumbnail-ChecklistsViewController_custom_class.png" alt="Changing the Custom Class of the Table View Controller"/></a><br><span class="enlarge-image"><a href="HTML/Figures/ChecklistsViewController_custom_class.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>We have now changed our <code class="objc">ChecklistsViewController</code> from a regular controller into a table view controller. As its name implies, and as you can see in the Storyboard editor, the controller contains a Table View object. We’ll go into the difference between controllers and views soon, but for now remember that the controller is the whole screen while the table view is the object that actually draws the list.</p>

<p><strong>&raquo;</strong> Run the app.</p>

<p>Instead of a plain white screen you’ll now see an empty list. This is the table view. You can drag the list up and down but it doesn’t contain any data yet.</p>

<figure class="image"><figcaption>The app now uses a table view controller</figcaption><img src="HTML/Figures/After_changing_to_table_view_controller.png" alt="The app now uses a table view controller"/></figure>

<p>At this point Xcode may give a warning (“Unsupported Configuration: Prototype table cells must have reuse identifiers”) and we’ll fix that in a minute.</p>

<figure class="image"><figcaption>Xcode gives a warning about prototype table cells</figcaption><img src="HTML/Figures/Xcode_prototype_cell_warning.png" alt="Xcode gives a warning about prototype table cells"/></figure>

<h3>The anatomy of a table view</h3>

<p>First, let’s talk a bit more about table views. A <code class="objc"><span class="kw7">UITableView</span></code> object displays a list of things. I’m not sure why it’s named a table because a table is commonly thought of as a spreadsheet-type thing that has multiple rows and multiple columns, whereas the <code class="objc"><span class="kw7">UITableView</span></code> only has rows. It’s more of a list than a table, but I guess we’re stuck with the name now.</p>

<p>There are two styles of tables: “plain” and “grouped”. They work mostly the same but there are a few small differences. The most visible dissimilarity is that rows in the grouped style table are slightly offset from the edges and are placed inside rounded rectangles.</p>

<figure class="image"><figcaption>A plain-style table (left) and a grouped table (right)</figcaption><img src="HTML/Figures/Plain_vs_grouped_table.png" alt="A plain-style table (left) and a grouped table (right)"/></figure>

<p>The plain style is used for rows that all represent something similar, such as contacts in an address book where each row contains the name of one person. The grouped style is used when each row represents something different, such as the various attributes of one of those contacts. The grouped style table would have a name row, an address row, a phone number row, and so on. We’ll use both table styles in the Checklists app.</p>

<p>The data for a table comes in the form of <em>rows</em>. In the first version of our app, each row will correspond to a to-do item that you can check off when you’re done with it. You can potentially have many rows (tens of thousands) although that kind of design isn’t recommended. Most users will find it incredibly annoying to scroll through ten thousand rows to find the one they want, and who can blame them...</p>

<p>Tables display their data in <em>cells</em>. A cell is related to a row but it’s not exactly the same. A cell is a view that shows a row of data that happens to be visible at that moment. If your table can show 10 rows at a time on the screen, then it only has 10 cells, even though there may be hundreds of rows with actual data. Whenever a row scrolls off the screen and becomes invisible, its cell will be re-used for a new row that scrolls into the screen.</p>

<figure class="image"><figcaption>Cells display the contents of rows</figcaption><img src="HTML/Figures/Cells_and_rows.png" alt="Cells display the contents of rows"/></figure>

<p>Until iOS 5 you had to put in quite a bit of effort to create cells for your tables but now we have a very handy new feature named <em>prototype cells</em> that lets you design your cells visually in the Storyboard editor.</p>

<p><strong>&raquo;</strong> Go to the Storyboard editor and click the empty cell to select it. It will become blue:</p>

<figure class="image"><figcaption>Selecting the prototype cell</figcaption><a href="HTML/Figures/Prototype_cell.png" target="_blank"><img src="HTML/Figures/Thumbnail-Prototype_cell.png" alt="Selecting the prototype cell"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Prototype_cell.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> Drag a Label from the Object Library into this cell. Give the label some placeholder text: “Checklist Item”. Set its font to System Bold, size 18. Make sure the label spans the entire width of the cell (but leave a small margin on the sides). Uncheck Autoshrink.</p>

<figure class="image"><figcaption>Adding the label to the prototype cell</figcaption><a href="HTML/Figures/Prototype_cell_with_label.png" target="_blank"><img src="HTML/Figures/Thumbnail-Prototype_cell_with_label.png" alt="Adding the label to the prototype cell"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Prototype_cell_with_label.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>Besides the label we will also add a checkmark to the cell’s design. The checkmark is provided by something called the <em>accessory</em>, which is a built-in subview that appears on the right side of the cell. You can choose from a few standard accessory controls or provide your own.</p>

<p><strong>&raquo;</strong> Select the Table View Cell. Inside the Attributes Inspector set the Accessory field to Checkmark:</p>

<figure class="image"><figcaption>Changing the accessory to get a checkmark</figcaption><img src="HTML/Figures/Accessory_checkmark.png" alt="Changing the accessory to get a checkmark"/></figure>

<p>Our design now looks like this:</p>

<figure class="image"><figcaption>The design of the prototype cell: a label and a checkmark</figcaption><img src="HTML/Figures/Prototype_cell_with_checkmark.png" alt="The design of the prototype cell: a label and a checkmark"/></figure>

<p>You may want to resize the label a bit so that it doesn’t overlap the checkmark.</p>

<p>We also need to set a <em>reuse identifier</em> on the cell. This is an internal name that the table view uses to find free cells to reuse when rows scroll off the screen and new rows must become visible. The table needs to assign cells to those new rows and recycling existing cells is more efficient than creating new cells. This technique is what makes your table views scroll smoothly.</p>

<p>Reuse identifiers are also important for when you want to display different types of cells in the same table. For example, one type of cell could have an image and a label and another could have a label and a button. You would give each cell type its own identifier, so the table view can assign the right cell to the right row.</p>

<p>Our app has only one type of cell but we still need to give it an identifier.</p>

<p><strong>&raquo;</strong> Type “ChecklistItem” into the Table View Cell’s Identifier field. That should make Xcode shut up about the warning it gave earlier.</p>

<figure class="image"><figcaption>Giving the table view cell a reuse identifier</figcaption><img src="HTML/Figures/Cell_identifier.png" alt="Giving the table view cell a reuse identifier"/></figure>

<p><strong>&raquo;</strong> Run the app and you’ll see... exactly the same as before. The table is still empty.</p>

<p>We only added a cell design to the table, not actual rows. Remember that the cell is just the visual representation of the row, not the actual data. To add data to the table, we have to write some code.</p>

<h3>The data source</h3>

<p><strong>&raquo;</strong> Head on over to ChecklistsViewController.m and add the following methods right before the <code class="objc"><span class="kw1">@end</span></code> line at the bottom of the file:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="nu0">1</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p>These two methods are part of <code class="objc"><span class="kw7">UITableView</span></code>’s <em>data source</em> protocol. The data source is the link between your data and the table view. Usually the view controller plays the role of data source and therefore implements these methods.</p>

<p>The table view needs to know how many rows of data it has and how it should display each of those rows. But you can’t simply dump that data into the table view’s lap and be done with it. You don’t say: “Dear table view, here are my 100 rows, now go show them on the screen.” Instead, you say to the table view: “This view controller is now your data source. You can ask it questions about the data anytime you feel like it.”</p>

<p>Once it is hooked up to a data source, the table view sends a <code class="objc">numberOfRowsInSection</code> message when it wants to know how many rows there are. And when the table view needs to display a particular row it sends the <code class="objc">cellForRowAtIndexPath</code> message to ask the data source for a cell.</p>

<p>You see this type of pattern all the time in iOS: one object does something on behalf of another object. In this case, the <code class="objc">ChecklistsViewController</code> works to provide the data to the table view, but only when the table view asks for it.</p>

<figure class="image"><figcaption>The dating ritual of a data source and a table view</figcaption><img src="HTML/Figures/Data_source.png" alt="The dating ritual of a data source and a table view"/></figure>

<p>Our implementation of <code class="objc">numberOfRowsInSection</code> returns the value 1. This tells the table view that we just have one row. The table view then calls the <code class="objc">cellForRowAtIndexPath</code> method to obtain a cell for that row. Inside <code class="objc">cellForRowAtIndexPath</code> we simply grab a copy of the prototype cell and give that back to the table view.  This is where you would normally put the row data into the cell, but our app doesn’t have any row data yet.</p>

<p><strong>&raquo;</strong> If you haven’t already, run the app and you’ll see that we now have a row in the table:</p>

<figure class="image"><figcaption>Our table now has one row</figcaption><img src="HTML/Figures/Table_with_one_row.png" alt="Our table now has one row"/></figure>



<aside>
<h3>Methods with multiple parameters</h3>

<p>Most of the methods we have used so far took only one parameter or did not have any parameters at all, but these table view data source methods take two:</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView   <span class="co2">// parameter 1</span>
 numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section         <span class="co2">// parameter 2</span>
<span class="br0">&#123;</span>
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView   <span class="co2">// parameter 1</span>
         cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath   <span class="co2">// parameter 2</span>
<span class="br0">&#123;</span>
    . . .
<span class="br0">&#125;</span></pre>

<p>The first parameter of both methods is the <code class="objc"><span class="kw7">UITableView</span></code> object in question (the table view on whose behalf these methods are invoked) and the second parameter is either the section number in the case of <code class="objc">numberOfRowsInSection</code>, or something called the “indexPath” in the case of <code class="objc">cellForRowAtIndexPath</code>.</p>

<p>In other programming languages a method with multiple parameters typically looks like this:</p>

<pre class="objc no-border"><span class="kw1">void</span> numberOfRowsInSection<span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span>tableView, <span class="kw5">NSInteger</span> section<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    . . .
<span class="br0">&#125;</span></pre>

<p>But that’s not the way we do it in Objective-C. It may look a little weird if you’re coming from another language, but once you get used to it you’ll find that this notation is actually quite readable.</p>

<p>To summarize, these are the various parts that make up a method declaration:</p>

<figure class="image"><figcaption>The different parts in a method name</figcaption><img src="HTML/Figures/Method_name.png" alt="The different parts in a method name"/></figure>



<p>The name of this method is officially <code class="objc">tableView<span class="sy0">:</span>numberOfRowsInSection<span class="sy0">:</span></code> (including the colons). If you pronounce that out loud, it actually makes sense. It asks for the number of rows in a particular section in a particular table view.</p>

</aside>

<p><strong>Exercise:</strong> Modify the app so now it shows five rows. <strong>◼</strong></p>

<p>That shouldn’t have been too hard:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="nu0">5</span>;
<span class="br0">&#125;</span></pre></figure>

<p>If you were tempted to go into the Storyboard editor and duplicate the prototype cell there five times, then you were confusing cells with rows.</p>

<p>When we make <code class="objc">numberOfRowsInSection</code> return the number 5, we tell the table view that there will be five rows. The table view then calls <code class="objc">cellForRowAtIndexPath</code> five times, once for each row.</p>

<p>Because <code class="objc">cellForRowAtIndexPath</code> currently just returns a copy of the prototype cell, our table view now shows five identical rows:</p>

<figure class="image"><figcaption>Our table now has five identical rows</figcaption><img src="HTML/Figures/Table_with_five_identical_rows.png" alt="Our table now has five identical rows"/></figure>

<p>There are several ways that we can create cells in <code class="objc">cellForRowAtIndexPath</code> but by far the easiest approach is to add a prototype cell to the table view (as we’ve done in the Storyboard editor) and then call <code class="objc"><span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="br0">&#93;</span></code> with that cell’s reuse identifier. It sounds scary but this will simply make a new copy of the prototype cell if necessary or recycle an existing cell that is no longer in use.</p>

<p>Once we have a cell, we should fill it up with the data from the corresponding row and give it back to the table view. That’s what we’ll do in the next section.</p>

<aside>
<h3>Index paths</h3>

<p>You’ve seen that the table view asks the data source for a cell using the <code class="objc">cellForRowAtIndexPath</code> method. So what is an <em>index-path</em>?</p>

<p><code class="objc"><span class="kw5">NSIndexPath</span></code> is simply an object that points to a specific row in the table. It is a combination of a row number and a section number, that’s all. When the table view asks the data source for a cell, you can look at the row number inside the <code class="objc">indexPath.row</code> property to find out for which row this cell is intended.</p>

<p>It is also possible for tables to group rows into sections. In an address book app you might sort contacts by last name. All contacts whose last name starts with “A” are grouped into their own section, all contacts whose last name starts with “B” are in another section, and so on. To find out to which section a row belongs, you would look at the <code class="objc">indexPath.section</code> property. The Checklists app has no need for this kind of grouping, so we’ll ignore the <code class="objc">section</code> property of <code class="objc"><span class="kw5">NSIndexPath</span></code> for now.</p>

<p>Note: Computers start counting at 0. If you have a list of 4 items, they are counted as 0, 1, 2 and 3. It may seem a little silly at first, but that’s just the way programmers do things. Therefore, for the first row in the first section, <code class="objc">indexPath.row</code> is 0 and <code class="objc">indexPath.section</code> is also 0. The second row has row number 1, the third row is row 2, and so on. Counting from 0 may take some getting used to, but after a while it becomes natural and you’ll start counting at 0 even when you’re out for groceries.</p>

</aside>

<p>Currently the rows (or rather the cells) all contain the placeholder text “Checklist Item”. Let’s give each row a different text.</p>

<p><strong>&raquo;</strong> Open the Storyboard and select the label inside the table view cell. Go to the Attributes Inspector and set the Tag field to 1000.</p>

<figure class="image"><figcaption>Set the label’s tag to 1000</figcaption><img src="HTML/Figures/Tag_attribute.png" alt="Set the label’s tag to 1000"/></figure>

<p>A <em>tag</em> is a numeric identifier that we can give to a user interface control, or any type of view really, in order to easily look it up later. Why the number 1000? No particular reason. It should be something other than 0, as that is the default value for all tags. 1000 is as good a number as any.</p>

<p>Note: Double check to make sure you set the tag on the <em>label</em>. It’s a common mistake to set it on the table view cell itself instead of the label and then the results won’t be what you expect!</p>

<p><strong>&raquo;</strong> In ChecklistsViewController.m, change <code class="objc">cellForRowAtIndexPath</code> to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw7">UILabel</span> <span class="sy0">*</span>label <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Walk the dog&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Brush my teeth&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Learn iOS development&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Soccer practice&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Eat ice cream&quot;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p>You’ve already seen the first line, which gets a copy of the prototype cell (either a new one or a recycled one) and puts it into the <code class="objc">cell</code> local variable:</p>

<pre class="objc"><span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;</pre>

<p>The first new line in this method is:</p>

<pre class="objc"><span class="kw7">UILabel</span> <span class="sy0">*</span>label <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span>;</pre>

<p>Here we ask the table view cell for the view with tag 1000. That is the tag we just set on our label in the Storyboard editor, so this returns a reference to that <code class="objc"><span class="kw7">UILabel</span></code> object. Using tags is a handy trick to get a reference to a control without having to make a <code class="objc"><span class="kw1">@property</span></code> for it.</p>

<p><strong>Exercise:</strong> Why can’t we simply add an outlet to the view controller and connect the cell’s label to that property in the Storyboard editor? <strong>◼</strong></p>

<p>Answer: There will likely be more than one cell in the table (at least enough of them to cover all the visible rows) and each cell will have its own label. If we connected the label from the prototype cell to an outlet on the view controller, that property would only refer to the label from one of these cells, not all of them.</p>

<p>Since the label belongs to the cell and not to the view controller as a whole, we can’t make an outlet for it on the view controller. (That doesn’t mean you cannot use properties with table view cells at all. In the <a href="http://www.raywenderlich.com/ios-apprentice">MyLocations tutorial</a> I’ll show you how to use properties for the controls in your table view cells.)</p>

<p>Back to the code. The next bit shouldn’t give you too much trouble:</p>

<pre class="objc"><span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Walk the dog&quot;</span>;
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Brush my teeth&quot;</span>;
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Learn iOS development&quot;</span>;
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Soccer practice&quot;</span>;
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Eat ice cream&quot;</span>;
<span class="br0">&#125;</span></pre>

<p>You have seen this <code class="objc"><span class="kw1">if</span> <span class="sy0">-</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="sy0">-</span> <span class="kw1">else</span></code> structure before. We simply look at the value of <code class="objc">indexPath.row</code>, which contains the row number, and change the label’s text accordingly. The cell for the first row &mdash; remember that we start counting at index 0 &mdash; gets the text “Walk the dog”, the cell for the second row gets the text “Brush my teeth”, and so on.</p>

<p><strong>&raquo;</strong> Run the app and see that we have five rows, each with their own text:</p>

<figure class="image"><figcaption>The rows in the table now have their own text</figcaption><img src="HTML/Figures/Table_with_five_different_rows.png" alt="The rows in the table now have their own text"/></figure>

<p>That is how you write the <code class="objc">cellForRowAtIndexPath</code> method to provide data to the table. You first get a <code class="objc"><span class="kw7">UITableViewCell</span></code> object and then change the contents of that cell based on the row number from <code class="objc"><span class="kw5">NSIndexPath</span></code>.</p>

<p>Just for the fun of it, let’s put 100 rows into the table.</p>

<p><strong>&raquo;</strong> Change the code to the following:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="nu0">100</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw7">UILabel</span> <span class="sy0">*</span>label <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Walk the dog&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Brush my teeth&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Learn iOS development&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Soccer practice&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Eat ice cream&quot;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p>It is mostly the same as before, except that <code class="objc">numberOfRowsInSection</code> returns 100 and <code class="objc">cellForRowAtIndexPath</code> uses a slightly different method to determine which text to display where:</p>

<pre class="objc"><span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">%</span> <span class="nu0">5</span> <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
<span class="br0">&#125;</span></pre>

<p>This uses the modulo operator <code class="objc"><span class="sy0">%</span></code>, which we’ve used in Bull’s Eye to help generate random numbers, to determine what row we’re on. The first row, as well as the sixth, eleventh, sixteenth and so on, will show the text “Walk the dog”. The second, seventh and twelfth row will show “Brush my teeth”. The third, eight and thirteenth row will show “Learn iOS Development”. And so on...</p>

<p>I think you get the picture, every five rows we repeat these lines. Rather than typing in all the possibilities all the way up to a hundred, we let the computer calculate this for us (that is what they are good at):</p>

<pre>
First row:     0 % 5 = 0
Second row:    1 % 5 = 1
Third row:     2 % 5 = 2
Fourth row:    3 % 5 = 3
Fifth row:     4 % 5 = 4
Sixth row:     5 % 5 = 0  (same as first row)  *** The sequence repeats here
Seventh row:   6 % 5 = 1  (same as second row)
Eighth row:    7 % 5 = 2  (same as third row)
Ninth row:     8 % 5 = 3  (same as fourth row)
Tenth row:     9 % 5 = 4  (same as fifth row)
Eleventh row: 10 % 5 = 0  (same as first row)  *** The sequence repeats again
Twelfth row:  11 % 5 = 1  (same as second row)
and so on...
</pre>

<p>If this makes no sense to you at all, then feel free to ignore it. We’re just using this trick to quickly get a large table filled up.</p>

<p><strong>&raquo;</strong> Run the app and you should see this:</p>

<figure class="image"><figcaption>The table now has 100 rows</figcaption><img src="HTML/Figures/Table_with_100_rows.png" alt="The table now has 100 rows"/></figure>

<p><strong>Exercise:</strong> How many cells do you think this table view uses? <strong>◼</strong></p>

<p>Answer: There are 100 rows but only 12 fit on the screen at a time. If you count the number of visible rows in the screenshot above you’ll get up to 11 &mdash; or rather 10-and-a-half because the last cell is only partially visible &mdash; but it’s possible to scroll the table in such a way that the top cell is still visible and a new cell is pulled in from below. So that makes at least 12 cells.</p>

<p>If you scroll really fast, then I guess it is possible that the table view needs to make a few more temporary cells, but I’m not sure about that. Is this important to know? Not really. You should let the table view take care of juggling the cells behind the scenes. All you have to do is give the table view a cell when it asks for it and fill it up with the data from the corresponding row.</p>

<h3>Tapping on the rows</h3>

<p>When you tap a row, notice that it colors blue. The checkmark turns white but the label text doesn’t. When you let go of the row, it stays selected. We are going to change this so that tapping the row will toggle the checkmark on and off.</p>

<figure class="image"><figcaption>A tapped row stays blue</figcaption><img src="HTML/Figures/Tapped_row_stays_blue.png" alt="A tapped row stays blue"/></figure>

<p>Taps on rows are handled by the table view’s <em>delegate</em>. Remember that I said before that in iOS you often find objects doing something on behalf of other objects? The data source is one example of this, but the table view also depends on another little helper, the table view delegate.</p>



<aside>
<h3>The delegation pattern</h3>

<p>The concept of delegation is very common in iOS. An object will often rely on another object to help it out with certain tasks. This <em>separation of concerns</em> keeps the system simple as each object does only what it is good at and lets other objects take care of the rest. The table view offers a great example of this.</p>

<p>Because every app has its own requirements for what its data looks like, the table view must be able to deal with lots of different types of data. Instead of making the table view very complex, or requiring that you modify it to suit your own apps, its designers have chosen to delegate the duty of filling up the cells to another object, the data source.</p>

<p>The table view doesn’t really care who its data source is or what kind of data your app deals with, just that it can send the <code class="objc">cellForRowAtIndexPath</code> message and that it will receive a cell in return. This keeps the table view component simple and moves the responsibility for handling the data to where it belongs: in your code.</p>

<p>Likewise, the table view knows how to recognize when the user taps a row, but what it should do in response completely depends on the app. In our app we’ll make this toggle the checkmark but another app will likely do something totally different. Using the delegation system, the table view can simply send a message that a tap occurred and let the delegate sort it out.</p>

</aside>

<p>Usually components will have just one delegate but the table view splits up its delegate duties into two separate helpers: the <code class="objc"><span class="kw8">UITableViewDataSource</span></code> for putting rows into the table, and the <code class="objc"><span class="kw8">UITableViewDelegate</span></code> for handling taps on the rows and several other tasks. (Sometimes it’s not entirely clear to which of these a particular piece of functionality belongs so you may have to check the documentation for both.)</p>

<p>If you look at the Storyboard and Ctrl-click on the table view, you can see that the table view’s data source and delegate are both connected to the view controller. That is standard practice for a <code class="objc"><span class="kw7">UITableViewController</span></code>. (You can also use table views in regular view controllers but then you’ll have to connect the data source and delegate manually.)</p>

<figure class="image"><figcaption>The table’s data source and delegate are hooked up to the view controller</figcaption><img src="HTML/Figures/Table_view_data_source_and_delegate.png" alt="The table’s data source and delegate are hooked up to the view controller"/></figure>

<p><strong>&raquo;</strong> Add the following method to ChecklistsViewController.m, just before <code class="objc"><span class="kw1">@end</span></code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span>tableView deselectRowAtIndexPath<span class="sy0">:</span>indexPath animated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>When you now run the app and tap a row, you’ll see that the row briefly turns blue and then becomes de-selected again.</p>

<p><strong>&raquo;</strong> Let’s make <code class="objc">didSelectRowAtIndexPath</code> toggle the checkmark, so change it to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>cell.accessoryType <span class="sy0">==</span> UITableViewCellAccessoryNone<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryCheckmark;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryNone;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="br0">&#91;</span>tableView deselectRowAtIndexPath<span class="sy0">:</span>indexPath animated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>First, we get the <code class="objc"><span class="kw7">UITableViewCell</span></code> object in question. We simply ask the table view: what is the cell at this <code class="objc">indexPath</code> you’ve given me? (Note that we call <code class="objc">cellForRowAtIndexPath</code> on the table view, not on our view controller. They are different methods with the same name in different objects.)</p>

<p>Then we look at the cell’s accessory, which you can find with the <code class="objc">accessoryType</code> property. If it is “none”, then we change the accessory to a checkmark; if it was a checkmark, we change it back to none.</p>

<p>One more thing, go to the Storyboard editor and select the label from the table view cell. Set its Highlighted color to white. This is the color that the label text is drawn in when you tap on the row. By default it is black but white looks better on the dark blue background. (If you’re using Xcode 4.3, the Highlighted color is already white, so that saves you some work.)</p>

<p><strong>&raquo;</strong> Run the app and try it out. You should be able to toggle the checkmarks on the rows.</p>

<figure class="image"><figcaption>You can now tap on a row to toggle the checkmark</figcaption><img src="HTML/Figures/Tap_to_toggle_checkmarks.png" alt="You can now tap on a row to toggle the checkmark"/></figure>

<p>Sweet. However, you may have noticed there is a problem with our app. Here’s how to reproduce it:</p>

<p><strong>&raquo;</strong> Tap a row to remove the checkmark. Scroll that row off the screen and now scroll back (try scrolling really fast). The checkmark has reappeared! In addition, the checkmark seems to spontaneously disappear from other rows. What is going on here?</p>

<p>Again it’s the story of cells vs. rows: we have toggled the checkmark on the cell but the cell may be reused for another row when we’re scrolling. Whether a checkmark is set or not should be a property of the row, not the cell. Instead of using the cell’s accessory to remember whether we should show a checkmark or not, we need some way to keep track of the checked status for each row. That means it’s time to expand our data source and make it use a proper data model.</p>

<p>Phew! That was a lot of new stuff to take in, so I hope you’re still with me. If not, then take a break and start at the beginning again. You’re being introduced to a whole bunch of new concepts all at once and that can be overwhelming. But don’t fear, it’s OK if not everything makes perfect sense yet. As long as you get the gist of what’s going on, you’re good to continue. If you want to check your work, you can find the project files for the app up to this point under “01 - Table View” in the tutorial’s Source Code folder.</p>

<hr>

<h2>Model-View-Controller</h2>

<p>No tutorial on programming for iOS can escape an explanation of Model-View-Controller, or MVC for short. MVC is one of the three fundamental design patterns of iOS. You’ve already seen the other two: delegation, making one object do something on behalf of another; and target-action, connecting events such as button taps to action methods.</p>

<p>Model-View-Controller roughly means that all objects in your app can be split up into three groups:</p>

<ul>
<li><strong>Model objects.</strong> These objects contain your data and any operations on the data. For example, if you are writing a cookbook app, the model would consist of the recipes. In a game it would be the design of the levels, the score of the player and the positions of the monsters. The operations that the data model objects perform are sometimes called the <em>business rules</em> or the <em>domain logic</em>. In our app, the checklists and their to-do items form the data model.</li>

<li><strong>View objects.</strong> These objects make up the visual part of the app: images, buttons, labels, text fields, and so on. In a game the views are the visual representation of the game world, such as the monster animations and a frag counter. A view can draw itself and responds to user input, but it typically does not handle any application logic. Many views, such as <code class="objc"><span class="kw7">UITableView</span></code>, can be re-used in many different apps because they are not tied to a specific data model.</li>

<li><strong>Controller objects.</strong> The view controller is the object that connects your data model objects to the views. It listens to taps on the views, makes the data model objects do some calculations in response, and updates the views to reflect the new state of your model. The view controller is in charge.</li>
</ul>

<p>Conceptually, this is how these three building blocks fit together:</p>

<figure class="image"><figcaption>Model-View-Controller</figcaption><img src="HTML/Figures/Model-View-Controller.png" alt="Model-View-Controller"/></figure>

<p>The view controller has one main view, accessible through its <code class="objc"><span class="kw1">self</span>.view</code> property, that contains a bunch of subviews. It is not uncommon for a screen to have dozens of views all at once. The top-level view usually fills the whole screen. You design the layout of the view controller’s screen in a nib file or a Storyboard.</p>

<p>In our app, the main view is the <code class="objc"><span class="kw7">UITableView</span></code> and its subviews are the table view cells. Each cell also has several subviews of its own, namely the text label and the accessory.</p>

<p>A view controller handles one screen of the app. If your app has more than one screen, each of these has its own views and is handled by its own view controller. Your app flows from one view controller to the other.</p>

<p>You will often need to create your own view controllers but iOS also comes with ready-to-use view controllers, such as the mail compose controller that lets you write email, the image picker controller for photos, and the tweet sheet for sending Twitter messages.</p>



<aside>
<h3>Views vs view controllers</h3>

<p>Note that a view and a view controller are two different things. A view is an object that draws something on the screen, such as a button or a label. The view is what you see, the view controller is what does the work behind the scenes.</p>

<p>I see a lot of beginners give their view controllers names such as <code class="objc">FirstView</code> and <code class="objc">SecondView</code>. Don’t do that, it is very confusing! If something is a view controller, call it “ViewController” and not “View”.</p>

<p>I sometimes wish Apple had left the word “view” out of “view controller” and just called it “controller” as that is a lot less misleading. The view controller doesn’t just control a view, it also controls your model. It is the bridge that sits between the two.</p>

</aside>

<h3>Creating our data model</h3>

<p>So far we’ve put a bunch of fake data into the table view. As you saw, we cannot just use the cells to remember our data as cells get re-used all the time and their old contents get overwritten. The cell is part of the view and is just used to display the data, but that data actually comes from somewhere else: the data model.</p>

<p>The rows are the data, the cells are the views. The table view controller is the thing that ties them together as it implements the table view’s data source and delegate methods.</p>

<figure class="image"><figcaption>The table view controller (data source) gets the data from the model and puts it into the cells</figcaption><img src="HTML/Figures/Data_model_and_cells.png" alt="The table view controller (data source) gets the data from the model and puts it into the cells"/></figure>

<p>The data model for our app consists of a list of to-do items. Each of these items will get its own row in the table. For each to-do item we need to store two pieces of information: the text (“Walk the dog”, “Brush my teeth”, “Eat ice cream”) and whether the checkmark is set or not. That is two pieces of information per row, so we need two variables for each row.</p>

<p>First I’ll show you the cumbersome way to program this.  Note: this is what you shouldn’t do. It will work but it isn’t very smart. Even though this is the wrong approach, I’d still like you to follow along and copy-paste the code into Xcode and run the app. You need to understand why this approach is bad so you’ll be able to appreciate the proper solution better.</p>

<p><strong>&raquo;</strong> In ChecklistsViewController.m, add the following instance variables after the <code class="objc"><span class="kw1">@implementation</span></code> line:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> ChecklistsViewController <span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>row0text;
    <span class="kw5">NSString</span> <span class="sy0">*</span>row1text;
    <span class="kw5">NSString</span> <span class="sy0">*</span>row2text;
    <span class="kw5">NSString</span> <span class="sy0">*</span>row3text;
    <span class="kw5">NSString</span> <span class="sy0">*</span>row4text;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Change the <code class="objc">viewDidLoad</code> method into the following:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    row0text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Walk the dog&quot;</span>;
    row1text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Brush teeth&quot;</span>;
    row2text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Learn iOS development&quot;</span>;
    row3text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Soccer practice&quot;</span>;
    row4text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Eat ice cream&quot;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Change the data source methods into:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="nu0">5</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw7">UILabel</span> <span class="sy0">*</span>label <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row0text;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row1text;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row2text;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row3text;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row4text;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Run the app. It still shows the same five rows as before.</p>

<p>What have we done here? For every row we have added an instance variable with the text for that row. Those five instance variables are our data model.</p>

<p>In <code class="objc">cellForRowAtIndexPath</code> we look at <code class="objc">indexPath.row</code> to figure out which row we’re supposed to draw, and put the text from the corresponding instance variable into the cell.</p>

<p>Let’s fix the checkmark toggling logic. We no longer want to toggle the checkmark on the cell but on the row. To do this, we add five new instance variables to keep track of the “checked” state of each of our rows.</p>

<p><strong>&raquo;</strong> Add the following instance variables:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> ChecklistsViewController <span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>row0text;
    <span class="kw5">NSString</span> <span class="sy0">*</span>row1text;
    <span class="kw5">NSString</span> <span class="sy0">*</span>row2text;
    <span class="kw5">NSString</span> <span class="sy0">*</span>row3text;
    <span class="kw5">NSString</span> <span class="sy0">*</span>row4text;
&nbsp;
    <span class="kw4">BOOL</span> row0checked;
    <span class="kw4">BOOL</span> row1checked;
    <span class="kw4">BOOL</span> row2checked;
    <span class="kw4">BOOL</span> row3checked;
    <span class="kw4">BOOL</span> row4checked;
<span class="br0">&#125;</span></pre></figure>

<p>You may have seen the <code class="objc"><span class="kw4">BOOL</span></code> symbol a few times before, but this is the first time we’re using it for variables. <code class="objc"><span class="kw4">BOOL</span></code> is a datatype just like <code class="objc"><span class="kw4">int</span></code> and <code class="objc"><span class="kw5">NSString</span></code>, except that it can hold only two possible values: <code class="objc"><span class="kw2">YES</span></code> and <code class="objc"><span class="kw2">NO</span></code>. In other languages these are commonly called “true” and “false” but Objective-C uses the simpler terms <code class="objc"><span class="kw2">YES</span></code> and <code class="objc"><span class="kw2">NO</span></code> (in all capitals).</p>

<p><code class="objc"><span class="kw4">BOOL</span></code> is short for “boolean”, after Englishman George Boole who long ago invented a type of logic that forms the basis of all modern computing. The fact that computers talk in ones and zeros is largely due to him. You use <code class="objc"><span class="kw4">BOOL</span></code> variables to remember whether something is true (<code class="objc"><span class="kw2">YES</span></code>) or not (<code class="objc"><span class="kw2">NO</span></code>). The names of boolean variables often start with the verb “is” or “has”, as in <code class="objc">isHungry</code> or <code class="objc">hasIceCream</code>.</p>

<p>In our case, the ivar <code class="objc">row0checked</code> is <code class="objc"><span class="kw2">YES</span></code> if the first row has its checkmark set and <code class="objc"><span class="kw2">NO</span></code> if it hasn’t. Likewise, <code class="objc">row1checked</code> reflects whether the second row has a checkmark or not. The same thing goes for the ivars for the other rows.</p>

<p>The delegate method that handles the taps on the rows will now use these new instance variables to determine whether the checkmark for a row needs to be toggled on or off.</p>

<p><strong>&raquo;</strong> Replace <code class="objc">didSelectRowAtIndexPath</code> with the following:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw4">BOOL</span> isChecked <span class="sy0">=</span> <span class="kw2">NO</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row0checked;
        row0checked <span class="sy0">=</span> <span class="sy0">!</span>row0checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row1checked;
        row1checked <span class="sy0">=</span> <span class="sy0">!</span>row1checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row2checked;
        row2checked <span class="sy0">=</span> <span class="sy0">!</span>row2checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row3checked;
        row3checked <span class="sy0">=</span> <span class="sy0">!</span>row3checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row4checked;
        row4checked <span class="sy0">=</span> <span class="sy0">!</span>row4checked;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>isChecked<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryNone;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryCheckmark;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="br0">&#91;</span>tableView deselectRowAtIndexPath<span class="sy0">:</span>indexPath animated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We examine <code class="objc">indexPath.row</code> to find the row in question, and then look up the proper “row checked” instance variable. For the first row that is <code class="objc">row0checked</code>, for the second row it is <code class="objc">row1checked</code>, and so on. We store its value into the temporary variable <code class="objc">isChecked</code>, which we’ll use at the bottom of the method to set or remove the checkmark on the cell.</p>

<p>Then we do the following to flip the boolean value around:</p>

<pre class="objc">    row0checked <span class="sy0">=</span> <span class="sy0">!</span>row0checked;</pre>

<p>The <code class="objc"><span class="sy0">!</span></code> symbol is the <em>logical not</em> operator. There are a few other logical operators that work on <code class="objc"><span class="kw4">BOOL</span></code> values, such as <em>and</em> and <em>or</em>, which we’ll encounter soon enough. What <code class="objc"><span class="sy0">!</span></code> does is simple: it reverses the meaning of the value. If <code class="objc">row0checked</code> is <code class="objc"><span class="kw2">YES</span></code>, then <code class="objc"><span class="sy0">!</span></code> makes it <code class="objc"><span class="kw2">NO</span></code>. Conversely, <code class="objc"><span class="sy0">!</span><span class="kw2">NO</span></code> is <code class="objc"><span class="kw2">YES</span></code>. Think of <code class="objc"><span class="sy0">!</span></code> as “not”: not yes is no and not no is yes. Yes?</p>

<p><strong>&raquo;</strong> Run the app and observe... that it doesn’t work very well. You have to tap a few times on a row to actually make the checkmark go away.</p>

<p>What’s wrong here? Simple: if you don’t set a value in a <code class="objc"><span class="kw4">BOOL</span></code> variable then its default value is <code class="objc"><span class="kw2">NO</span></code>. So <code class="objc">row0checked</code> and the others think that there is no checkmark on the row, but the table draws one anyway because we set the checkmark accessory on the prototype cell. In other words: our data model (the “row checked” variables) and the views (the checkmarks inside the cells) are out-of-sync.</p>

<p>There are a few ways we could try to fix this: we could set the <code class="objc"><span class="kw4">BOOL</span></code> variables to <code class="objc"><span class="kw2">YES</span></code> to begin with, or we could remove the checkmark from the prototype cell in the Storyboard editor. Neither is a foolproof solution because what goes wrong here isn’t so much that we initialized the “row checked” values wrong or designed the prototype cell wrong, but that we forgot to set the checkmark properly in <code class="objc">cellForRowAtIndexPath</code>.</p>

<p>When you are asked for a new cell, you always should configure all of its properties. The call to <code class="objc">dequeueReusableCellWithIdentifier</code> could return a cell that was previously used for a row with a checkmark, so if our row doesn’t have a checkmark we have to remove it from the cell at this point (and vice versa). Let’s fix that.</p>

<p><strong>&raquo;</strong> Add the following method above <code class="objc">cellForRowAtIndexPath</code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>configureCheckmarkForCell<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>cell atIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw4">BOOL</span> isChecked <span class="sy0">=</span> <span class="kw2">NO</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row0checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row1checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row2checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row3checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row4checked;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>isChecked<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryCheckmark;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryNone;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>This new method looks at the cell of a certain row (specified by <code class="objc">indexPath</code>) and makes the checkmark visible if the corresponding “row checked” variable is <code class="objc"><span class="kw2">YES</span></code>, or hides it if <code class="objc"><span class="kw2">NO</span></code>.</p>

<p>We’ll call this method in <code class="objc">cellForRowAtIndexPath</code>, just before we return the cell.</p>

<p><strong>&raquo;</strong> Change <code class="objc">cellForRowAtIndexPath</code> to the following (recall that <code class="objc">. . .</code> means that the existing code at that spot doesn’t change):</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    . . .
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureCheckmarkForCell<span class="sy0">:</span>cell atIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Run the app again.</p>

<p>Now the app works just fine. Initially all the rows are unchecked. Tapping a row checks it, tapping it again unchecks it. The rows and cells are now always in sync. This guarantees that our cell always has the value that corresponds to the row.</p>

<p>Why did I make <code class="objc">configureCheckmarkForCell</code> a method of its own? Well, we can use it to simplify <code class="objc">didSelectRowAtIndexPath</code>. As you should know by now that method handles taps on the row and toggles the “row checked” variable and then updates the cell. We can simplify things by letting <code class="objc">configureCheckmarkForCell</code> do some of the work.</p>

<p><strong>&raquo;</strong> Change <code class="objc">didSelectRowAtIndexPath</code> to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row0checked <span class="sy0">=</span> <span class="sy0">!</span>row0checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row1checked <span class="sy0">=</span> <span class="sy0">!</span>row1checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row2checked <span class="sy0">=</span> <span class="sy0">!</span>row2checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row3checked <span class="sy0">=</span> <span class="sy0">!</span>row3checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row4checked <span class="sy0">=</span> <span class="sy0">!</span>row4checked;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureCheckmarkForCell<span class="sy0">:</span>cell atIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span>tableView deselectRowAtIndexPath<span class="sy0">:</span>indexPath animated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Run the app again and it should still work.</p>

<p><strong>&raquo;</strong> Add the following to <code class="objc">viewDidLoad</code> and run the app again:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    . . .
&nbsp;
    row1checked <span class="sy0">=</span> <span class="kw2">YES</span>;
    row2checked <span class="sy0">=</span> <span class="kw2">YES</span>;
    row4checked <span class="sy0">=</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Now rows 1, 2 and 4 (i.e the second, third and fifth rows) initially have a checkmark while the others don’t.</p>

<figure class="image"><figcaption>The data model and the table view cells are now always in-sync</figcaption><img src="HTML/Figures/Data_model_and_cells_are_synced.png" alt="The data model and the table view cells are now always in-sync"/></figure>

<p>This approach works, but you’ll have to agree with me the code is becoming unwieldy very quickly. For only five rows it’s doable, but what if we have 100 rows and they all need to be unique? Should we add another 95 “row text” and “row checked” instance variables to the view controller, as well as that many additional if-statements? I hope not!</p>

<p>There is a better way: arrays.</p>

<h3>Arrays</h3>

<p>An <em>array</em> is an ordered list of objects. If you think of a variable as a container of one value (or one object) then an array is a container for multiple objects. Of course, the array itself is also an object (named <code class="objc"><span class="kw5">NSArray</span></code>) that you can put into a variable. And because arrays are objects, arrays can contain other arrays.</p>

<figure class="image"><figcaption>Arrays are ordered lists that can contain objects, including other arrays</figcaption><img src="HTML/Figures/Arrays.png" alt="Arrays are ordered lists that can contain objects, including other arrays"/></figure>

<p>The objects inside an array are indexed by numbers, starting at 0 as usual. To ask the array for the first object, you do <code class="objc"><span class="br0">&#91;</span>array objectAtIndex<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span></code>. The array is <em>ordered</em>, which means that the order of the objects it contains matters. The object at index 0 always comes before the object at index 1.</p>

<p><code class="objc"><span class="kw5">NSArray</span></code> is a so-called <em>collection</em> object. There are several other collection objects, such as <code class="objc"><span class="kw5">NSDictionary</span></code> and <code class="objc"><span class="kw5">NSSet</span></code>, and they all organize their objects in a different fashion. (A dictionary contains key-value pairs, just like a real dictionary contains a list of words and a description for each of those words. A set is like an array except that the order of the objects doesn’t matter. We’ll use these other collections in later tutorials.)</p>

<p>The organization of an array is very similar to the rows from a table &mdash; they are both lists of objects in a particular order &mdash; so it makes sense that we put our data model’s rows into an array.</p>

<p>Arrays store objects, but our rows currently consist of two separate pieces of data: the text and the checked state. It would be easier if we made a single object for each row, because then the row number from the table simply becomes the index in the array. Let’s combine the text and checkmark state into a new object of our own!</p>

<p><strong>&raquo;</strong> Select the Checklists group in the Project Navigator and right click. Choose New File...</p>

<figure class="image"><figcaption>Adding a new file to the project</figcaption><img src="HTML/Figures/New_file.png" alt="Adding a new file to the project"/></figure>

<p>Under the Cocoa Touch section choose Objective-C class:</p>

<figure class="image"><figcaption>Choosing the Objective-C class template</figcaption><img src="HTML/Figures/New_file_Objective-C_class.png" alt="Choosing the Objective-C class template"/></figure>

<p>The next screen gives you some options to fill out:</p>

<figure class="image"><figcaption>Options for the new file</figcaption><img src="HTML/Figures/New_file_Objective-C_class_options.png" alt="Options for the new file"/></figure>

<p>Enter the following:</p>

<ul>
<li>Class: <code class="objc">ChecklistItem</code></li>
<li>Subclass of: <code class="objc"><span class="kw5">NSObject</span></code></li>
</ul>

<p>On Xcode 4.3 the screen has a few more options, but we will not use them here. Press Next to create the new files, ChecklistItem.h and ChecklistItem.m.</p>

<figure class="image"><figcaption>The new files are added to the Project Navigator</figcaption><img src="HTML/Figures/ChecklistItem_file_added.png" alt="The new files are added to the Project Navigator"/></figure>

<p>The files themselves look like this (without the comments at the top):</p>

<figure class="code"><figcaption>ChecklistItem.h</figcaption><pre class="objc"><span class="co1">#import &lt;Foundation/Foundation.h&gt;</span>
&nbsp;
<span class="kw1">@interface</span> ChecklistItem <span class="sy0">:</span> <span class="kw5">NSObject</span>
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>And:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="co1">#import &quot;ChecklistItem.h&quot;</span>
&nbsp;
<span class="kw1">@implementation</span> ChecklistItem
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>init
<span class="br0">&#123;</span>
    <span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="co2">// Initialization code here.</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>This is roughly the minimum amount of stuff you need in order to make a new object. Xcode added an <code class="objc">init</code> method to the object already. I’ll explain what <code class="objc">init</code> does in a minute.</p>

<p>Depending on your version of Xcode, ChecklistItem.m may not actually have an <code class="objc">init</code> method. The developers of Xcode tend to change these templates from time to time, so there may be small differences between what you see in these tutorials and what you see in Xcode. Your ChecklistItem.m may simply look like this:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="co1">#import &quot;ChecklistItem.h&quot;</span>
&nbsp;
<span class="kw1">@implementation</span> ChecklistItem
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>If your ChecklistItem.m has no <code class="objc">init</code> then it will use the standard init method. Because <code class="objc">init</code> from the Objective-C class template doesn’t actually do anything yet, it can be left out. More about these methods later.</p>

<p><strong>&raquo;</strong> Add the following to ChecklistItem.h, before the <code class="objc"><span class="kw1">@end</span></code> line:</p>

<figure class="code"><figcaption>ChecklistItem.h</figcaption><pre class="objc"><span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">copy</span><span class="br0">&#41;</span> <span class="kw5">NSString</span> <span class="sy0">*</span>text;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">assign</span><span class="br0">&#41;</span> <span class="kw4">BOOL</span> checked;</pre></figure>

<p>These are the two data items that we’re adding to the object, in the form of properties. The <code class="objc">text</code> property will store the description of the checklist item (the text that will appear in the table view cell’s label) and the <code class="objc">checked</code> property determines whether the cell gets a checkmark or not.</p>

<p>Why are we adding these data items as properties and not as instance variables? Instance variables are really supposed to be used on the insides of objects only, they should not be visible to other objects. In this case we do want the text and checked values to be visible. They are part of the <code class="objc">ChecklistItem</code> object’s so-called <em>public interface</em> &mdash; it is no coincidence that they are placed in the <code class="objc"><span class="kw1">@interface</span></code> section.</p>

<p>Unlike the properties we’ve used in the previous tutorial, these two do not have the <code class="objc"><span class="kw4">IBOutlet</span></code> symbol as they are not outlets. You only declare something as an outlet when you want to be able to make connections to it from Interface Builder or the Storyboard editor. That is not the case for these properties as they are part of our data model, not the user interface of the app.</p>

<p>As always, we need to <code class="objc"><span class="kw1">@synthesize</span></code> our properties.</p>

<p><strong>&raquo;</strong> Add the following to ChecklistItem.m below the <code class="objc"><span class="kw1">@implementation</span></code> line:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> text, checked;</pre></figure>

<p>That’s all for now. The <code class="objc">ChecklistItem</code> object currently only serves to combine the text and the checked flag into one object.</p>

<p>Before we get around to using an array, let’s replace the <code class="objc"><span class="kw5">NSString</span></code> and <code class="objc"><span class="kw4">BOOL</span></code> variables in the view controller with <code class="objc">ChecklistItem</code> objects.</p>

<p>First, we need to tell the view controller about the <code class="objc">ChecklistItem</code> object or it won’t be able to use it. To do so, we add an <code class="objc"><span class="co1">#import</span></code> statement to the top of the file.</p>

<p><strong>&raquo;</strong> Add the following to ChecklistsViewController.m above the <code class="objc"><span class="kw1">@implementation</span></code> line:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="co1">#import &quot;ChecklistItem.h&quot;</span></pre></figure>

<p><strong>&raquo;</strong> Remove the old <code class="objc"><span class="kw5">NSString</span></code> and <code class="objc"><span class="kw4">BOOL</span></code> instance variables and replace them with <code class="objc">ChecklistItem</code> objects:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> ChecklistsViewController <span class="br0">&#123;</span>
    ChecklistItem <span class="sy0">*</span>row0item;
    ChecklistItem <span class="sy0">*</span>row1item;
    ChecklistItem <span class="sy0">*</span>row2item;
    ChecklistItem <span class="sy0">*</span>row3item;
    ChecklistItem <span class="sy0">*</span>row4item;
<span class="br0">&#125;</span></pre></figure>

<p>Previously we filled in the “row text” and “row checked” variables in <code class="objc">viewDidLoad</code>. We’ll do the same for our <code class="objc">ChecklistItem</code> objects.</p>

<p><strong>&raquo;</strong> Change <code class="objc">viewDidLoad</code> to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    row0item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    row0item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Walk the dog&quot;</span>;
    row0item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
&nbsp;
    row1item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    row1item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Brush my teeth&quot;</span>;
    row1item.checked <span class="sy0">=</span> <span class="kw2">YES</span>;
&nbsp;
    row2item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    row2item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Learn iOS development&quot;</span>;
    row2item.checked <span class="sy0">=</span> <span class="kw2">YES</span>;
&nbsp;
    row3item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    row3item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Soccer practice&quot;</span>;
    row3item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
&nbsp;
    row4item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    row4item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Eat ice cream&quot;</span>;
    row4item.checked <span class="sy0">=</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We’re essentially doing the same thing as before, except that this time the <code class="objc">text</code> and <code class="objc">checked</code> variables are not instance variables of the view controller but properties of the <code class="objc">ChecklistItem</code> objects.</p>

<p>We begin by creating a new <code class="objc">ChecklistItem</code> object:</p>

<pre class="objc">    row0item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;</pre>

<p>You’ve seen something similar in the first tutorial when we created the <code class="objc"><span class="kw7">UIAlertView</span></code>. There we did:</p>

<pre class="objc">    alertView <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UIAlertView</span> alloc<span class="br0">&#93;</span> initWithTitle<span class="sy0">:</span>...<span class="br0">&#93;</span>;</pre>

<p>That is how you create objects in Objective-C, you first call <code class="objc">alloc</code> to reserve memory for this new object, followed by a form of <code class="objc">init</code> to <em>initialize</em> this object. Initialization means that you put the object in a usable state, usually by giving your instance variables and properties meaningful values.</p>

<p>Our <code class="objc">ChecklistItem</code> object has an initialization method that is simply named <code class="objc">init</code>, but not all objects are as concise. The full name of the initialization method for <code class="objc"><span class="kw7">UIAlertView</span></code> is <code class="objc">initWithTitle<span class="sy0">:</span>message<span class="sy0">:</span>delegate<span class="sy0">:</span>cancelButtonTitle<span class="sy0">:</span>otherButtonTitles<span class="sy0">:</span></code>. That’s quite a mouthful! It’s possible for an object to have more than one init method, but you’ll always only call one of them (it doesn’t make sense to initialize an object twice).</p>

<p>You’ll be seeing this pattern a lot, almost every time you make a new object. First <code class="objc">alloc</code>, then <code class="objc">init</code>. This gives you an <em>instance</em> of the object, a new copy of the object in memory. In case you haven’t learned enough fancy words today, the whole process of allocation followed by initialization is also called <em>instantiation</em>.</p>

<figure class="image"><figcaption>Allocation and initialization</figcaption><img src="HTML/Figures/Allocation.png" alt="Allocation and initialization"/></figure>

<p>After creating the <code class="objc">ChecklistItem</code> object, we put values into its <code class="objc">text</code> and <code class="objc">checked</code> properties. We repeat this for the four other rows. Each row gets its own <code class="objc">ChecklistItem</code> object that we store it its own instance variable.</p>

<p><strong>&raquo;</strong> Change the other methods to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>configureCheckmarkForCell<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>cell atIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw4">BOOL</span> isChecked <span class="sy0">=</span> <span class="kw2">NO</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row0item.checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row1item.checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row2item.checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row3item.checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        isChecked <span class="sy0">=</span> row4item.checked;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>isChecked<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryCheckmark;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryNone;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw7">UILabel</span> <span class="sy0">*</span>label <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row0item.text;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row1item.text;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row2item.text;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row3item.text;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> row4item.text;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureCheckmarkForCell<span class="sy0">:</span>cell atIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row0item.checked <span class="sy0">=</span> <span class="sy0">!</span>row0item.checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row1item.checked <span class="sy0">=</span> <span class="sy0">!</span>row1item.checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row2item.checked <span class="sy0">=</span> <span class="sy0">!</span>row2item.checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row3item.checked <span class="sy0">=</span> <span class="sy0">!</span>row3item.checked;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        row4item.checked <span class="sy0">=</span> <span class="sy0">!</span>row4item.checked;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureCheckmarkForCell<span class="sy0">:</span>cell atIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span>tableView deselectRowAtIndexPath<span class="sy0">:</span>indexPath animated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Instead of using the <code class="objc">row0text</code> and <code class="objc">row0checked</code> variables, we now use <code class="objc">row0item.text</code> and <code class="objc">row0item.checked</code>. Likewise for the other rows.</p>

<p><strong>&raquo;</strong> Run the app just to make sure that everything still works.</p>

<p>The code is still unwieldy because we still need to keep around a <code class="objc">ChecklistItem</code> instance variable for each row. Time to put that array into action!</p>

<aside>
<h3>Mutable and non-mutable</h3>

<p>There are actually two types of arrays: the <em>mutable</em> array (<code class="objc"><span class="kw5">NSMutableArray</span></code>) and the <em>non-mutable</em>  or <em>immutable</em> array (<code class="objc"><span class="kw5">NSArray</span></code>). Mutable means: can be changed. An <code class="objc"><span class="kw5">NSArray</span></code>, which is non-mutable, cannot be changed once it is created. You cannot add new objects to it or remove objects from it, only access the objects that are already inside the array.</p>

<p>You see this in other places in the iOS SDK as well. <code class="objc"><span class="kw5">NSString</span></code> is also immutable. Once you’ve made an <code class="objc"><span class="kw5">NSString</span></code> object, you cannot change its text. You can only create a new string object that is derived from this one. For example, <code class="objc"><span class="br0">&#91;</span>string lowercase<span class="br0">&#93;</span></code> will create a new string with all the characters converted to lowercase. The original string object is still there, unmodified. If you need to create a string that you can change afterwards, you should use the <code class="objc"><span class="kw5">NSMutableString</span></code> object instead.</p>

<p>Note that even if you have an non-mutable array, you can still modify the objects that it contains. It is the array itself that cannot change &mdash; you cannot take objects out of it or put new objects into it &mdash; but once you have obtained a reference to one of its objects using <code class="objc"><span class="br0">&#91;</span>array objectAtIndex<span class="sy0">:</span><span class="br0">&#93;</span></code> you can do with that object what you want.</p>

<p>Think of an immutable array as being stuck in a traffic jam. The cars in front of you and behind you don’t change and no one is going anywhere, but you can certainly step out of your car and spray paint it pink.</p>

</aside>

<p>We need to use a mutable array because in our app we will let the user add new items to the list and remove items as well.</p>

<p><strong>&raquo;</strong> In ChecklistsViewController.m, throw away all the instance variables and replace them with a single <code class="objc"><span class="kw5">NSMutableArray</span></code> ivar named <code class="objc">items</code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> ChecklistsViewController <span class="br0">&#123;</span>
    <span class="kw5">NSMutableArray</span> <span class="sy0">*</span>items;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Change the <code class="objc">viewDidLoad</code> method to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    items <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
&nbsp;
    ChecklistItem <span class="sy0">*</span>item;
&nbsp;
    item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Walk the dog&quot;</span>;
    item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
    <span class="br0">&#91;</span>items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Brush my teeth&quot;</span>;
    item.checked <span class="sy0">=</span> <span class="kw2">YES</span>;
    <span class="br0">&#91;</span>items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Learn iOS development&quot;</span>;
    item.checked <span class="sy0">=</span> <span class="kw2">YES</span>;
    <span class="br0">&#91;</span>items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Soccer practice&quot;</span>;
    item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
    <span class="br0">&#91;</span>items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Eat ice cream&quot;</span>;
    item.checked <span class="sy0">=</span> <span class="kw2">YES</span>;
    <span class="br0">&#91;</span>items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This is not so different from before, except that we first make the array object:</p>

<pre class="objc">    items <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;</pre>

<p>Again, notice the <code class="objc"><span class="br0">&#91;</span><span class="br0">&#91;</span>alloc<span class="br0">&#93;</span> init...<span class="br0">&#93;</span></code> pattern to create and initialize the object. It is important to realize that just declaring that you have a variable does not automatically make the corresponding object for you. The variable is just the container for the object. You’ll still have to call <code class="objc">alloc</code> and <code class="objc">init</code> to create the object and put it into that variable.</p>

<p>When we did this,</p>

<pre class="objc"><span class="kw1">@implementation</span> ChecklistsViewController <span class="br0">&#123;</span>
    <span class="kw5">NSMutableArray</span> <span class="sy0">*</span>items;
<span class="br0">&#125;</span></pre>

<p>we just said: we have a variable named <code class="objc">items</code> that can contain an <code class="objc"><span class="kw5">NSMutableArray</span></code> object. But until we instantiate an actual <code class="objc"><span class="kw5">NSMutableArray</span></code> object and put that into <code class="objc">items</code>, the variable is empty. Its value is “nil” in programmer-speak, although some programmers like to call this “null”. You can still send messages to a <code class="objc"><span class="kw2">nil</span></code> variable, but they won’t arrive anywhere so that’s quite pointless.</p>

<p>That’s why in <code class="objc">viewDidLoad</code>, we first make the actual <code class="objc"><span class="kw5">NSMutableArray</span></code> object and stuff it into <code class="objc">items</code>. Now we can use this array object through the <code class="objc">items</code> ivar.</p>

<p><code class="objc"><span class="kw5">NSMutableArray</span></code> has an init method named <code class="objc">initWithCapacity</code> that reserves space for a certain number of items (20 in our case). That doesn’t mean the array can only store 20 items and no more! It’s just a hint that we give to the array. We expect about 20 items, but if we add more than that the array will grow to make room.</p>

<p>Each time we make a <code class="objc">ChecklistItem</code>, we now add it into the array:</p>

<pre class="objc">    item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Walk the dog&quot;</span>;
    item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
    <span class="br0">&#91;</span>items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;</pre>

<p>At the end of <code class="objc">viewDidLoad</code>, the <code class="objc">items</code> array contains five <code class="objc">ChecklistItem</code> objects. This is our new data model.</p>

<p>Now that we have all our rows in the <code class="objc">items</code> array, we can simplify our table view data source and delegate methods.</p>

<p><strong>&raquo;</strong> Change these methods to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>configureCheckmarkForCell<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>cell atIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span>items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>item.checked<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryCheckmark;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryNone;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span>items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw7">UILabel</span> <span class="sy0">*</span>label <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span>;
    label.text <span class="sy0">=</span> item.text;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureCheckmarkForCell<span class="sy0">:</span>cell atIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span>items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
    item.checked <span class="sy0">=</span> <span class="sy0">!</span>item.checked;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureCheckmarkForCell<span class="sy0">:</span>cell atIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span>tableView deselectRowAtIndexPath<span class="sy0">:</span>indexPath animated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>In each method, we do:</p>

<pre class="objc">    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span>items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;</pre>

<p>This asks the array for the <code class="objc">ChecklistItem</code> object at the index that corresponds with the row number. Once we have that object, we can simply look at its <code class="objc">text</code> and <code class="objc">checked</code> properties and do whatever we need to do. If we were to add 100 items to this list, then none of this code would need to change. It works equally well with five items as with a hundred.</p>

<p>Speaking of the number of items, we can now change <code class="objc">numberOfRowsInSection</code> to return the number of items in the array, instead of a hard-coded number.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">numberOfRowsInSection</code> method to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span>items count<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Not only is the code a lot shorter and easier to read, it can now also handle an arbitrary number of rows. That is the power of arrays.</p>

<p><strong>&raquo;</strong> Run the app and see for yourself. It should still do exactly the same as before but its internal structure is much better.</p>

<p><strong>Exercise:</strong> Add a few more rows to the table. You should only have to change <code class="objc">viewDidLoad</code> for this to work. <strong>◼</strong></p>

<h3>Cleaning up the code</h3>

<p>There are a few more things I want to do to clean up this code.</p>

<p><strong>&raquo;</strong> Make these changes:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>configureCheckmarkForCell<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>cell withChecklistItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>item.checked<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryCheckmark;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryNone;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>configureTextForCell<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>cell withChecklistItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    <span class="kw7">UILabel</span> <span class="sy0">*</span>label <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span>;
    label.text <span class="sy0">=</span> item.text;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span>items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureTextForCell<span class="sy0">:</span>cell withChecklistItem<span class="sy0">:</span>item<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureCheckmarkForCell<span class="sy0">:</span>cell withChecklistItem<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
&nbsp;
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span>items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>item toggleChecked<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureCheckmarkForCell<span class="sy0">:</span>cell withChecklistItem<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span>tableView deselectRowAtIndexPath<span class="sy0">:</span>indexPath animated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>Exercise:</strong> Spot the differences. Can you see what was changed? Can you reason why? <strong>◼</strong></p>

<p>Answer: I renamed the <code class="objc">configureCheckmarkForCell<span class="sy0">:</span>atIndexPath<span class="sy0">:</span></code> method to <code class="objc">configureCheckmarkForCell<span class="sy0">:</span>withChecklistItem<span class="sy0">:</span></code>. If you think this is a long method name, you’re in for a surprise. A lot of the object names and method names in the iOS SDK are huge, but at least that should give you a good idea of what they mean. Fortunately, Xcode has an auto-completion feature, so you only have to type the first few characters and it will automatically fill out the rest. Otherwise you’d be doing a lot of typing!</p>

<p>Why did I change this method? Previously it received an index-path and then did this to find the corresponding <code class="objc">ChecklistItem</code>:</p>

<pre class="objc">    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span>items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;</pre>

<p>But in both <code class="objc">cellForRowAtIndexPath</code> and <code class="objc">didSelectRowAtIndexPath</code> we already do that as well. So it makes more sense to pass that <code class="objc">ChecklistItem</code> object directly to the “configure” method instead of making it do the same work twice. Anything that simplifies the code is good.</p>

<p>I also added a <code class="objc">configureTextForCell<span class="sy0">:</span>withChecklistItem<span class="sy0">:</span></code> method. That sets the item’s text on the cell’s label. Previously we did that directly in <code class="objc">cellForRowAtIndexPath</code> but I thought it would be a little clearer to put that in its own method.</p>

<p>Finally, <code class="objc">didSelectRowAtIndexPath</code> no longer modifies the <code class="objc">ChecklistItem</code>’s <code class="objc">checked</code> property directly but calls a new method named <code class="objc">toggleChecked</code> on the item object. We still need to add this method to <code class="objc">ChecklistItem</code> otherwise the code won’t run.</p>

<p><strong>&raquo;</strong> Add the following to ChecklistItem.h, before <code class="objc"><span class="kw1">@end</span></code>:</p>

<figure class="code"><figcaption>ChecklistItem.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>toggleChecked;</pre></figure>

<p><strong>&raquo;</strong> Add the implementation of this method to ChecklistItem.m:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>toggleChecked
<span class="br0">&#123;</span>
    <span class="kw1">self</span>.checked <span class="sy0">=</span> <span class="sy0">!</span><span class="kw1">self</span>.checked;
<span class="br0">&#125;</span></pre></figure>

<p>As you can see, the method does exactly what <code class="objc">didSelectRowAtIndexPath</code> used to do, except that we’ve added this bit of functionality to <code class="objc">ChecklistItem</code> instead. A good object-oriented design principle is that you should let objects change their own state as much as possible. Previously, the view controller implemented this toggling behavior but now <code class="objc">ChecklistItem</code> knows how to toggle itself.</p>

<p><strong>&raquo;</strong> Run the app, and well, it still should work exactly the same as before. :-)</p>

<p>If you want to check your work, you can find the project files for the current version of the app in the folder “02 - Arrays” in the tutorial’s Source Code folder.</p>



<aside>
<h3>Clean up that mess!</h3>

<p>So what’s the point of making all of these changes if the app still works exactly the same? For one, the code is much cleaner and that helps to avoid bugs. By using an array we’ve also made the code more flexible. Our table view can now handle any number of rows.</p>

<p>You’ll find that when you are programming you are constantly restructuring your code to make it better. It’s impossible to do the whole thing 100% perfect right from the start. So we write code until it becomes messy and then we clean it up. Then after a little while it becomes a big mess again and we clean it up again. This process for cleaning up code is called <em>refactoring</em> and it’s a cycle that never ends.</p>

<p>There are a lot of programmers who never do clean up their code. The result is what we call “spaghetti code” and it’s a horrible mess to maintain. If you haven’t looked at your code for several months but then need to add a new feature or fix a bug, you may need some time to read it through to understand again how everything fits together. It’s in your own best interest to write code that is as clean as possible, otherwise untangling that spaghetti mess is no fun.</p>

</aside>

<hr>

<h2>Adding new items to the checklist</h2>

<p>So far our table view has contained a handful of fixed rows but the idea behind this app is that you can create your own lists. Therefore, we need to give the user the ability to add their own  to-do items.</p>

<p>In this section we’ll expand the app to have a so-called <em>navigation bar</em> at the top. This bar has an Add button (the big +) that opens new screen that lets you enter a name for the new to-do item. When you tap Done, the new item will be added to the list.</p>

<figure class="image"><figcaption>The + button in the navigation bar opens the Add Item screen</figcaption><img src="HTML/Figures/Adding_new_items.png" alt="The + button in the navigation bar opens the Add Item screen"/></figure>

<p>Presenting a new screen to add items is a common pattern in a lot of apps. Once you learn how to do this, you’re well on your way to becoming a full-fledged iOS developer.</p>

<p>What we’ll do in this section:</p>

<ul>
<li>Add a navigation controller</li>
<li>Put the Add button into the navigation bar</li>
<li>Add a fake item to the list when you press the Add button</li>
<li>Delete items with swipe-to-delete</li>
<li>Open the Add Item screen that lets the user type the text for the item</li>
</ul>

<p>As always, we take it in small steps. After we’ve put the Add button on the screen, we first write the code to add a “fake” item to the list. Instead of writing all of the code for the Add Item screen, we simply pretend that it already exists. Once we’ve learned how to add fake items, we can build the Add Item screen for real.</p>

<h3>Navigation controllers</h3>

<p>First, let’s add the navigation bar. You may have seen in the Object Library that there actually is an object named Navigation Bar. You can drag this into your view and put it at the top. However, we won’t do that. Instead, we will embed our view controller inside a <em>navigation controller.</em></p>

<p>Next to the table view, the navigation controller is probably the second most used iOS user interface component. It is the thing that lets you go from one page to another:</p>

<figure class="image"><figcaption>A navigation controller in action</figcaption><img src="HTML/Figures/Navigation_controller.png" alt="A navigation controller in action"/></figure>

<p>The <code class="objc"><span class="kw7">UINavigationController</span></code> takes care of most of this navigation stuff for you, which saves a lot of programming effort. You get a title in the middle of the screen and a “back” button that automatically takes the user back to the previous screen. You can put a button of your own on the right.</p>

<p>Adding a navigation controller is really easy.</p>

<p><strong>&raquo;</strong> Go to the Storyboard editor and select the Checklists View Controller scene. From the menu bar at the top of the screen, choose Editor → Embed In → Navigation Controller.</p>

<figure class="image"><figcaption>Putting the view controller inside a navigation controller</figcaption><img src="HTML/Figures/Embed_in_Navigation_Controller.png" alt="Putting the view controller inside a navigation controller"/></figure>

<p>That’s it. The Storyboard editor has now added a new Navigation Controller scene and made a relationship between it and our view controller.</p>

<figure class="image"><figcaption>The navigation controller is now linked with our view controller</figcaption><img src="HTML/Figures/Navigation_controller_linked_with_our_view_controller.png" alt="The navigation controller is now linked with our view controller"/></figure>

<p>When the app starts up, the Checklists View Controller is automatically put inside a navigation controller.</p>

<p><strong>&raquo;</strong> Run the app and try it out.</p>

<figure class="image"><figcaption>The app now has a navigation bar at the top</figcaption><img src="HTML/Figures/App_with_navigation_controller.png" alt="The app now has a navigation bar at the top"/></figure>

<p>The only thing different (visually) is that we now have a navigation bar at the top.</p>

<p><strong>&raquo;</strong> Go back to the Storyboard editor and double-click on the navigation bar inside the Checklists View Controller to make the title editable. Name it “Checklists”.</p>

<figure class="image"><figcaption>Changing the title in the navigation bar</figcaption><a href="HTML/Figures/Change_nav_bar_title.png" target="_blank"><img src="HTML/Figures/Thumbnail-Change_nav_bar_title.png" alt="Changing the title in the navigation bar"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Change_nav_bar_title.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>What you’re doing here, is changing a <em>navigation item</em> object that was automatically added to the view controller when we chose the Embed In command. The Navigation Item object contains the title and buttons that will appear in the navigation bar when this view controller becomes active.</p>

<p>Each embedded view controller has its own Navigation Item that it uses to configure what is inside the navigation bar. When the navigation controller slides a new view controller into the screen, it replaces the contents of the navigation bar with that view controller’s Navigation Item.</p>

<p><strong>&raquo;</strong> Go to the Object Library and look for Bar Button Item. Drag it into the right-side slot of the navigation bar. Be sure to use the navigation bar on the Checklists View Controller, not the one from the navigation controller!</p>

<figure class="image"><figcaption>Dragging a Bar Button Item into the navigation bar</figcaption><img src="HTML/Figures/Drag_bar_button_item.png" alt="Dragging a Bar Button Item into the navigation bar"/></figure>

<p>By default this new button is named “Item” but we want it to have a big + sign.</p>

<p><strong>&raquo;</strong> In the Attributes Inspector, choose Identifier: Add. This gives the button the + sign.</p>

<figure class="image"><figcaption>Bar Button Item attributes</figcaption><img src="HTML/Figures/Bar_Button_Item_attributes.png" alt="Bar Button Item attributes"/></figure>

<p>If you look through the Identifier list you see a lot of predefined bar button types: Add, Compose, Reply, Camera, and so on. You can use these in your own apps but only for their intended purpose. You shouldn’t use the camera icon on a button that sends an email, for example. Improper use of these icons may lead Apple to reject your app from the App Store and that sucks.</p>

<p>OK, that gives us a button. If you run the app, it should look like this:</p>

<figure class="image"><figcaption>The app with the Add button</figcaption><img src="HTML/Figures/App_with_Add_button.png" alt="The app with the Add button"/></figure>

<p>Of course, pressing the button doesn’t actually do anything because we haven’t hooked it up to an action yet. In a little while we will create the Add Item screen and show this screen when you tap the button. But before we can do that, we’ll first have to figure out how to add new rows to the table.</p>

<p>Let’s hook up the Add button to an action. You got plenty of exercise on this in the previous tutorial, so this shouldn’t be too much of a problem.</p>

<p><strong>&raquo;</strong> Add a declaration for a new action method to ChecklistsViewController.h, before <code class="objc"><span class="kw1">@end</span></code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>addItem;</pre></figure>

<p><strong>&raquo;</strong> Go to the Storyboard editor and hook up the Add button to this action. This works as before when we edited nibs, although in the Storyboard editor the scenes do not have a File’s Owner. Instead, you can Ctrl-drag to the Checklists View Controller item in the sidebar:</p>

<figure class="image"><figcaption>Ctrl-drag from Add button to View Controller</figcaption><img src="HTML/Figures/Drag_from_Add_button_to_view_controller_1.png" alt="Ctrl-drag from Add button to View Controller"/></figure>

<p>Or, even simpler, Ctrl-drag from the Add button to the view controller item in the dock area below the scene:</p>

<figure class="image"><figcaption>Ctrl-drag from Add button to View Controller (alternative method)</figcaption><img src="HTML/Figures/Drag_from_Add_button_to_view_controller_2.png" alt="Ctrl-drag from Add button to View Controller (alternative method)"/></figure>

<p>In fact, you can Ctrl-drag from the Add button to almost anywhere into the same scene to make the connection (dragging onto the status bar is a good spot).</p>

<p><strong>&raquo;</strong> After dragging, pick “addItem” from the list (under Sent Actions). Now the connection is made and a tap on the + button will send the <code class="objc">addItem</code> message to the view controller.</p>

<p>Let’s give <code class="objc">addItem</code> something to do.</p>

<p><strong>&raquo;</strong> Add the body of this new method to the bottom of ChecklistsViewController.m, just before <code class="objc"><span class="kw1">@end</span></code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>addItem
<span class="br0">&#123;</span>
    <span class="kw4">int</span> newRowIndex <span class="sy0">=</span> <span class="br0">&#91;</span>items count<span class="br0">&#93;</span>;
&nbsp;
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;I am a new row&quot;</span>;
    item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
    <span class="br0">&#91;</span>items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw5">NSIndexPath</span> <span class="sy0">*</span>indexPath <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSIndexPath</span> indexPathForRow<span class="sy0">:</span>newRowIndex inSection<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="kw5">NSArray</span> <span class="sy0">*</span>indexPaths <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObject<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.tableView insertRowsAtIndexPaths<span class="sy0">:</span>indexPaths withRowAnimation<span class="sy0">:</span>UITableViewRowAnimationAutomatic<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Inside this method we create a new <code class="objc">ChecklistItem</code> object and add it to our data model. We also have to figure out the row number of this new object and then tell the table view, “We've inserted a row at this index, please update yourself.”</p>

<p>Let’s take it section by section:</p>

<pre class="objc"><span class="kw4">int</span> newRowIndex <span class="sy0">=</span> <span class="br0">&#91;</span>items count<span class="br0">&#93;</span>;</pre>

<p>When you start the app there are 5 items in the array and 5 rows on the screen. Computers start counting at 0, so the existing rows have indexes 0, 1, 2, 3 and 4. We will add the new row to the end of the array, so the index for that new row will be 5.</p>

<p>In other words, when we’re adding a row to the end of a table the index for the new row is always equal to the number of items currently in that table. Let that sink in for a second. We put the index for the new row in the local variable <code class="objc">newRowIndex</code>.</p>

<p>The following few lines should look familiar:</p>

<pre class="objc">ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;I am a new row&quot;</span>;
item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
<span class="br0">&#91;</span>items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;</pre>

<p>You have seen this code before in <code class="objc">viewDidLoad</code>. It creates the new <code class="objc">ChecklistItem</code> object and adds it to the end of the array. Our data model now consists of 6 <code class="objc">ChecklistItem</code> objects inside the <code class="objc">items</code> array. Note that <code class="objc">newRowIndex</code> is still 5 even though <code class="objc"><span class="br0">&#91;</span>items count<span class="br0">&#93;</span></code> is now 6. That’s why we read the item count and stored this value in <code class="objc">newRowIndex</code> before we added the new item to the array.</p>

<p>Here it gets tricky:</p>

<pre class="objc"><span class="kw5">NSIndexPath</span> <span class="sy0">*</span>indexPath <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSIndexPath</span> indexPathForRow<span class="sy0">:</span>newRowIndex inSection<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;</pre>

<p>Just adding the new <code class="objc">ChecklistItem</code> object to the data model isn’t enough. We also have to tell the table view about this new row so it can add a new cell for that row. As you know by now, table views use index-paths to identify rows, so first we make an <code class="objc"><span class="kw5">NSIndexPath</span></code> object that points to our new row, using the row number from the <code class="objc">newRowIndex</code> variable. This index-path object now points to row 5 (in section 0).</p>

<pre class="objc"><span class="kw5">NSArray</span> <span class="sy0">*</span>indexPaths <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObject<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;</pre>

<p>We will use the table view method <code class="objc">insertRowsAtIndexPaths</code> to tell it about the new row, but as its name implies this method actually lets you insert multiple rows at the same time. Instead of a single <code class="objc"><span class="kw5">NSIndexPath</span></code> object, we need to give it an array of index-paths. Not very convenient, but that’s the way it is. Fortunately it is easy to create an array that contains a single index-path object using <code class="objc"><span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObject<span class="br0">&#93;</span></code>.</p>

<p>Finally, we tell the table view to insert this new row with a nice animation:</p>

<pre class="objc"><span class="br0">&#91;</span><span class="kw1">self</span>.tableView insertRowsAtIndexPaths<span class="sy0">:</span>indexPaths withRowAnimation<span class="sy0">:</span>UITableViewRowAnimationAutomatic<span class="br0">&#93;</span>;</pre>

<p>To recap, we 1) created a new <code class="objc">ChecklistItem</code> object, 2) added it to our data model, and 3) inserted a new cell for it in the table view.</p>

<p><strong>&raquo;</strong> Try it out. You can now add many new rows to the table. You can also tap these new rows to turn their checkmarks on and off again. When you scroll the table up and down, the checkmarks stay with the proper rows.</p>

<p>Note that the rows are always added to both the table and our data model. When we send the <code class="objc">insertRowsAtIndexPaths</code> message to the table, we say: “Hey table, our data model has a bunch of new items added to it.”  This is important! If you forget to tell the table view about your new items or if you tell the table view there are new items but you don’t actually add them to your data model, then your app will crash. These two things always have to be in sync.</p>

<p><strong>Exercise:</strong> Give the new items checkmarks by default. <strong>◼</strong></p>

<h3>Deleting rows</h3>

<p>While we’re at it, we might as well give users the ability to delete rows. A common way to do this in iOS apps is “swipe-to-delete”. You swipe your finger over a row and a Delete button slides into the screen. You then tap the Delete button to confirm the removal or anywhere else to cancel.</p>

<figure class="image"><figcaption>Swipe-to-delete in action</figcaption><img src="HTML/Figures/Swipe-to-delete.png" alt="Swipe-to-delete in action"/></figure>

<p>Swipe-to-delete is very easy to implement.</p>

<p><strong>&raquo;</strong> Add the following method to the bottom of ChecklistsViewController.m, before <code class="objc"><span class="kw1">@end</span></code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView commitEditingStyle<span class="sy0">:</span><span class="br0">&#40;</span>UITableViewCellEditingStyle<span class="br0">&#41;</span>editingStyle forRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span>items removeObjectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw5">NSArray</span> <span class="sy0">*</span>indexPaths <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObject<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>tableView deleteRowsAtIndexPaths<span class="sy0">:</span>indexPaths withRowAnimation<span class="sy0">:</span>UITableViewRowAnimationAutomatic<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>When the <code class="objc">commitEditingStyle</code> method is present (it comes from the table view data source), the table view will automatically enable swipe-to-delete. All we have to do is remove the item from our data model:</p>

<pre class="objc"><span class="br0">&#91;</span>items removeObjectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;</pre>

<p>And delete the corresponding row from the table view:</p>

<pre class="objc"><span class="kw5">NSArray</span> <span class="sy0">*</span>indexPaths <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObject<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
<span class="br0">&#91;</span>tableView deleteRowsAtIndexPaths<span class="sy0">:</span>indexPaths withRowAnimation<span class="sy0">:</span>UITableViewRowAnimationAutomatic<span class="br0">&#93;</span>;</pre>

<p>This mirrors what we did in <code class="objc">addItem</code>. Again we make an <code class="objc"><span class="kw5">NSArray</span></code> with only one index-path object and then tell the table view to remove the rows with an animation.</p>

<p>If at any point you got stuck, you can refer to the project files for the app from the “03 - Data Model” folder in the tutorial’s Source Code folder.</p>



<aside>
<h3>Destroying objects</h3>

<p>By the way, when we do <code class="objc"><span class="br0">&#91;</span>items removeObjectAtIndex<span class="br0">&#93;</span></code>, that not only takes the <code class="objc">ChecklistItem</code> at that index out of the array but it also permanently destroys that <code class="objc">ChecklistItem</code> object.</p>

<p>We’ll talk more about this in the next tutorial, but if there are no more references to an object, it is automatically destroyed. As long as a <code class="objc">ChecklistItem</code> object sits inside an array, that array has a reference to it. But when we pull the <code class="objc">ChecklistItem</code> out of the array, that reference goes away and the object is <em>deallocated</em>.</p>

<p>What does it mean for an object to be destroyed? Each object occupies a small section of the computer’s memory. When you call <code class="objc">alloc</code> to create an object, a chunk of memory is reserved to hold the object’s values. If the object is deallocated, that memory becomes available again and will eventually be occupied by new objects. After it has been deleted, the object is not valid anymore and you can no longer use it.</p>

<p>On versions of iOS before 5.0 you had to take care of this memory management by hand and if you made a mistake it was possible to keep using an object that already had been deleted. This so-called zombie object is no longer valid but you’re still trying to access the memory that used to be reserved for it. Sometimes it even works &mdash; which is what makes these kinds of bugs so insidious &mdash; but eventually your app will crash. With iOS 5 it’s a lot harder to use such undead objects, but not impossible.</p>

</aside>

<hr>

<h2>The Add Item screen</h2>

<p>You’ve learned how to add new rows to the table, but all of these rows get the same text. We will now change the <code class="objc">addItem</code> action to open a new screen that lets the user enter his own text for those new <code class="objc">ChecklistItem</code>s.</p>

<p>The to-do list for this section:</p>

<ul>
<li>Create the Add Item screen using the power of Storyboarding</li>
<li>Add a text field and allow the user to type into it using the on-screen keyboard</li>
<li>Recognize when the user presses Cancel or Done on the Add Item screen</li>
<li>Create a new <code class="objc">ChecklistItem</code> with the text from the text field</li>
<li>Add the new <code class="objc">ChecklistItem</code> object to the table on the main screen</li>
</ul>

<p>A new screen means a new view controller, so we begin by adding a new scene to the Storyboard.</p>

<p><strong>&raquo;</strong> Go to the Objects Library and drag a new Table View Controller (not a regular view controller) into the Storyboard canvas.</p>

<p>You may need to zoom out to fit everything properly. Either use the loupe icons at the bottom of the screen or double-click the mouse on the canvas.</p>

<figure class="image"><figcaption>Dragging a new Table View Controller into the canvas</figcaption><a href="HTML/Figures/Drag_new_table_view_controller.png" target="_blank"><img src="HTML/Figures/Thumbnail-Drag_new_table_view_controller.png" alt="Dragging a new Table View Controller into the canvas"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Drag_new_table_view_controller.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> With the new view controller in place, zoom back in and select the Add button from the Checklists View Controller. Ctrl-drag to the new view controller.</p>

<figure class="image"><figcaption>Ctrl-drag from the Add button to the new table view controller</figcaption><a href="HTML/Figures/Ctrl-drag_segue.png" target="_blank"><img src="HTML/Figures/Thumbnail-Ctrl-drag_segue.png" alt="Ctrl-drag from the Add button to the new table view controller"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Ctrl-drag_segue.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>Let go of the mouse and a menu named “Storyboard Segues” pops up:</p>

<figure class="image"><figcaption>The Storyboard Segues popup</figcaption><img src="HTML/Figures/Storyboard_Segues_menu.png" alt="The Storyboard Segues popup"/></figure>

<p>The three options in this menu are the different types of connections you can make between the Add button and the new screen. Choose Push from the menu.</p>

<p>This type of connection is named a <em>segue</em> (if you’re not a native English speaker, that is pronounced “seg way” like the strange scooters that you can stand on).</p>

<figure class="image"><figcaption>A new segue is added between the two view controllers</figcaption><a href="HTML/Figures/Push_segue.png" target="_blank"><img src="HTML/Figures/Thumbnail-Push_segue.png" alt="A new segue is added between the two view controllers"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Push_segue.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> Run the app to see what it does.</p>

<p>When you press the Add button, a new empty table slides in from the right. You can press the Checklists button at the top to go back to the previous screen.</p>

<figure class="image"><figcaption>The screen that shows up after you press the Add button</figcaption><img src="HTML/Figures/Table_view_controller_after_push_segue.png" alt="The screen that shows up after you press the Add button"/></figure>

<p>We didn’t even have to write any code and we already have ourselves a working navigation controller!</p>

<p>Note that the Add button no longer adds a new row to the table. That connection has been broken and is replaced by the segue. Just in case, we should remove the button’s connection with the <code class="objc">addItem</code> action.</p>

<p><strong>&raquo;</strong> Select the Add button, go to the Connections Inspector, and press the small X next to addItem.</p>

<figure class="image"><figcaption>Removing the addItem action from the Add button</figcaption><img src="HTML/Figures/Removing_addItem_connection.png" alt="Removing the addItem action from the Add button"/></figure>

<p>Notice that the Inspector also shows the connection with the segue that we’ve just made (under Storyboard Segues).</p>

<p>So now we have a new table view controller that slides into the screen when you press the Add button. This isn’t actually what we want, though. For a screen that lets you add new items, it is better to use a so-called <em>modal</em> segue.</p>

<p><strong>&raquo;</strong> Click the segue in the Storyboard editor. The segue is an object like any other (remember, everything is an object!) and as such it has attributes that you can change. In the Attributes Inspector, choose Style: Modal.</p>

<figure class="image"><figcaption>Changing the segue style to Modal</figcaption><img src="HTML/Figures/Segue_attributes.png" alt="Changing the segue style to Modal"/></figure>

<p>The navigation bar now disappears from the new view controller. This new screen is no longer presented as part of the navigation hierarchy, but as a separate screen that lies on top of the existing one.</p>

<p><strong>&raquo;</strong> Run the app to see the difference.</p>

<p>When you do, you’ll notice that you no longer have a way to go back to the previous screen. Eek! Here’s what we’ll do: modal screens usually have a navigation bar with a Cancel button on the left and a Done button on the right. (In some apps the button on the right is called Save or Send.) Pressing either of these buttons will close the screen, but only Done will save your changes.</p>

<p>The easiest way to add a navigation bar and two buttons is to wrap the view controller for the Add Item screen into a navigation controller of its own. The steps to do this are the same as before:</p>

<p><strong>&raquo;</strong> Select the table view controller (the new one), choose Editor → Embed In → Navigation Controller.</p>

<p>Now the storyboard looks like this:</p>

<figure class="image"><figcaption>The Storyboard with our two table view controllers that are both embedded in their own navigation controller</figcaption><a href="HTML/Figures/Four_view_controllers.png" target="_blank"><img src="HTML/Figures/Thumbnail-Four_view_controllers.png" alt="The Storyboard with our two table view controllers that are both embedded in their own navigation controller"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Four_view_controllers.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>The new navigation controller has been inserted in between the two table view controllers. The Add button now performs a modal segue to the new navigation controller.</p>

<p><strong>&raquo;</strong> Double-click the navigation bar in the right-most view controller to edit its title and change it to “Add Item”. Drag two Bar Button Items into the navigation bar, one in the left slot and one in the right slot.</p>

<figure class="image"><figcaption>The navigation bar items for the new screen</figcaption><img src="HTML/Figures/Add_Item_screen_design.png" alt="The navigation bar items for the new screen"/></figure>

<p><strong>&raquo;</strong> In the Attributes Inspector for the left button choose Identifier: Cancel. For the right button choose Identifier: Done.</p>

<p>You don’t have to type anything into the button’s Title field. The Cancel and Done buttons are built-in button types that automatically use the proper text.</p>

<figure class="image"><figcaption>Cancel and Done are built-in button types</figcaption><img src="HTML/Figures/Cancel_Bar_Button_Item.png" alt="Cancel and Done are built-in button types"/></figure>

<p>You could also choose Identifier: Custom and type the text “Cancel” or “Done” into the button. However, there is an advantage to choosing these predefined Cancel and Done buttons. For one, the Done button has a slightly different background color that you don’t get when you use a custom item. Two, if your app runs on an iPhone where the language is set to something other than English, the standard buttons are automatically translated into the user’s language.</p>

<p><strong>&raquo;</strong> Run the app and you’ll see that our new screen has Cancel and Done buttons.</p>

<h3>Making our own view controller object</h3>

<p>The Cancel and Done buttons should close the Add Item screen and return the app to the main screen. There is currently no way to perform this kind of “backwards” segue from the Storyboard editor, so we’ll have to write the code for that ourselves &mdash; in other words, we have to hook up these buttons to action methods.</p>

<p>Where do we put these action methods? Not in <code class="objc">ChecklistsViewController</code> because that is not the view controller we’re dealing with here. Instead, we have to make a new view controller object specifically for the Add Item screen and connect it to the scene we’ve just designed in the Storyboard editor.</p>

<p><strong>&raquo;</strong> Right-click on the Checklists group in the Project Navigator and choose New File... This time choose the “UIViewController subclass” template.</p>

<figure class="image"><figcaption>Choosing the UIViewController subclass template</figcaption><img src="HTML/Figures/New_file_UIViewController_subclass.png" alt="Choosing the UIViewController subclass template"/></figure>

<p>In Xcode 4.3, the templates are different. There you choose “Objective-C class”:</p>

<figure class="image"><figcaption>Choosing the Objective-C class template in Xcode 4.3</figcaption><img src="HTML/Figures/View_controller_template_Xcode_43.png" alt="Choosing the Objective-C class template in Xcode 4.3"/></figure>

<p><strong>&raquo;</strong> In the next step, choose the following options:</p>

<ul>
<li>Class: <code class="objc">AddItemViewController</code></li>
<li>Subclass of: <code class="objc"><span class="kw7">UITableViewController</span></code> (you can pick that from the list)</li>
<li>Targeted for iPad: Uncheck this</li>
<li>With XIB for user interface: Uncheck this</li>
</ul>

<figure class="image"><figcaption>Choosing the options for the UIViewController subclass</figcaption><img src="HTML/Figures/New_file_UIViewController_subclass_options.png" alt="Choosing the options for the UIViewController subclass"/></figure>

<p>Note: Make sure the “Subclass of” field is set to “UI<strong>Table</strong>ViewController”, not just “UIViewController”!</p>

<p>This adds two files to the project, AddItemViewController.h and AddItemViewController.m. There is no .xib file because we’re using the Storyboard editor to build this screen, so the view controller doesn’t need its own nib.</p>

<p><strong>&raquo;</strong> Change AddItemViewController.h to add the two action methods:</p>

<figure class="code"><figcaption>AddItemViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
&nbsp;
<span class="kw1">@interface</span> AddItemViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>cancel;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p><strong>&raquo;</strong> In the Storyboard editor, select the table view controller and go to the Identity Inspector. Under Custom Class, type “AddItemViewController”.</p>

<p>This tells the Storyboard that the view controller from this scene is actually our <code class="objc">AddItemViewController</code> object.</p>

<figure class="image"><figcaption>Changing the class name of the AddItemViewController</figcaption><img src="HTML/Figures/AddItemViewController_identity_inspector.png" alt="Changing the class name of the AddItemViewController"/></figure>

<p>Don’t forget this step! Without it, the Add Item screen will simply not work. Also make sure that it is really the view controller that is selected before you change the fields in the Identity Inspector (the scene needs to have a fat blue border). A common mistake is to select the table view and change that.</p>

<p>With the Class field set, you can hook up the Cancel bar button to the <code class="objc">cancel</code> action and the Done bar button to the <code class="objc">done</code> action.</p>

<p><strong>&raquo;</strong> Ctrl-drag from the bar buttons to anywhere else in that view controller’s scene (for example, the status bar) and pick the proper action from the popup menu.</p>

<p>The final step is to implement the action methods in AddItemViewController.m. However, the Xcode template put a lot of stuff in this file that we don’t need. The template assumes you’ll fill this in before you run the app again. If you don’t and try to run the app right now, Xcode will give many warnings. So let’s get rid of that placeholder code first.</p>

<p><strong>&raquo;</strong> In AddItemViewController.m, delete everything from the following line until <code class="objc"><span class="kw1">@end</span></code> (but not the <code class="objc"><span class="kw1">@end</span></code> line itself!):</p>

<pre class="objc"><span class="co1">#pragma mark - Table view data source</span></pre>

<p>The lines you just deleted were the <code class="objc">numberOfRowsInSection</code>, <code class="objc">cellForRowAtIndexPath</code> and <code class="objc">didSelectRowAtIndexPath</code> methods that we’ve seen before plus a few other data source and delegate methods for the table view. We won’t need them for this particular view controller.</p>

<p><strong>IMPORTANT!</strong> Do not skip this step. If you do not remove these methods, then the Add Item screen will not work properly.</p>

<p><strong>&raquo;</strong> Add the <code class="objc">cancel</code> and <code class="objc">done</code> actions at the bottom of AddItemViewController.m, as always before <code class="objc"><span class="kw1">@end</span></code>:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>cancel
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.presentingViewController dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.presentingViewController dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This tells the “presenting view controller”, which is the view controller that presented this modal screen, to close the screen with an animation. If you’re wondering which of our four view controllers is the presenting one, it’s the <code class="objc"><span class="kw7">UINavigationController</span></code> that contains the <code class="objc">ChecklistsViewController</code>, i.e. the one on the far left in the Storyboard.</p>

<p>What do you think happens to the <code class="objc">AddItemViewController</code> object when we dismiss it? After the view controller disappears from the screen, its object is destroyed and the memory it was using is reclaimed by the system. Every time the user opens the Add Item screen, we make a new instance for it. This means a view controller object is only alive for the duration that the user is interacting with it; there is no point in keeping it around afterwards.</p>



<aside>
<h3>Container view controllers</h3>

<p>I’ve been saying that one view controller represents one screen, but here we actually have two view controllers for each screen. The app’s main screen consists of the <code class="objc">ChecklistsViewController</code> inside a navigation controller, and the Add Item screen is composed of the <code class="objc">AddItemViewController</code> that sits inside its own navigation controller.</p>

<p>The Navigation Controller is a special type of view controller that acts as a container for other view controllers. It comes with a navigation bar and has the ability to easily go from one screen to another. The container essentially “wraps around” these screens. It’s just the frame that contains the view controllers that do the real work, which are known as the “content” controllers.</p>

<p>Another often-used container is the Tab Bar Controller, which you’ll see in the next tutorial. On the iPad, container view controllers are even more commonplace. View controllers on the iPhone are fullscreen but on the iPad they often occupy only a portion of the screen, such as the content of a popover or one of the panes in a split-view.</p>

</aside>

<h3>Static table cells</h3>

<p>Let’s change the look of the Add Item screen. Currently it is an empty table with a navigation bar on top, but I want it to look like this:</p>

<figure class="image"><figcaption>What the Add Item screen will look like when we’re done</figcaption><img src="HTML/Figures/Add_Item_screen.png" alt="What the Add Item screen will look like when we’re done"/></figure>

<p><strong>&raquo;</strong> Go to the Storyboard editor and select the Table View object inside the <code class="objc">AddItemViewController</code>. In the Attributes Inspector, change the Content setting from Dynamic Prototypes to Static Cells.</p>

<p>(Note that Xcode has been giving us a warning ever since we added this second table view controller: “Prototype table cells must have reuse identifiers.” Switching to static cells gets rid of this warning.)</p>

<figure class="image"><figcaption>Changing to table view to static cells</figcaption><img src="HTML/Figures/Static_cells.png" alt="Changing to table view to static cells"/></figure>

<p>You use static cells when you know beforehand how many sections and rows the table view will have. This is handy for screens that require the user to enter data, such as the one we’re building. We can design the rows directly in the Storyboard editor. For a table with static cells we don’t need to provide a data source, and we can hook up the controls from the cells directly to properties on the view controller.</p>

<p>As you can see in the Scene pane on the left, the table view now has a Table View Section object hanging under it, and three Table View Cells in that section.</p>

<p><strong>&raquo;</strong> Click on the bottom two cells and delete them. We only need one cell for now.</p>

<figure class="image"><figcaption>The table view has a section with three static cells</figcaption><img src="HTML/Figures/AddItemViewController_scene.png" alt="The table view has a section with three static cells"/></figure>

<p><strong>&raquo;</strong> Click the Table View again and in the Attributes Inspector set its Style to Grouped. That gives us the look we want.</p>

<figure class="image"><figcaption>The table view with grouped style</figcaption><img src="HTML/Figures/AddItemViewController_grouped.png" alt="The table view with grouped style"/></figure>

<p>Inside the table view cell we’ll add a text field component that lets us type the text.</p>

<p><strong>&raquo;</strong> Drag a Text Field into the cell and size it up nicely. In the Attributes Inspector for the text field, set the Border Style to none:</p>

<figure class="image"><figcaption>Adding a text field to the table view cell</figcaption><a href="HTML/Figures/AddItemViewController_text_field.png" target="_blank"><img src="HTML/Figures/Thumbnail-AddItemViewController_text_field.png" alt="Adding a text field to the table view cell"/></a><br><span class="enlarge-image"><a href="HTML/Figures/AddItemViewController_text_field.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> Run the app and press the + button to open the Add Item screen. Tap on the cell and you’ll see the keyboard slide in from the bottom of the screen.</p>

<p>Any time you make a text field active, the keyboard automatically appears. You can type into the text field by tapping on the letters. (On the Simulator, you can simply type using your Mac’s keyboard.)</p>

<figure class="image"><figcaption>You can now type text into the table view cell</figcaption><img src="HTML/Figures/AddItemViewController_typing.png" alt="You can now type text into the table view cell"/></figure>

<p>But look what happens when you tap just outside the text field’s area, but still in the cell:</p>

<figure class="image"><figcaption>Whoops, that looks a little weird</figcaption><img src="HTML/Figures/AddItemViewController_text_field_row_selected.png" alt="Whoops, that looks a little weird"/></figure>

<p>The row turns blue because you selected it. That’s not what we want, so we should disable selections for this row.</p>

<p><strong>&raquo;</strong> In the AddItemViewController.m file, add the following method at the bottom:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView willSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">nil</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This is another table view delegate method. When the user taps in a row, the table sends the delegate a <code class="objc">willSelectRowAtIndexPath</code> message that says: “Hi delegate, I am about to select this particular row.” By returning <code class="objc"><span class="kw2">nil</span></code>, our delegate answers: “Sorry, but you're not allowed to!”</p>

<p>There is one more thing we need to do to prevent the row from going blue. It’s already impossible to select the row, as we’ve just told the table view we won’t allow it. However, the cell also has a Selection Color property. This is set to Blue by default. Even if you make it impossible for the row to be selected, sometimes UIKit still briefly draws it blue when you tap it. Therefore it is best to also disable this selection color.</p>

<p><strong>&raquo;</strong> In the Storyboard editor, select the table view cell and go to the Attributes Inspector. Set the Selection attribute to None.</p>

<p>Now if you run the app, it is impossible to select the row and make it turn blue.</p>



<aside>
<h3>Return to sender</h3>

<p>We’ve seen the <code class="objc"><span class="kw1">return</span></code> statement a few times now. You use <code class="objc"><span class="kw1">return</span></code> to send a value from a method back to the method that called it. Let’s take a more detailed look at what it does.</p>

<figure class="image"><figcaption>Methods call other methods and receive values in return</figcaption><img src="HTML/Figures/Methods_and_return_values.png" alt="Methods call other methods and receive values in return"/></figure>

<p>You cannot just return any value. The value you return must be of the datatype that is specified in front of the method name. For example, <code class="objc">shouldAutorotateToInterfaceOrientation</code> must return a <code class="objc"><span class="kw4">BOOL</span></code> value as its name begins with <code class="objc"><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span></code>:</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>shouldAutorotateToInterfaceOrientation<span class="sy0">:</span>
    <span class="br0">&#40;</span><span class="kw7">UIInterfaceOrientation</span><span class="br0">&#41;</span>interfaceOrientation
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span></pre>

<p>The value <code class="objc"><span class="kw2">YES</span></code> is a <code class="objc"><span class="kw4">BOOL</span></code> so that works. If instead you were to write:</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>shouldAutorotateToInterfaceOrientation<span class="sy0">:</span>
    <span class="br0">&#40;</span><span class="kw7">UIInterfaceOrientation</span><span class="br0">&#41;</span>interfaceOrientation
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="co3">@</span><span class="st0">&quot;Yes&quot;</span>;
<span class="br0">&#125;</span></pre>

<p>then the compiler would give an error message as <code class="objc"><span class="co3">@</span><span class="st0">&quot;Yes&quot;</span></code> is a string, not a <code class="objc"><span class="kw4">BOOL</span></code>. To a human reader they look similar and you’d easily understand the intent, but Objective-C isn’t that tolerant. Datatypes have to match or it just isn’t allowed.</p>

<p>The <code class="objc">numberOfRowsInSection</code> method is supposed to return an <code class="objc"><span class="kw5">NSInteger</span></code>, which is another name for <code class="objc"><span class="kw4">int</span></code>, so the statement “return 1” is perfectly valid:</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView
    numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="nu0">1</span>;
<span class="br0">&#125;</span></pre>

<p>Our most recent version of this method looks like this:</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView
    numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span>items count<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre>

<p>That is also a valid return statement because the <code class="objc">count</code> method from <code class="objc"><span class="kw5">NSArray</span></code> returns an <code class="objc"><span class="kw5">NSUInteger</span></code> value. The differences between <code class="objc"><span class="kw5">NSInteger</span></code>, <code class="objc"><span class="kw5">NSUInteger</span></code> and <code class="objc"><span class="kw4">int</span></code> are not very interesting. The important thing is that Objective-C can easily convert between them as they all represent whole numbers (integers).</p>

<p>The <code class="objc">cellForRowAtIndexPath</code> method is supposed to return a <code class="objc"><span class="kw7">UITableViewCell</span></code> object:</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView
    cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView
        dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    . . .
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre>

<p>The difference with the previous examples is that <code class="objc"><span class="kw4">BOOL</span></code>, <code class="objc"><span class="kw4">int</span></code> and <code class="objc"><span class="kw5">NSInteger</span></code> are not objects but <code class="objc"><span class="kw7">UITableViewCell</span></code> is. You can tell the difference by the <code class="objc"><span class="sy0">*</span></code>. A name followed by an asterisk means that we’re dealing with an object. The others are so-called <em>primitive types</em>. The next tutorial explains more about the differences between objects and primitive types. For now, just keep an eye out for the <code class="objc"><span class="sy0">*</span></code>.</p>

<p>The <code class="objc">willSelectRowAtIndexPath</code> method is supposed to return an <code class="objc"><span class="kw5">NSIndexPath</span></code> object. However, we can also make it return “nil”, which means no object.</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView
    willSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">nil</span>;
<span class="br0">&#125;</span></pre>

<p>When a method is expected to return an object, you can return <code class="objc"><span class="kw2">nil</span></code> as well. That doesn’t mean <code class="objc"><span class="kw2">nil</span></code> is always a proper response. For example, if we were to return <code class="objc"><span class="kw2">nil</span></code> from <code class="objc">cellForRowAtIndexPath</code>, the app would crash. Some methods don’t like it when you return <code class="objc"><span class="kw2">nil</span></code> instead of an actual object, but for others it is OK. How do you know which is the case? You can find that in the documentation of the method in question.</p>

<p>In the case of <code class="objc">willSelectRowAtIndexPath</code>, the <a href="http://developer.apple.com/library/ios/DOCUMENTATION/UIKit/Reference/UITableViewDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UITableViewDelegate/tableView:willSelectRowAtIndexPath:">iOS documentation</a> says:</p>

<blockquote>
“Return Value: An index-path object that confirms or alters the selected row. Return an NSIndexPath object other than indexPath if you want another cell to be selected. Return nil if you don't want the row selected.”
</blockquote>

<p>This means we can either:</p>

<ol>
<li>Return the same index-path we were given. This confirms that this row can be selected.</li>
<li>Return another index-path in order to select another row.</li>
<li>Return <code class="objc"><span class="kw2">nil</span></code> to prevent the row from being selected, which is what we did.</li>
</ol>

<p>The <a href="http://developer.apple.com/library/ios/documentation/uikit/reference/UITableViewDataSource_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UITableViewDataSource/tableView:cellForRowAtIndexPath:">documentation</a> for <code class="objc">cellForRowAtIndexPath</code> says:</p>

<blockquote>
“Return Value: An object inheriting from UITableViewCell that the table view can use for the specified row. An assertion is raised if you return nil.”
</blockquote>

<p>In other words, this method must always return a proper table view cell object.</p>

<p>“An assertion is raised if you return nil” means: returning <code class="objc"><span class="kw2">nil</span></code> instead of a valid <code class="objc"><span class="kw7">UITableViewCell</span></code> object will crash the app on purpose because you’re doing something you’re not supposed to. An <em>assertion</em> is a special debugging tool that is used to check that your code always does something valid. If not, the app will crash with a helpful error message. We’ll see more of this later when we talk about finding bugs &mdash; and squashing them.</p>

<p>You’ve also seen methods that do not return anything:</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad</pre>

<p>and</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>cancel</pre>

<p>The term “void” means: this method does not pass a value back to the caller. <code class="objc"><span class="kw4">IBAction</span></code> is a synonym for <code class="objc"><span class="kw1">void</span></code> but as you know it’s also a special symbol that lets Interface Builder and the Storyboard editor know that this method can be hooked up to a button or other control. Because <code class="objc"><span class="kw4">IBAction</span></code> means the same as <code class="objc"><span class="kw1">void</span></code>, action methods never return a value.</p>

<p>If you forget to return a value from a method that expects to return something, then Xcode will give you the following warning: “Control reaches end of non-void function”. The app will still run, but there’s a big chance it will crash at some point, as whoever calls that method is expecting a to receive a value but the method is not returning any. As always, pay attention to the warnings of Xcode!</p>

</aside>

<h3>Reading the text from the text field</h3>

<p>We now have a text field in our table view cell that the user can type into, but how do we read the text that the user has typed? When the user taps Done, we need to get that text and somehow put it into a new <code class="objc">ChecklistItem</code> and add it to our list of items. This means the <code class="objc">done</code> action needs to be able to refer to the text field. You already know how to refer to controls from within your view controller: use a property.</p>

<p>When we added outlets in the previous tutorial, I told you to type in the <code class="objc"><span class="kw1">@property</span></code> declaration and add a <code class="objc"><span class="kw1">@synthesize</span></code> line. I’m going to show you a trick now that will save you some typing. You can let the Storyboard editor do all of this automatically by Ctrl-dragging from the control in question into your .h file.</p>

<p><strong>&raquo;</strong> First, open the Assistant editor, using the toolbar button:</p>

<figure class="image"><figcaption>Click the toolbar button to open the Assistant editor</figcaption><img src="HTML/Figures/Assistant_Editor_button.png" alt="Click the toolbar button to open the Assistant editor"/></figure>

<p>This may make the screen a little crowded &mdash; there are now five horizontal panels open &mdash; so you might want to close the Project Navigator and the Utilities pane using the “View” toolbar buttons.</p>

<p>The Assistant editor opens a new pane on the right of the screen. In the Jump Bar it should say “Automatic”:</p>

<figure class="image"><figcaption>The Assistant Editor</figcaption><a href="HTML/Figures/Assistant_Editor.png" target="_blank"><img src="HTML/Figures/Thumbnail-Assistant_Editor.png" alt="The Assistant Editor"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Assistant_Editor.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>The Assistant editor should have automatically chosen the AddItemViewController.h file for you. “Automatic” means the Assistant editor figures out what other file is related to the one you’re currently editing. If you’re editing the Storyboard, the related file is the selected view controller’s .h file.</p>

<p>(Sometimes Xcode can be a little dodgy here. If it shows you something else than AddItemViewController.h, try de-selecting and re-selecting the view controller, or click around in the Jump Bar a bit. Switching to another file and then back to the Storyboard may also help.)</p>

<p><strong>&raquo;</strong> With the view controller and the .h file side by side, select the text field. Then Ctrl-drag from the text field into the .h file:</p>

<figure class="image"><figcaption>Ctrl-drag from the text field into the .h file</figcaption><a href="HTML/Figures/Ctrl-drag_text_field_to_header_file.png" target="_blank"><img src="HTML/Figures/Thumbnail-Ctrl-drag_text_field_to_header_file.png" alt="Ctrl-drag from the text field into the .h file"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Ctrl-drag_text_field_to_header_file.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>When you let go, a popup appears:</p>

<figure class="image"><figcaption>The popup that lets you add a new outlet</figcaption><img src="HTML/Figures/Add_outlet_popup.png" alt="The popup that lets you add a new outlet"/></figure>

<p><strong>&raquo;</strong> Choose the following options:</p>

<ul>
<li>Connection: Outlet</li>
<li>Name: textField</li>
<li>Type: <code class="objc"><span class="kw7">UITextField</span></code></li>
<li>Storage: Strong</li>
</ul>

<p><strong>&raquo;</strong> Press Connect and voila, Xcode has automatically inserted a <code class="objc"><span class="kw1">@property</span></code> for us.</p>

<p>The AddItemViewController.h file now looks like this:</p>

<figure class="code"><figcaption>AddItemViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
&nbsp;
<span class="kw1">@interface</span> AddItemViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span>
&nbsp;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">strong</span>, <span class="kw1">nonatomic</span><span class="br0">&#41;</span> <span class="kw4">IBOutlet</span> <span class="kw7">UITextField</span> <span class="sy0">*</span>textField;
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>cancel;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>In the AddItemViewController.m file, a synthesize statement was added:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> textField;</pre></figure>

<p>Very handy that Xcode now does this for us. As of Xcode 4.4, it is no longer necessary to type <code class="objc"><span class="kw1">@synthesize</span></code> for your properties, so if you’re using the latest version of Xcode, nothing was actually added to your AddItemViewController.m. Fine with me... the less code we need, the better!</p>

<p>We have now hooked up the text field object with a new property named <code class="objc">textField</code>. Now we’ll modify the <code class="objc">done</code> action to write the contents of this text field to the Debug Area. This is a quick way to verify that we can actually read what the user typed.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">done</code> action to:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    <span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="co3">@</span><span class="st0">&quot;Contents of the text field: %@&quot;</span>, <span class="kw1">self</span>.textField.text<span class="br0">&#41;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span>.presentingViewController dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Run the app, press the + button and type something in the text field. When you press Done, the Add Item screen should close and Xcode should open the Debug pane with a message like this:</p>

<pre>
Checklists[1165:207] Contents of the text field: Hello, world!
</pre>

<p>Great, so that works. <code class="objc"><span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="br0">&#41;</span></code> should be an old friend by now. You’ve seen the <code class="objc"><span class="sy0">%</span>d</code> and <code class="objc"><span class="sy0">%</span>f</code> format specifiers before, which were used for integer values and floating-point values (decimals), respectively. The <code class="objc"><span class="sy0">%</span>@</code> specifier is used to print out the value of an object, in this case the contents of the text field’s <code class="objc">text</code> property.</p>

<h3>Polishing it up</h3>

<p>Before we will write the code to take this text and insert it as a new item into the list, let’s improve the design and workings of the Add Item screen a little. For instance, it would be nice if you didn’t have to tap into the text field in order to bring up the keyboard. It would be more convenient if the keyboard automatically appeared once the screen opens.</p>

<p><strong>&raquo;</strong> To accomplish this, add the following line to the <code class="objc">viewWillAppear</code> method:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewWillAppear<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>animated
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewWillAppear<span class="sy0">:</span>animated<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span>.textField becomeFirstResponder<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Xcode 4.2 already put a basic version of this method in our view controller as it is commonly needed by view controllers. However, the template for Xcode 4.3 does not include it, so simply copy-paste the whole thing into the .m file.</p>

<p>The view controller receives the <code class="objc">viewWillAppear</code> message just before it becomes visible. That is a perfect time to make the text field active. We do this by sending it the <code class="objc">becomeFirstResponder</code> message. If you’ve done programming on other platforms, this is often called “giving the control focus”. In iOS terminology, the control becomes the <em>first responder</em>.</p>

<p>If you now run the app and go to the Add Item screen, you can start typing right away.</p>

<p>Let’s style the input field a bit.</p>

<p><strong>&raquo;</strong> Go to the Storyboard editor and select the text field. Go to its Attributes Inspector and set the following attributes:</p>

<ul>
<li>Placeholder: Name of the Item</li>
<li>Font: System 17</li>
<li>Adjust to Fit: Uncheck this</li>
<li>Capitalization: Sentences</li>
<li>Return Key: Done</li>
</ul>

<figure class="image"><figcaption>The text field attributes</figcaption><img src="HTML/Figures/Text_field_attributes.png" alt="The text field attributes"/></figure>

<p>There are several options here that let you configure the keyboard that appears when the text field becomes active. If this were a field that only allowed numbers, for example, you would set the Keyboard to Number Pad. If it were an email address field, you’d set it to E-mail Address. For our purposes, the Default keyboard is appropriate.</p>

<p>You can also change the text that is displayed on the keyboards’s Return Key. By default it says “return” but we set it to “Done”. This is just the text on the button. We’ll make the keyboard’s Done button trigger the same action as the Done button from the navigation bar.</p>

<p><strong>&raquo;</strong> Make sure the text field is selected and open the Connections Inspector. Drag from the Did End on Exit event to the view controller and pick the <code class="objc">done</code> action.</p>

<p>When you run the app now, pressing Done on the keyboard will also close the screen and print the text to the Debug Area.</p>

<figure class="image"><figcaption>The keyboard now has a big blue Done button</figcaption><img src="HTML/Figures/Keyboard_with_Done_button.png" alt="The keyboard now has a big blue Done button"/></figure>

<p>It’s always good to validate the input from the user to make sure what they’re entering is acceptable. For instance, what should happen if the user immediately taps the Done button on the Add Item screen without entering any text? Adding a to-do item to the list that has no text is not very useful, so in order to prevent this we should disable the Done button when no text has been typed yet.</p>

<p>We have two Done buttons, one on the keyboard and one in the navigation bar. Let’s start with the Done button from the keyboard as this is the simplest one to fix.</p>

<p><strong>&raquo;</strong> On the Attributes Inspector for the text field, check Auto-enable Return Key.</p>

<p>That’s it. Now when you run the app the Done button on the keyboard automatically is disabled when there is no text in the text field. Try it out!</p>

<figure class="image"><figcaption>The Auto-enable Return Key option disables the return key when there is no text</figcaption><img src="HTML/Figures/Auto-enable_Return_Key.png" alt="The Auto-enable Return Key option disables the return key when there is no text"/></figure>

<p>For the Done button in the navigation bar we have to do a little more work. We have to check the contents of the text field after every keystroke to see if it is now empty or not. If it is, then we disable the button. The user can always press Cancel but Done only works when there is text.</p>

<p>In order to listen to changes to the text field &mdash; which may come from taps on the keyboard but also from cut/paste &mdash; we need to make the view controller a delegate for the text field. The text field will send events to this delegate to let it know what is going on. The delegate, which will be our <code class="objc">AddItemViewController</code>, can then respond to these events and take appropriate actions.</p>

<p>We’ve seen delegates before with <code class="objc"><span class="kw7">UITableView</span></code>. The text field object, <code class="objc"><span class="kw7">UITextField</span></code>, also has a delegate. These are two different delegates and we make the view controller play both roles. Later in this tutorial we’ll add even more delegates.</p>

<p><strong>&raquo;</strong> Add <code class="objc"><span class="kw8">UITextFieldDelegate</span></code> to AddItemViewController.h’s <code class="objc"><span class="kw1">@interface</span></code> line:</p>

<figure class="code"><figcaption>AddItemViewController.h</figcaption><pre class="objc"><span class="kw1">@interface</span> AddItemViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;UITextFieldDelegate&gt;
    . . .</pre></figure>

<p>The view controller now says: I can be a delegate for text field objects.</p>

<p>We also have to tell the text field that we have a delegate for it.</p>

<p><strong>&raquo;</strong> Go to the Storyboard editor and select the text field. There are several different ways in which you can hook up the text field’s delegate outlet to the view controller. I prefer to go to its Connections Inspector and drag from “delegate” to the view controller’s icon in the dock:</p>

<figure class="image"><figcaption>Drag from the Connections Inspector to connect the text field delegate</figcaption><img src="HTML/Figures/Connect_text_field_delegate.png" alt="Drag from the Connections Inspector to connect the text field delegate"/></figure>

<p>We also have to add a property for the Done button, so we can send it messages from within the view controller in order to enable or disable it.</p>

<p><strong>&raquo;</strong> Open the Assistant editor and make sure AddItemViewController.h is visible in the newly opened pane. Ctrl-drag from the Done bar button to AddItemViewController.h and let go. Name the new outlet <code class="objc">doneBarButton</code>.</p>

<p>This adds the following property:</p>

<figure class="code"><figcaption>AddItemViewController.h</figcaption><pre class="objc"><span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw4">IBOutlet</span> <span class="kw7">UIBarButtonItem</span> <span class="sy0">*</span>doneBarButton;</pre></figure>

<p>Xcode also automatically added the corresponding <code class="objc"><span class="kw1">@synthesize</span></code> statement for this property in AddItemViewController.m. (Not with Xcode 4.4 or up, where it is no longer required.)</p>

<p><strong>&raquo;</strong> Add the following to AddItemViewController.m, at the bottom:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>textField<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITextField</span> <span class="sy0">*</span><span class="br0">&#41;</span>theTextField shouldChangeCharactersInRange<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSRange</span><span class="br0">&#41;</span>range replacementString<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>string
<span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>newText <span class="sy0">=</span> <span class="br0">&#91;</span>theTextField.text stringByReplacingCharactersInRange<span class="sy0">:</span>range withString<span class="sy0">:</span>string<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="kw2">YES</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="kw2">NO</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This is one of the <code class="objc"><span class="kw7">UITextField</span></code> delegate methods. It is invoked every time the user changes text, whether by tapping on the keyboard or by cut/paste.</p>

<p>First, we figure out what the new text will be:</p>

<pre class="objc"><span class="kw5">NSString</span> <span class="sy0">*</span>newText <span class="sy0">=</span> <span class="br0">&#91;</span>theTextField.text stringByReplacingCharactersInRange<span class="sy0">:</span>range withString<span class="sy0">:</span>string<span class="br0">&#93;</span>;</pre>

<p>The <code class="objc">shouldChangeCharactersInRange</code> delegate method doesn’t give us the new text, only which part of the text should be replaced (the range) and the text it should be replaced with (the replacement string). So we calculate ourselves what the new text will be by taking the text field’s text and doing the replacement. This gives us a new string object that we store in the <code class="objc">newText</code> local variable.</p>

<p>Then we check if the new text is empty by looking at its length, and enable or disable the Done button accordingly:</p>



<pre class="objc"><span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
    <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="kw2">NO</span>;
<span class="br0">&#125;</span></pre>

<p><strong>&raquo;</strong> Run the app and type some text into the text field. Now remove that text and you’ll see that the Done button in the navigation bar properly gets disabled when the text field becomes empty.</p>

<p>One problem: The Done button is initially enabled when the Add Item screen opens, but there is no text in the text field at that point so it really should be disabled. This is simple enough to fix:</p>

<p><strong>&raquo;</strong> In the Storyboard editor, select the Done bar button and go to the Attributes Inspector. Uncheck the Enabled box.</p>

<p>The Done buttons are now properly disabled when there is no text in the text field:</p>

<figure class="image"><figcaption>You cannot press Done if there is no text</figcaption><img src="HTML/Figures/Done_buttons_disabled.png" alt="You cannot press Done if there is no text"/></figure>

<p>There is actually a slightly better way to write the above method:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>textField<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITextField</span> <span class="sy0">*</span><span class="br0">&#41;</span>theTextField shouldChangeCharactersInRange<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSRange</span><span class="br0">&#41;</span>range replacementString<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>string
<span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>newText <span class="sy0">=</span> <span class="br0">&#91;</span>theTextField.text stringByReplacingCharactersInRange<span class="sy0">:</span>range withString<span class="sy0">:</span>string<span class="br0">&#93;</span>;
    <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span><span class="br0">&#41;</span>;
    <span class="kw1">return</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We replaced the if-statement by the line:</p>

<pre class="objc">    <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span><span class="br0">&#41;</span>;</pre>

<p>Earlier we did:</p>

<pre class="objc">    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="co2">// we get here if the length is greater than 0</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="co2">// we get here if the length is 0</span>
    <span class="br0">&#125;</span></pre>

<p>We check the condition <code class="objc"><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span></code>. If that condition is true, i.e. the text length is greater than 0, we set <code class="objc">doneBarButton</code>’s <code class="objc">enabled</code> property to <code class="objc"><span class="kw2">YES</span></code>. If the condition is false, we set the <code class="objc">enabled</code> property to <code class="objc"><span class="kw2">NO</span></code>.</p>

<p>Notice that in these sentences I’m basically saying: if the condition is <code class="objc"><span class="kw2">YES</span></code> then <code class="objc">enabled</code> becomes <code class="objc"><span class="kw2">YES</span></code> but if the condition is <code class="objc"><span class="kw2">NO</span></code> then <code class="objc">enabled</code> becomes <code class="objc"><span class="kw2">NO</span></code>. In other words, we always set the <code class="objc">enabled</code> property to the result of the condition: <code class="objc"><span class="kw2">YES</span></code> or <code class="objc"><span class="kw2">NO</span></code>.</p>

<p>That makes it possible for us to skip the if, and simply do:</p>

<pre class="objc">    <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> the result of the condition;</pre>

<p>which in Objective-C reads as follows:</p>

<pre class="objc">    <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span><span class="br0">&#41;</span>;</pre>

<p>The ( ) parentheses are not really necessary, you can also write it like this:</p>

<pre class="objc">    <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span>;</pre>

<p>However, I find this to be slightly less readable, so I use the parentheses to make it clear beyond a doubt that <code class="objc"><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span></code> is evaluated first and that the assignment takes place after that.</p>

<p>If <code class="objc"><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span></code> is greater than 0, <code class="objc"><span class="kw1">self</span>.doneBarButton.enabled</code> becomes <code class="objc"><span class="kw2">YES</span></code>; otherwise it becomes <code class="objc"><span class="kw2">NO</span></code>.</p>

<p>We can fit this into a single statement because the <em>relational operators</em> all return <code class="objc"><span class="kw2">YES</span></code> if the condition is true and <code class="objc"><span class="kw2">NO</span></code> if the condition is false. These are the relational operators in Objective-C:</p>

<blockquote>
<code class="objc">&gt;</code> (greater than)<br>
<br>
<code class="objc">&lt;</code> (less than)<br>
<br>
<code class="objc">&gt;<span class="sy0">=</span></code> (greater than or equal to)<br>
<br>
<code class="objc">&lt;<span class="sy0">=</span></code> (less than or equal to)<br>
<br>
<code class="objc"><span class="sy0">==</span></code> (equal)<br>
<br>
<code class="objc"><span class="sy0">!=</span></code> (not equal)
</blockquote>

<p>Remember this trick; whenever you see code like this,</p>

<pre class="objc">    <span class="kw1">if</span> <span class="br0">&#40;</span>some condition<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        something <span class="sy0">=</span> <span class="kw2">YES</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        something <span class="sy0">=</span> <span class="kw2">NO</span>;
    <span class="br0">&#125;</span></pre>

<p>then you can write it simply as:</p>

<pre class="objc">    something <span class="sy0">=</span> <span class="br0">&#40;</span>some condition<span class="br0">&#41;</span>;</pre>

<p>We’ve actually done this before in the <code class="objc">shouldAutorotateToInterfaceOrientation</code> method. It currently looks like this:</p>

<pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>shouldAutorotateToInterfaceOrientation<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIInterfaceOrientation</span><span class="br0">&#41;</span>interfaceOrientation
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#40;</span>interfaceOrientation <span class="sy0">==</span> <span class="kw7">UIInterfaceOrientationPortrait</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>

<p>Which is equivalent to:</p>

<pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>shouldAutorotateToInterfaceOrientation<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIInterfaceOrientation</span><span class="br0">&#41;</span>interfaceOrientation
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>interfaceOrientation <span class="sy0">==</span> <span class="kw7">UIInterfaceOrientationPortrait</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="kw2">YES</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="kw2">NO</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>In practice it doesn’t really matter which version you use. I prefer the shorter one; that’s what the pros do. Just remember that relational operators such as <code class="objc"><span class="sy0">==</span></code> and <code class="objc">&gt;</code> always return <code class="objc"><span class="kw2">YES</span></code> or <code class="objc"><span class="kw2">NO</span></code>, so the extra <code class="objc"><span class="kw1">if</span></code> really isn’t necessary.</p>

<h3>Adding new ChecklistItems</h3>

<p>We now have an Add Item screen that lets the user enter text. We properly validate the input so that we’ll never end up with text that is empty. But how do we get this text into a new <code class="objc">ChecklistItem</code> that we can add to the list? To do this we will have to make our own delegate.</p>

<p>You’ve already seen delegates in a few different places: The table view has a delegate that responds to taps on the rows. The text field has a delegate that we use to validate the length of the text. In the Bull’s Eye tutorial we used a delegate to listen to the alert view. And our app also has something named the <code class="objc">ChecklistsAppDelegate</code> (see the Project Navigator). You can’t turn a corner in this place without bumping into a delegate...</p>

<p>The delegate pattern is commonly used to handle the situation we find ourselves in: screen A opens screen B and at some point screen B needs to communicate back to screen A, for example when it closes. The solution is to make A a delegate of B so screen B can send its messages to A whenever it needs to.</p>

<figure class="image"><figcaption>Screen A launches screen B and becomes its delegate</figcaption><img src="HTML/Figures/Delegates_1.png" alt="Screen A launches screen B and becomes its delegate"/></figure>

<p>The cool thing about the delegate pattern is that screen B doesn’t really know anything about screen A. It just knows that <em>some</em> object is its delegate. Other than that, screen B doesn’t care who that is. Just like <code class="objc"><span class="kw7">UITableView</span></code> doesn’t really care about our view controller, only that it delivers table view cells when the table view asks for them. This principle, where screen B is independent of screen A, yet can still talk to it, is called <em>loose coupling</em> and is considered good object-oriented design practice.</p>

<figure class="image"><figcaption>This is what Screen B sees: only the delegate part, not the rest of screen A</figcaption><img src="HTML/Figures/Delegates_2.png" alt="This is what Screen B sees: only the delegate part, not the rest of screen A"/></figure>

<p>We will use the delegate pattern to let the <code class="objc">AddItemViewController</code> send notifications to the <code class="objc">ChecklistsViewController</code>, without it having to know anything about this object.</p>

<p><strong>&raquo;</strong> At the top of AddItemViewController.h, add this in between the <code class="objc"><span class="co1">#import</span></code> and <code class="objc"><span class="kw1">@interface</span></code> lines:</p>

<figure class="code"><figcaption>AddItemViewController.h</figcaption><pre class="objc"><span class="kw1">@class</span> AddItemViewController;
<span class="kw1">@class</span> ChecklistItem;
&nbsp;
<span class="kw1">@protocol</span> AddItemViewControllerDelegate &lt;NSObject&gt;
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewControllerDidCancel<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller;
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewController<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>This defines the <code class="objc">AddItemViewControllerDelegate</code> protocol. You should recognize the lines inside the <code class="objc"><span class="kw1">@protocol</span> ... <span class="kw1">@end</span></code> block as method declarations.</p>

<aside>
<h3>Protocols</h3>

<p>In Objective-C, a <em>protocol</em> doesn’t have anything to do with computer networks or meeting royalty. It is simply a name for a group of methods. A protocol doesn’t have instance variables and it doesn’t implement any of the methods it declares. It just says: any object that conforms to this protocol must implement methods X, Y and Z.</p>

<p>The methods listed in the <code class="objc">AddItemViewControllerDelegate</code> protocol are <code class="objc">addItemViewControllerDidCancel<span class="sy0">:</span></code> and <code class="objc">addItemViewController<span class="sy0">:</span>didFinishAddingItem<span class="sy0">:</span></code>. Delegates often have very long method names!</p>

<p>If we make the <code class="objc">ChecklistsViewController</code> conform to this protocol, then it must implement these two methods. The trick is that from then on we can refer to the <code class="objc">ChecklistsViewController</code> using the protocol name. That is done using the following syntax:</p>

<pre class="objc no-border"><span class="kw4">id</span> &lt;AddItemViewControllerDelegate&gt; delegate;</pre>

<p>The variable <code class="objc">delegate</code> is now a reference to some object that implements the methods of this protocol. You can send messages to the object in the <code class="objc">delegate</code> variable, without knowing what kind of object it really is. Of course, we know it is the <code class="objc">ChecklistsViewController</code> but <code class="objc">AddItemViewController</code> doesn’t need to be aware of that. All it sees is <code class="objc">delegate</code>.</p>

<p>It is customary for the delegate methods to have a reference to their owner as the first (or only) parameter. That’s why we pass along the <code class="objc">AddItemViewController</code> to both methods. This is not required but still a good idea. For example, it may happen that a table view delegate is the delegate for more than one table view. In that case, it needs to be able to distinguish between those two table views. That’s why the table view delegate methods contain a reference to the <code class="objc"><span class="kw7">UITableView</span></code> object that sent the notification.</p>

<p>If you’ve programmed in other languages before, you may recognize protocols as being very similar to “interfaces”. When the designers of the Objective-C language added protocols they couldn’t use the term interface to describe protocols as this keyword was already used to declare objects (the <code class="objc"><span class="kw1">@interface</span></code> line in the .h files). Therefore <code class="objc"><span class="kw1">@protocol</span></code> it is. It’s only a name, the concept is the same.</p>

</aside>

<p>Notice the line that says <code class="objc"><span class="kw1">@class</span> ChecklistItem;</code>. This tells the delegate protocol about the <code class="objc">ChecklistItem</code> object. In the past we’ve used <code class="objc"><span class="co1">#import</span></code> to let one object know about other objects. So what’s the difference between these two?</p>

<ul>
<li>The line <code class="objc"><span class="kw1">@class</span> ChecklistItem;</code> simply says to the compiler: if you see the name <code class="objc">ChecklistItem</code> then that’s an object we’re going to be using. It doesn’t tell the compiler exactly what that object does, just that it’s an object. You’ll use <code class="objc"><span class="kw1">@class</span></code> mostly in .h files because at that point the compiler doesn’t need to know what the object’s properties and methods are, just that it exists. This is also known as a <em>forward declaration</em>.</li>

<li><code class="objc"><span class="co1">#import &quot;ChecklistItem.h&quot;</span></code> literally adds the contents of the ChecklistItem.h file into the current file when it is being compiled. More about this in the next tutorial, but it means that when you use <code class="objc"><span class="co1">#import</span></code>, the compiler knows everything about that object. If you want to access the properties of an object or call any of its methods, you need to use <code class="objc"><span class="co1">#import</span></code>.</li>
</ul>

<p>We need this forward declaration for the <code class="objc">ChecklistItem</code> object because we are using that object in the <code class="objc">AddItemViewControllerDelegate</code> protocol, as a parameter for the method <code class="objc">addItemViewController<span class="sy0">:</span>didFinishAddingItem<span class="sy0">:</span></code>. Likewise for the forward declaration of <code class="objc"><span class="kw1">@class</span> AddItemViewController</code>.</p>

<p>We’re not done yet in AddItemViewController.h. The view controller must have a property that it can use to refer to the delegate.</p>

<p><strong>&raquo;</strong> Add this inside the <code class="objc"><span class="kw1">@interface</span></code> block, below the other properties:</p>

<figure class="code"><figcaption>AddItemViewController.h</figcaption><pre class="objc"><span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">weak</span><span class="br0">&#41;</span> <span class="kw4">id</span> &lt;AddItemViewControllerDelegate&gt; delegate;</pre></figure>

<p><strong>&raquo;</strong> Because we’re adding this property by hand, we also have to add a <code class="objc"><span class="kw1">@synthesize</span></code> line to AddItemViewController.m file, below the other <code class="objc"><span class="kw1">@synthesize</span></code> lines:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> delegate;</pre></figure>

<p><strong>&raquo;</strong> Replace the <code class="objc">cancel</code> and <code class="objc">done</code> actions with the following:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>cancel
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.delegate addItemViewControllerDidCancel<span class="sy0">:</span><span class="kw1">self</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    item.text <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
    item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span>.delegate addItemViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishAddingItem<span class="sy0">:</span>item<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Because <code class="objc">AddItemViewController</code> doesn’t know yet what a <code class="objc">ChecklistItem</code> object is, we have to import its definition.</p>

<p><strong>&raquo;</strong> Add the following line at the top of the file:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="co1">#import &quot;ChecklistItem.h&quot;</span></pre></figure>

<p>When the user taps the Cancel button, we send the <code class="objc">addItemViewControllerDidCancel</code> message to the delegate. We do something similar for the Done button, except that the message is <code class="objc">addItemViewController<span class="sy0">:</span>didFinishAddingItem<span class="sy0">:</span></code> and we pass along a new <code class="objc">ChecklistItem</code> object.</p>

<p>If you were to run the app now, the Cancel and Done buttons would no longer appear to work. (Try it out!) That is because we haven’t told the Add Item screen yet who its delegate is. That means <code class="objc"><span class="kw1">self</span>.delegate</code> is <code class="objc"><span class="kw2">nil</span></code> and the messages aren’t being sent to anyone; there is no one listening for them.</p>

<p>Tip: If you’ve programmed in other languages before, you may be afraid of the dreaded “null pointer dereference”. In Objective-C it is perfectly valid to send a message to <code class="objc"><span class="kw2">nil</span></code>. This will not crash your app. You don’t have to add an <code class="objc"><span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.delegate <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span></code> check before sending a message to the delegate. The only thing you don’t want to send messages to are deallocated objects (so-called zombies), but everyone knows you don’t mess with zombies.</p>

<p>We will make the <code class="objc">ChecklistsViewController</code> suitable to be a delegate for <code class="objc">AddItemViewController</code>.</p>

<p><strong>&raquo;</strong> Change ChecklistsViewController.h to:</p>

<figure class="code"><figcaption>ChecklistsViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
<span class="co1">#import &quot;AddItemViewController.h&quot;</span>
&nbsp;
<span class="kw1">@interface</span> ChecklistsViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;AddItemViewControllerDelegate&gt;
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>addItem;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>The <code class="objc"><span class="co1">#import</span></code> line for AddItemViewController.h is necessary to load the definition of the <code class="objc">AddItemViewControllerDelegate</code>, otherwise we cannot use it.</p>

<p>The change to the <code class="objc"><span class="kw1">@interface</span></code> line tells the compiler that <code class="objc">ChecklistsViewController</code> now conforms to the <code class="objc">AddItemViewControllerDelegate</code> protocol. Anytime you see something in between <code class="objc">&lt; &gt;</code> brackets on an <code class="objc"><span class="kw1">@interface</span></code> line, that means the object implements a particular protocol.</p>

<p><strong>&raquo;</strong> Add the implementations of the protocol’s methods at the bottom of ChecklistsViewController.m:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewControllerDidCancel<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewController<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Currently these methods simply close the Add Item screen. Once we have this working we’ll add the code to make the new <code class="objc">ChecklistItem</code> and add it to the table. Note that this is what the <code class="objc">AddItemViewController</code> used to do itself in its <code class="objc">cancel</code> and <code class="objc">done</code> actions. We’ve simply moved that responsibility to the delegate now.</p>

<p>In review, these are the steps for setting up the delegate pattern between two objects, where object A is the delegate for object B and object B will send out the messages:</p>

<ol>
<li>Define a delegate <code class="objc"><span class="kw1">@protocol</span></code> for object B.</li>
<li>Give object B a property for that delegate protocol.</li>
<li>Make object B send messages to its delegate when something interesting happens, such as the user pressing the Cancel or Done buttons, or when it needs a piece of information.</li>
<li>Make object A conform to the delegate protocol. It should put the name of the protocol in its <code class="objc"><span class="kw1">@interface</span></code> line and implement the methods from the protocol.</li>
<li>Tell object B that object A is now its delegate.</li>
</ol>

<p>This means there is one more thing we need to do: we have to tell <code class="objc">AddItemViewController</code> that the <code class="objc">ChecklistsViewController</code> is now its delegate. The proper place to do that when you’re using Storyboards is in the <code class="objc">prepareForSegue</code> method.</p>

<p><strong>&raquo;</strong> Add this method to ChecklistsViewController.m:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>prepareForSegue<span class="sy0">:</span><span class="br0">&#40;</span>UIStoryboardSegue <span class="sy0">*</span><span class="br0">&#41;</span>segue sender<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>sender
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>segue.identifier isEqualToString<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;AddItem&quot;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw7">UINavigationController</span> <span class="sy0">*</span>navigationController <span class="sy0">=</span> segue.destinationViewController;
        AddItemViewController <span class="sy0">*</span>controller <span class="sy0">=</span> <span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>navigationController.topViewController;
        controller.delegate <span class="sy0">=</span> <span class="kw1">self</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>The <code class="objc">prepareForSegue</code> method is invoked by UIKit when a segue from one screen to another is about to be performed. It allows us to give data to the new view controller before it will be displayed. Usually you’ll do that by setting its properties.</p>

<p>The new view controller can be found in <code class="objc">segue.destinationViewController</code>. In our app, that is not <code class="objc">AddItemViewController</code> but the navigation controller that embeds it. To get the <code class="objc">AddItemViewController</code> object, we can look at the navigation controller’s <code class="objc">topViewController</code> property. This property refers to the screen that is currently active inside the navigation controller.</p>

<p>Once we have a reference to the <code class="objc">AddItemViewController</code> object, we set its <code class="objc">delegate</code> property to <code class="objc"><span class="kw1">self</span></code> and the connection is complete. <code class="objc">ChecklistsViewController</code> is now the delegate of <code class="objc">AddItemViewController</code>. It took some work, but we’re all set now.</p>

<p>You may wonder why we did this:</p>

<pre class="objc">    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>segue.identifier isEqualToString<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;AddItem&quot;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        . . .
    <span class="br0">&#125;</span></pre>

<p>Because there may be more than one segue per view controller, it’s a good idea to give each one a unique identifier and to check for that identifier first to make sure you’re handling the correct segue.</p>

<p><strong>&raquo;</strong> Open the Storyboard editor and select the segue between the Checklists View Controller and the Navigation Controller on its right. In the Attributes Inspector, type “AddItem” into the Identifier field:</p>

<figure class="image"><figcaption>Naming the segue between the Checklists scene and the navigation controller</figcaption><a href="HTML/Figures/Naming_the_segue.png" target="_blank"><img src="HTML/Figures/Thumbnail-Naming_the_segue.png" alt="Naming the segue between the Checklists scene and the navigation controller"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Naming_the_segue.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> Run the app to see if it works.</p>

<p>Pressing the + button will perform the segue to the Add Item screen with the Checklists screen set as its delegate. When you press Cancel or Done, the <code class="objc">AddItemViewController</code> sends a message to its delegate (i.e. <code class="objc">ChecklistsViewController</code>). Currently the delegate simply closes the Add Item screen, but we’ll soon make it do more.</p>



<aside>
<h3>Equal or not equal</h3>

<p>You may be wondering why we did not use the <code class="objc"><span class="sy0">==</span></code> operator to check if the segue identifier was equal to the text “AddItem”, in the following manner:</p>

<pre class="objc no-border">    <span class="kw1">if</span> <span class="br0">&#40;</span>segue.identifier <span class="sy0">==</span> <span class="co3">@</span><span class="st0">&quot;AddItem&quot;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        . . .
    <span class="br0">&#125;</span></pre>

<p>This gets into the topic of <em>object identity</em>, or what does it mean for two objects to be equal.</p>

<p>If you use <code class="objc"><span class="sy0">==</span></code>, you’re checking whether two variables refer to the exact same object. That would be wrong in this case, as the literal text <code class="objc"><span class="co3">@</span><span class="st0">&quot;AddItem&quot;</span></code> and the value from <code class="objc">segue.identifier</code> are most likely two separate string objects.</p>

<p>However, both of these string objects may have the same value &mdash; they both may contain the text <code class="objc"><span class="co3">@</span><span class="st0">&quot;AddItem&quot;</span></code>. To compare the values of these objects but not the objects themselves, you use the <code class="objc">isEqual</code> method, or more specifically for strings, <code class="objc">isEqualToString</code>.</p>

<figure class="image"><figcaption>The difference between using == and isEqualToString to compare two strings</figcaption><img src="HTML/Figures/Object_identity.png" alt="The difference between using == and isEqualToString to compare two strings"/></figure>

<p>Imagine two people who are both called Joe. They’re different people who just happen to have the same name. If we’d compare them with <code class="objc">joe1 <span class="sy0">==</span> joe2</code> then the result would be <code class="objc"><span class="kw2">NO</span></code>, as they’re not the same person. But <code class="objc"><span class="br0">&#91;</span>joe1.name isEqualToString<span class="sy0">:</span>joe2.name<span class="br0">&#93;</span></code> would be <code class="objc"><span class="kw2">YES</span></code>.</p>

<p>On the other hand, if I’m telling you a story about Joe and this story seems awfully familiar to you, then maybe we happen to know this same Joe. In that case, <code class="objc">joe1 <span class="sy0">==</span> joe2</code> would be <code class="objc"><span class="kw2">YES</span></code>.</p>

</aside>

<p>We can now add the new <code class="objc">ChecklistItem</code> to our data model and table view. Finally!</p>

<p><strong>&raquo;</strong> Change the implementation of the <code class="objc">didFinishAddingItem</code> delegate method to the following:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewController<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    <span class="kw4">int</span> newRowIndex <span class="sy0">=</span> <span class="br0">&#91;</span>items count<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw5">NSIndexPath</span> <span class="sy0">*</span>indexPath <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSIndexPath</span> indexPathForRow<span class="sy0">:</span>newRowIndex inSection<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="kw5">NSArray</span> <span class="sy0">*</span>indexPaths <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObject<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.tableView insertRowsAtIndexPaths<span class="sy0">:</span>indexPaths withRowAnimation<span class="sy0">:</span>UITableViewRowAnimationAutomatic<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This is largely the same as what we did in <code class="objc">addItem</code> before. In fact, I simply copied the contents of the <code class="objc">addItem</code> action and pasted them into our delegate method. The only difference is that we no longer create the <code class="objc">ChecklistItem</code> object ourselves; this now happens in the <code class="objc">AddItemViewController</code>. We merely have to insert this new object into our <code class="objc">items</code> array. As before, we tell the table view we have a new row for it and then close the Add Items screen.</p>

<p><strong>&raquo;</strong> Remove the <code class="objc">addItem</code> action from the ChecklistsViewController.h and .m files as we no longer need this method.</p>

<p>Just to make sure, go into the Storyboard editor and make sure the + button is no longer connected to the <code class="objc">addItem</code> action. Bad things happen if buttons are connected to methods that no longer exist...</p>

<p><strong>&raquo;</strong> Run the app and you should be able to add your own items to the list!</p>

<p>You can find the project files for the app up to this point under “04 - Add Item Screen” in the tutorial’s Source Code folder.</p>



<aside>
<h3>Delegates seem like a lot of work!</h3>

<p>Why put in all this effort with delegates when you simply could have given <code class="objc">AddItemViewController</code> a property that points to <code class="objc">ChecklistsViewController</code>? That would work something like this:</p>

<pre class="objc no-border"><span class="co2">// in the .h file</span>
<span class="kw1">@interface</span> AddItemViewController
&nbsp;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">weak</span><span class="br0">&#41;</span> ChecklistsViewController <span class="sy0">*</span>checklistsViewController;
&nbsp;
<span class="kw1">@end</span>
&nbsp;
<span class="co2">// in the .m file</span>
<span class="co1">#import &quot;ChecklistsViewController.h&quot;</span>
&nbsp;
<span class="kw1">@implementation</span> AddItemViewController
&nbsp;
<span class="kw1">@synthesize</span> checklistsViewController;
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    <span class="co2">// directly call a method from ChecklistsViewController</span>
    <span class="br0">&#91;</span>checklistsViewController addItemWithText<span class="sy0">:</span><span class="kw1">self</span>.textField.text<span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">@end</span></pre>

<p>It’s true that this saves some typing, but it also shackles these two objects together. As a general design principle, if screen A launches screen B then you don’t want screen B to know too much about the screen that invoked it (A).</p>

<p>When you give <code class="objc">AddItemViewController</code> a direct pointer to  <code class="objc">ChecklistsViewController</code>, then you can never open the Add Item screen from somewhere else in the app. We won’t actually do this in the Checklists app, but it’s not uncommon for one screen to be accessible from multiple places. Using a delegate helps to abstract the dependency from screen B on screen A.</p>

<p>In addition, the delegate protocol defines a contract between screen B and any screens that wish to use it. Screen A doesn’t have to expose any methods that it might prefer to keep hidden from other objects. By making it a delegate of screen B, screen A doesn’t have to put any methods in its public <code class="objc"><span class="kw1">@interface</span></code> beyond those from the delegate protocol.</p>

<p>Anytime you want one part of your app to notify another part about something, usually in order to update the screen, you want to use delegates. It’s the iOS way.</p>

</aside>

<hr>

<h2>Editing existing checklist items</h2>

<p>Adding new items to the list is a great step forward for our app, but there are usually three things an app needs to do with data: 1) adding new items (which we’ve tackled), 2) deleting items (we allow that with swipe-to-delete), and 3) editing existing items (uhh…). The later is useful for when you want to rename an item from your list. We all make typos.</p>

<p>We could make a completely new Edit Item screen but it would work mostly the same as the Add Item screen. The only difference is that it doesn’t start out empty but with an existing to-do item.</p>

<p>So instead let’s re-use the Add Item screen and make it capable of editing an existing <code class="objc">ChecklistItem</code> object. When the user presses Done we will update the text in that object and tell the delegate about it so that it can update the label of the corresponding table view cell.</p>

<p><strong>Exercise:</strong> Which changes would we need to make to the Add Item screen to enable it to edit existing items? <strong>◼</strong></p>

<p>Answer:</p>

<ol>
<li>The screen must be renamed to Edit Item</li>
<li>We must be able to give it an existing <code class="objc">ChecklistItem</code> object</li>
<li>We have to place the item’s text into the text field</li>
<li>When the user presses Done, we should not add a new item object, but update the existing one</li>
</ol>

<p>There is a bit of a user interface problem, though... How will we actually open the Edit Item screen? In many apps that is done by tapping on the item’s row but in our app that already toggles the checkmark. To solve this problem, we’ll have to revise the UI of our app a little.</p>

<p>When a row is given two functions, the standard approach is to use a <em>detail disclosure button</em> for the secondary task:</p>

<figure class="image"><figcaption>The detail disclosure button</figcaption><img src="HTML/Figures/Detail_Disclosure_button.png" alt="The detail disclosure button"/></figure>

<p>Tapping the row itself will still perform the row’s main function, in our case toggling the checkmark. But we’ll make it so that tapping the disclosure button will open the Edit Item screen.</p>

<p>(An alternative approach is taken by Apple’s Reminders app. There the checkmark is on the left and tapping only this left-most section of the row will toggle the checkmark. Tapping anywhere else in the row will bring up the Edit screen for that item. There are also apps that can toggle the whole screen into “Edit mode” and then let you change the text of an item inline. Which solution you choose depends on what works best for your data.)</p>

<p><strong>&raquo;</strong> Go to the table view cell in the Storyboard editor and in the Attributes Inspector set its Accessory to Detail Disclosure.</p>

<p>Instead of the checkmark you’ll now see a blue chevron (&gt;) button on the right of the cell. This means we’ll have to place the checkmark somewhere else.</p>

<p><strong>&raquo;</strong> Add a new label to the cell to the left of the text label. Give it the following attributes:</p>

<ul>
<li>Text: √ (you can type this with Alt/Option+V)</li>
<li>Font: System Bold, size 22</li>
<li>Autoshrink: No</li>
<li>Highlighted color: White</li>
<li>Tag: 1001</li>
</ul>

<p>We’ve give this new label its own tag, so we can easily find it later.</p>

<figure class="image"><figcaption>Attributes for the checkmark label</figcaption><img src="HTML/Figures/Checkmark_attributes.png" alt="Attributes for the checkmark label"/></figure>

<p>The design of the prototype cell now looks like this:</p>

<figure class="image"><figcaption>The new design of the prototype cell</figcaption><img src="HTML/Figures/Final_prototype_cell_design.png" alt="The new design of the prototype cell"/></figure>

<p><strong>&raquo;</strong> In ChecklistsViewController.m, change configureCheckmarkForCell to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>configureCheckmarkForCell<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>cell withChecklistItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    <span class="kw7">UILabel</span> <span class="sy0">*</span>label <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1001</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>item.checked<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;√&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        label.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;&quot;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>Instead of changing the cell’s <code class="objc">accessoryType</code> property, this now changes the text in the new label.</p>

<p><strong>&raquo;</strong> Run the app and you’ll see that the checkmark has moved to the left. There is now a blue detail disclosure button on the right. Tapping the row still toggles the checkmark, but tapping the blue button doesn’t.</p>

<figure class="image"><figcaption>The checkmarks are now on the other side of the cell</figcaption><img src="HTML/Figures/App_with_new_cell_design.png" alt="The checkmarks are now on the other side of the cell"/></figure>

<p>Next we’re going to make the detail disclosure button open the Add/Edit Item screen. Unfortunately, the Storyboard editor for iOS 5 doesn’t make it possible to create a segue for a disclosure button. If we Ctrl-drag from where the disclosure button is to the Add Item View Controller it attaches a segue to the row itself, not to the disclosure button.</p>

<p>However, we can create a segue that is attached to the table view controller as a whole and then trigger that manually.</p>

<p><strong>&raquo;</strong> Ctrl-drag from the Checklists view controller icon in the dock area to the Navigation Controller next door and make a Modal segue:</p>

<figure class="image"><figcaption>Adding the segue to the view controller</figcaption><img src="HTML/Figures/Add_segue_to_view_controller.png" alt="Adding the segue to the view controller"/></figure>

<p>There are now two segues going from the Checklists screen to the navigation controller. For us to make a distinction between the two, they must have unique identifiers.</p>

<p><strong>&raquo;</strong> Give this new segue the identifier “EditItem” (in the Attributes Inspector).</p>

<p>Note that this new segue isn’t attached to any control. There is nothing on the screen that you can tap or otherwise interact with in order to trigger this segue. We have to perform it programmatically.</p>

<p><strong>&raquo;</strong> Add the following method to ChecklistsViewController.m. Place it with the other table view delegate methods:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView accessoryButtonTappedForRowWithIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span> performSegueWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;EditItem&quot;</span> sender<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The <code class="objc">accessoryButtonTappedForRowWithIndexPath</code> method comes from the table view delegate protocol and the name is obvious enough to guess what it does. Inside this method we simply tell the view controller to perform the segue named “EditItem”.</p>

<p>If you run the app now, tapping the blue chevron button will open the Add/Edit Item screen. The Cancel and Done buttons won’t work because we haven’t set the delegate yet. We only set the delegate in <code class="objc">prepareForSegue</code> for when you tap the + button and perform the “AddItem” segue, not the “EditItem” segue. We’ll change that in a minute.</p>

<aside>

<p>Note: As of Xcode 4.5 and iOS 6 you can now make segues directly from accessory buttons. When you Ctrl-drag from the table view cell, Xcode asks you whether you want to put the segue on the whole cell or just the accessory button. Because this new feature is not compatible with iOS 5, this tutorial will continue to use the workaround.</p>

</aside>

<p>Before we fix the delegate business, we shall make the Add/Edit Item screen capable of editing existing <code class="objc">ChecklistItem</code> objects.</p>

<p><strong>&raquo;</strong> Add a new property for a <code class="objc">ChecklistItem</code> object below the other properties in AddItemViewController.h:</p>

<figure class="code"><figcaption>AddItemViewController.h</figcaption><pre class="objc"><span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> ChecklistItem <span class="sy0">*</span>itemToEdit;</pre></figure>

<p>This property contains the <code class="objc">ChecklistItem</code> object that we will be editing. If we’re adding a new to-do item, the <code class="objc">itemToEdit</code> property will be <code class="objc"><span class="kw2">nil</span></code>. That is how the view controller will make the distinction between adding and editing.</p>

<p><strong>&raquo;</strong> Properties need to be synthesized, so add the following to AddItemViewController.m:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> itemToEdit;</pre></figure>

<p><strong>&raquo;</strong> Change the <code class="objc">viewDidLoad</code> method to the following:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.itemToEdit <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.title <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Edit Item&quot;</span>;
        <span class="kw1">self</span>.textField.text <span class="sy0">=</span> <span class="kw1">self</span>.itemToEdit.text;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>Remember that <code class="objc">viewDidLoad</code> is called when the view controller is created, but before it is shown on the screen. That gives us time to put the user interface in order. In editing mode, when <code class="objc"><span class="kw1">self</span>.itemToEdit</code> is not <code class="objc"><span class="kw2">nil</span></code>, we change the title in the navigation bar to “Edit Item”. You do this by changing the <code class="objc"><span class="kw1">self</span>.title</code> property. The navigation controller looks for this property and automatically changes the title in the navigation bar. We also set the text in the text field to the value from the item’s <code class="objc">text</code> property.</p>

<p>The <code class="objc">AddItemViewController</code> is now capable of recognizing when it needs to edit an item. If the <code class="objc"><span class="kw1">self</span>.itemToEdit</code> property is given a <code class="objc">ChecklistItem</code> object, then the screen magically changes into the Edit Item screen.</p>

<p>But where do we fill up that <code class="objc">itemToEdit</code> property? In <code class="objc">prepareForSegue</code>, of course! That’s the ideal place for putting values into the properties of the new screen before it becomes visible.</p>

<p><strong>&raquo;</strong> Change <code class="objc">prepareForSegue</code> in ChecklistsViewController.m to the following:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>prepareForSegue<span class="sy0">:</span><span class="br0">&#40;</span>UIStoryboardSegue <span class="sy0">*</span><span class="br0">&#41;</span>segue sender<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>sender
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>segue.identifier isEqualToString<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;AddItem&quot;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        . . .
&nbsp;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>segue.identifier isEqualToString<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;EditItem&quot;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw7">UINavigationController</span> <span class="sy0">*</span>navigationController <span class="sy0">=</span> segue.destinationViewController;
        AddItemViewController <span class="sy0">*</span>controller <span class="sy0">=</span> <span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>navigationController.topViewController;
        controller.delegate <span class="sy0">=</span> <span class="kw1">self</span>;
        controller.itemToEdit <span class="sy0">=</span> sender;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>As before, we get the navigation controller from the Storyboard and its embedded <code class="objc">AddItemViewController</code> using the <code class="objc">topViewController</code> property. We set the controller’s <code class="objc">delegate</code> property so we’re notified when the user taps Cancel or Done.</p>

<p>This is the interesting new bit:</p>

<pre class="objc">    controller.itemToEdit <span class="sy0">=</span> sender;</pre>

<p>The <code class="objc">sender</code> parameter apparently contains the <code class="objc">ChecklistItem</code> object to edit, but where does that come from?</p>

<p><strong>&raquo;</strong> Change <code class="objc">accessoryButtonTappedForRowWithIndexPath</code>  to:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView accessoryButtonTappedForRowWithIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span>items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span> performSegueWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;EditItem&quot;</span> sender<span class="sy0">:</span>item<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The accessory-tapped method is given the index-path of the row in question. We use that to look up the corresponding <code class="objc">ChecklistItem</code> object, which we pass to the segue in the <code class="objc">sender</code> parameter of <code class="objc">performSegueWithIdentifier</code>.</p>

<p>Normally <code class="objc">sender</code> will contain a reference to the control that triggered the segue, such as the bar button item or the table view cell that was tapped, but since we’re performing the segue manually we can make <code class="objc">sender</code> anything we want. A <code class="objc">ChecklistItem</code> object will do just fine, thank you.</p>



<aside>
<h3>Sending data between the view controllers</h3>

<p>We’ve talked about screen B (the Add/Edit Item screen) passing data back to screen A (the Checklists screen) through the use of delegates. But note that here we’re actually passing data from screen A to screen B: the <code class="objc">ChecklistItem</code> to edit.</p>

<p>This data transfer works two ways: if screen A opens screen B, then A can give B the data it needs. You simply make a property for this data on screen B and then screen A puts something into this property right before it makes screen B visible.</p>

<p>To pass data back from B to A you would use a delegate.</p>

<figure class="image"><figcaption>Screen A sends data to B by putting it into B’s properties. Screen B sends data back to the delegate.</figcaption><img src="HTML/Figures/Delegates_3.png" alt="Screen A sends data to B by putting it into B’s properties. Screen B sends data back to the delegate."/></figure>

<p>We’re going to do this a few more times in this lesson, just to make sure you don’t forget it. :-)</p>

</aside>

<p>With these steps done, we can now run the app. If you tap the + button, the Add Item screen works as before. However, if you tap the accessory button in an existing row, the screen that opens is now named Edit Item and it already contains the text of that item.</p>

<figure class="image"><figcaption>Editing an item</figcaption><img src="HTML/Figures/Editing_an_item.png" alt="Editing an item"/></figure>

<p>One small problem: the Done button in the navigation bar is initially disabled. This is because we set it disabled in the Storyboard editor.</p>

<p><strong>&raquo;</strong> Change <code class="objc">viewDidLoad</code> to fix this:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.itemToEdit <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.title <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Edit Item&quot;</span>;
        <span class="kw1">self</span>.textField.text <span class="sy0">=</span> <span class="kw1">self</span>.itemToEdit.text;
        <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="kw2">YES</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>We can simply always enable the Done button because when we’re editing an existing item we are guaranteed to pass in a text that is not empty.</p>

<p>Our problems don’t end here, though. Run the app, tap a row to edit it, and press Done. Instead of changing the text on the existing item, a new to-do item with the new text is now added to the list. We didn’t write the code yet to update our data model, so the delegate always thinks it needs to add a new row.</p>

<p>To solve this we will add a new method to our delegate protocol.</p>

<p><strong>&raquo;</strong> Add the following line to the <code class="objc"><span class="kw1">@protocol</span></code> section in AddItemViewController.h:</p>

<figure class="code"><figcaption>AddItemViewController.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewController<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item;</pre></figure>

<p>The full protocol now looks like this:</p>

<figure class="code"><figcaption>AddItemViewController.h</figcaption><pre class="objc"><span class="kw1">@protocol</span> AddItemViewControllerDelegate &lt;NSObject&gt;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewControllerDidCancel<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewController<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewController<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item;
<span class="kw1">@end</span></pre></figure>

<p>We have a method that is invoked when the user presses Cancel and two methods for when the user presses Done. If we’re adding a new item, <code class="objc">didFinishAddingItem</code> is called, but if we were editing an existing item, <code class="objc">didFinishEditingItem</code> is called. By using different methods the delegate (our view controller) can make a distinction between those two situations.</p>

<p><strong>&raquo;</strong> In AddItemViewController.m, change the <code class="objc">done</code> method to:</p>

<figure class="code"><figcaption>AddItemViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.itemToEdit <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        item.text <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
        item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
&nbsp;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate addItemViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishAddingItem<span class="sy0">:</span>item<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.itemToEdit.text <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate addItemViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishEditingItem<span class="sy0">:</span><span class="kw1">self</span>.itemToEdit<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>First we check whether the <code class="objc">itemToEdit</code> property contains an object. If not, then we’re adding a new item and we do the stuff we did before. The new part is this:</p>

<pre class="objc"><span class="kw1">self</span>.itemToEdit.text <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
<span class="br0">&#91;</span><span class="kw1">self</span>.delegate addItemViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishEditingItem<span class="sy0">:</span><span class="kw1">self</span>.itemToEdit<span class="br0">&#93;</span>;</pre>

<p>Nothing too spectacular here. We put the text from the text field into the <code class="objc">ChecklistItem</code> object from <code class="objc">itemToEdit</code> and then call the new delegate method.</p>

<p>(Note that we pass along the object from <code class="objc">itemToEdit</code> with the delegate method. This isn’t strictly necessary as the delegate could simply look at the <code class="objc">itemToEdit</code> property to find that object. I chose to do it this way to be consistent with <code class="objc">didFinishAddingItem</code> because that message also sends along a <code class="objc">ChecklistItem</code> object.)</p>

<p>If you were to run the app now, it will crash. (Go ahead, try it out.) Once you press Done, the following will appear in your Debug Area:</p>

<pre>
*** Terminating app due to uncaught exception 'NSInvalidArgumentException',
reason: '-[ChecklistsViewController addItemViewController:
didFinishEditingItem:]: unrecognized selector sent to instance 0xab04950'
</pre>

<p>The Xcode window has switched to the debugger and points out which line caused the crash:</p>

<figure class="image"><figcaption>The app crashes on the code we just added</figcaption><a href="HTML/Figures/Unrecognized_selector_crash.png" target="_blank"><img src="HTML/Figures/Thumbnail-Unrecognized_selector_crash.png" alt="The app crashes on the code we just added"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Unrecognized_selector_crash.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>It’s also possible that Xcode points at the main.m source file as the cause for the crash, but that’s a little misleading:</p>

<figure class="image"><figcaption>Xcode isn’t being very helpful here</figcaption><img src="HTML/Figures/Xcode_crash_in_main.png" alt="Xcode isn’t being very helpful here"/></figure>

<p>More about debugging later, but I wanted to show you this error as it is very common to get this when you’re using delegates. Xcode actually warned us about this problem in the Issue Navigator:</p>

<figure class="image"><figcaption>Xcode warns about incomplete implementation</figcaption><img src="HTML/Figures/Xcode_warnings_incomplete_implementation.png" alt="Xcode warns about incomplete implementation"/></figure>

<p>Xcode complains that <code class="objc">ChecklistsViewController</code> has an “incomplete implementation” because a method in a protocol wasn’t implemented. That is also the reason for the crash: unrecognized selector sent.</p>

<p>A <em>selector</em> is term Objective-C uses for the name of a method, so this warning means we tried to call a method named <code class="objc">addItemViewController<span class="sy0">:</span>didFinishEditingItem<span class="sy0">:</span></code> that doesn’t actually exist anywhere.</p>

<p>That is not so strange because we only added this method to our delegate protocol but did not actually tell the view controller, the actual delegate, what to do with it.</p>

<p><strong>&raquo;</strong> Add the following to ChecklistsViewController.m and the crash will be history:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>addItemViewController<span class="sy0">:</span><span class="br0">&#40;</span>AddItemViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    <span class="kw4">int</span> index <span class="sy0">=</span> <span class="br0">&#91;</span>items indexOfObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
    <span class="kw5">NSIndexPath</span> <span class="sy0">*</span>indexPath <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSIndexPath</span> indexPathForRow<span class="sy0">:</span>index inSection<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.tableView cellForRowAtIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span> configureTextForCell<span class="sy0">:</span>cell withChecklistItem<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The <code class="objc">AddItemViewController</code> already updated the <code class="objc">ChecklistItem</code> object for us with the new text but we still need to update the table view. We look for the corresponding cell in the table and tell it to update its label using the <code class="objc">configureTextForCell</code> method we wrote earlier.</p>

<p><strong>&raquo;</strong> Run the app again and verify that it now works.</p>

<h3>Refactoring the code</h3>

<p>So now we have an app that shows a list of items. You can toggle the checkmark on and off by tapping the rows. You can add new items and edit existing items using the Add/Edit Item screen and you can delete items by swiping the rows. Pretty sweet.</p>

<p>Given the recent changes, I don’t think the name <code class="objc">AddItemViewController</code> is appropriate anymore as this screen is now used to both add items and edit items. I propose we rename it to <code class="objc">ItemDetailViewController</code>.</p>

<p><strong>&raquo;</strong> Go to AddItemViewController.h and click in the <code class="objc"><span class="kw1">@interface</span></code> line so that the blinking cursor is on the word <code class="objc">AddItemViewController</code>. From the Xcode menubar at the top of the screen choose Edit → Refactor → Rename...</p>

<p>Xcode will now ask you for the new name:</p>

<figure class="image"><figcaption>Changing the name of AddItemViewController</figcaption><img src="HTML/Figures/Refactor_change_name.png" alt="Changing the name of AddItemViewController"/></figure>

<p><strong>&raquo;</strong> Type “ItemDetailViewController” for the new name and check “Rename related files”.</p>

<p>Tip: If Xcode gives the error message “Wait for indexing and try again”, then stop the running app first.</p>

<p><strong>&raquo;</strong> Press Preview. Xcode opens a screen that shows the files that will change. Click on a filename to see the changes that will be made inside of that file.</p>

<p>You’ll see that Xcode will simply rename everything from <code class="objc">AddItemViewController</code> to <code class="objc">ItemDetailViewController</code>. It’s always smart to check what Xcode is going to do.</p>

<figure class="image"><figcaption>Xcode gives a preview of which files it will change</figcaption><a href="HTML/Figures/Refactor_preview.png" target="_blank"><img src="HTML/Figures/Thumbnail-Refactor_preview.png" alt="Xcode gives a preview of which files it will change"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Refactor_preview.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> Click Save to let Xcode do its thing.</p>

<p>Xcode will now ask you if you want to enable automatic snapshots. A snapshot is a copy of your entire project for safekeeping. It is probably a good idea to enable this. If something goes wrong, you can always go back to an earlier snapshot.</p>

<figure class="image"><figcaption>Enable automatic snapshots for simple backups of your project</figcaption><img src="HTML/Figures/Refactor_automatic_snapshots.png" alt="Enable automatic snapshots for simple backups of your project"/></figure>

<p><strong>&raquo;</strong> Click Enable and wait a few seconds for Xcode to complete the operation.</p>

<p>In case you’re curious (or something went wrong!) you can find the snapshots in the Organizer window, under the Projects tab:</p>

<figure class="image"><figcaption>The Organizer window lists the snapshots for your project</figcaption><a href="HTML/Figures/Organizer_snapshots.png" target="_blank"><img src="HTML/Figures/Thumbnail-Organizer_snapshots.png" alt="The Organizer window lists the snapshots for your project"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Organizer_snapshots.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>You can also use the File → Restore Snapshot... option. If at some point you wish to make a manual snapshot, use File → Create Snapshot.</p>

<p>We’re not done yet with our refactorings.</p>

<p><strong>&raquo;</strong> Repeat this process to rename the <code class="objc">AddItemViewControllerDelegate</code> protocol to <code class="objc">ItemDetailViewControllerDelegate</code>. You better get used to those long names!</p>

<p>Unfortunately, Xcode isn’t able to automatically rename the methods from our delegate protocol for us, so we’ll have to do this manually.</p>

<p><strong>&raquo;</strong> Switch to the Search Navigator and type: “addItemViewController” (without the quotes). This searches through our entire project for that text.</p>

<figure class="image"><figcaption>Using the Search navigator to find the methods to change</figcaption><img src="HTML/Figures/Search_navigator.png" alt="Using the Search navigator to find the methods to change"/></figure>

<p><strong>&raquo;</strong> You will have to change:</p>

<ul>
<li><code class="objc">addItemViewControllerDidCancel<span class="sy0">:</span></code> into <code class="objc">itemDetailViewControllerDidCancel<span class="sy0">:</span></code></li>
<li><code class="objc">addItemViewController<span class="sy0">:</span></code> into <code class="objc">itemDetailViewController<span class="sy0">:</span></code></li>
</ul>

<p>After these changes the <code class="objc"><span class="kw1">@protocol</span></code> in ItemDetailViewController.h now has these methods:</p>

<figure class="code"><figcaption>ItemDetailViewController.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>itemDetailViewControllerDidCancel<span class="sy0">:</span><span class="br0">&#40;</span>ItemDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>itemDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ItemDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>itemDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ItemDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item;</pre></figure>

<p><strong>&raquo;</strong> You’ll also need to change these method names in ItemDetailViewController.m and ChecklistsViewController.m.</p>

<p>I always repeat the search afterwards to make sure I didn’t skip anything by accident.</p>

<p>There is one more thing we need to verify. Depending on your version of Xcode, the Refactor tool may not be smart enough to also change the view controller inside the Storyboard. If that happens, the Storyboard still thinks our view controller is named <code class="objc">AddItemViewController</code> and the app will crash with the following message:</p>

<pre>
Checklists[2248:207] Unknown class AddItemViewController in Interface Builder file.
</pre>

<p><strong>&raquo;</strong> Go to the Storyboard Editor and select the Add Item View Controller. In the Identity Inspector, change Class to “ItemDetailViewController”:</p>

<figure class="image"><figcaption>Don’t forget to change the Storyboard as well</figcaption><img src="HTML/Figures/Change_view_controller_class_name.png" alt="Don’t forget to change the Storyboard as well"/></figure>

<p>Because we made quite a few changes all over the place, I always like to do a clean build just to make sure Xcode picks up all these changes and that there are no more warnings or compiler errors. You don’t have to be paranoid about this, but it’s good practice to do a clean build once in a while.</p>

<p><strong>&raquo;</strong> From Xcode’s menubar choose Product → Clean. When the clean is done choose Product → Build (or simply press the Run button). If there are no issues, then run the app again and test the various features just to make sure everything still works!</p>

<p>Tip: If renaming gives you problems, then double-check your spelling. Objective-C is case-sensitive, so it considers “itemDetailViewController” and “ItemDetailViewController” to be two completely different words.</p>

<p>You can find the project files for the app up to this point under “05 - Edit Items” in the tutorial’s Source Code folder.</p>



<aside>
<h3>Iterative development</h3>

<p>If you think this approach to development is a little messy, then you’re absolutely right. We started out with one design but as we were developing it we found out that things didn’t work out so well in practice and that we had to refactor our approach a few times to find a way that works. Well, this is how software development goes in practice.</p>

<p>You build a small part of your app and everything looks and works fine. Then you add the next small part on top of that and suddenly everything breaks down. The proper thing to do is to go back and restructure your entire approach so that everything is hunkey-dorey again... Until the next change you need to make.</p>

<p>Software development is a constant process of refinement. In these tutorials I didn’t want to just give you a perfect piece of code and explain to you how each part works. That’s not how software development happens in the real world. So instead, we’re working our way from zero to a full app, exactly the way a pro developer would, including the mistakes and dead ends.</p>

<p>Isn’t it possible to create a design up-front (sometimes called a “software architecture design”) that deals with all of these situations, like a blueprint but for software? I don’t believe in such designs. Sure, it’s always good to plan ahead. Before writing this chapter, I made a few quick sketches of how I imagined the app would turn out. That was useful to envision the amount of work, but as usual some of my assumptions and guesses turned out to be wrong and the design stopped being useful about halfway in. And this is only a simple app!</p>

<p>That doesn’t mean you shouldn’t spend any time on planning and design, just not too much. ;-) Simply start somewhere and keep going until you get stuck, then backtrack and improve on your approach. This is called <em>iterative development</em> and it’s usually faster than meticulous up-front planning and provides better results.</p>

</aside>

<hr>

<h2>Saving and loading the checklist items</h2>

<p>Any new to-do items that you add to the list cease to exist when you terminate the app (by pressing the Stop button in Xcode, for example). You can also delete the five default items that we put in the list but they keep reappearing after a new launch. That’s not how a real app should behave, of course.</p>

<p>Thanks to the multitasking features of iOS 4 and up, an app stays in memory when you close it. The app goes into a suspended state where it does absolutely nothing but will still hang on to its data. During normal usage, users will never truly terminate the app, just suspend it. However, the app can still be terminated when the iPhone runs out of available working memory as iOS will terminate any suspended apps in order to free up memory when necessary. And if they really want to, users can kill apps by hand or reset their entire device.</p>

<p>Just keeping the list of items in memory is not good enough because there is no guarantee that the app will remain in memory forever, whether active or suspended. Instead, we will need to <em>persist</em> this data in a file on the iPhone’s long-term flash storage. This is no different than saving a file from your word processor on your desktop computer except that iPhone apps should take care of this saving automatically. The user shouldn’t have to press a Save button just to make sure unsaved data is safely placed in long-term storage.</p>

<figure class="image"><figcaption>Apps need to persist data just in case the app is terminated</figcaption><img src="HTML/Figures/Persistence.png" alt="Apps need to persist data just in case the app is terminated"/></figure>

<p>In this section we will:</p>

<ul>
<li>Determine where in the file system we can place the file that will remember the to-do list items.</li>
<li>Save the to-do items to that file whenever the user changes something: adds a new item, toggles a checkmark, et cetera.</li>
<li>Load the to-do items from that file when the app starts up again after it was terminated.</li>
</ul>

<p>Let’s get crackin’!</p>

<h3>The Documents directory</h3>

<p>iOS apps live in a sheltered environment, also known as the <em>sandbox</em>. Each app has its own directory for storing files but cannot access the directories or files of any other apps. This is a security measure, designed to prevent malicious software such as viruses from doing any damage. If an app can only change its own files, then it cannot break any other part of the system.</p>

<p>Your apps can store files in the so-called “Documents” directory. You are guaranteed this directory is always available in the app’s sandbox. The contents of the Documents directory are backed up when the user syncs their device with iTunes. When you release a new version of your app and users install the update, the contents of the Documents folder are left untouched. So any data the app has saved into this folder stays there even if the app is updated.</p>

<p>Let’s look at how this works.</p>

<p><strong>&raquo;</strong> Add the following methods to <code class="objc">ChecklistsViewController</code>, above <code class="objc">viewDidLoad</code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>documentsDirectory
<span class="br0">&#123;</span>
    <span class="kw5">NSArray</span> <span class="sy0">*</span>paths <span class="sy0">=</span> NSSearchPathForDirectoriesInDomains<span class="br0">&#40;</span>NSDocumentDirectory, NSUserDomainMask, <span class="kw2">YES</span><span class="br0">&#41;</span>;
    <span class="kw5">NSString</span> <span class="sy0">*</span>documentsDirectory <span class="sy0">=</span> <span class="br0">&#91;</span>paths objectAtIndex<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="kw1">return</span> documentsDirectory;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>dataFilePath
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw1">self</span> documentsDirectory<span class="br0">&#93;</span> stringByAppendingPathComponent<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checklists.plist&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The <code class="objc">documentsDirectory</code> method is something I added for convenience. There is no standard method we can call to get the full path to the Documents folder, so I rolled my own.</p>

<p>The <code class="objc">dataFilePath</code> method uses <code class="objc">documentsDirectory</code> to construct the full path to the file that we will use to store the checklist items. This file is named “Checklists.plist” and it lives inside the Documents directory.</p>

<p>We use the <code class="objc"><span class="kw5">NSString</span></code> method <code class="objc">stringByAppendingPathComponent</code> to build a proper file system path to Checklists.plist. We can call this method because the return value of <code class="objc"><span class="br0">&#91;</span><span class="kw1">self</span> documentsDirectory<span class="br0">&#93;</span></code> is also an <code class="objc"><span class="kw5">NSString</span></code>. Recall that <code class="objc"><span class="kw5">NSString</span></code> objects are immutable, so this method will create a new string object with the full path to our file.</p>

<p>You could also have constructed the full path like this:</p>

<pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>dataFilePath
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;%@/Checklists.plist&quot;</span>, <span class="br0">&#91;</span><span class="kw1">self</span> documentsDirectory<span class="br0">&#93;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre>

<p>This adds “Checklist.plist” to the Documents directory path, separated by a forward slash. However, I prefer to use <code class="objc">stringByAppendingPathComponent</code> since that frees me from worrying about whether to use a forward slash or a backward slash, what to do if there already is a slash in the folder name, and many other tiny concerns. The built-in objects from iOS come with a lot of useful helper methods like these and it’s often better to use them instead of trying to do things on your own.</p>

<p><strong>&raquo;</strong> Add the following two <code class="objc"><span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="br0">&#41;</span></code> statements to <code class="objc">viewDidLoad</code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="co3">@</span><span class="st0">&quot;Documents folder is %@&quot;</span>, <span class="br0">&#91;</span><span class="kw1">self</span> documentsDirectory<span class="br0">&#93;</span><span class="br0">&#41;</span>;
    <span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="co3">@</span><span class="st0">&quot;Data file path is %@&quot;</span>, <span class="br0">&#91;</span><span class="kw1">self</span> dataFilePath<span class="br0">&#93;</span><span class="br0">&#41;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Run the app. Xcode’s Debug Area will now show you where your app’s Documents directory is actually located.</p>

<p>If I run the app from the Simulator, on my system it says:</p>

<pre>
Documents folder is /Users/matthijs/Library/Application Support/
iPhone Simulator/5.0/Applications/
21BAB5FA-EE73-4728-9B1C-2B9829E9E146/Documents

Data file path is /Users/matthijs/Library/Application Support/
iPhone Simulator/5.0/Applications/
21BAB5FA-EE73-4728-9B1C-2B9829E9E146/Documents/Checklists.plist
</pre>

<p>If you run it on your iPhone, the path will look somewhat different. Here’s what mine says (this is on an iPod touch):</p>

<pre>
Documents folder is
/var/mobile/Applications/FDD50B54-9383-4DCC-9C19-C3DEBC1A96FE/Documents

Data file path is /var/mobile/Applications/FDD50B54-9383-4DCC-9C19-C3DEBC1A96FE
/Documents/Checklists.plist
</pre>

<p>The name of the folder that contains the app is “21BAB5FA-EE73-4728-9B1C-2B9829E9E146” (on the Simulator) and “FDD50B54-9383-4DCC-9C19-C3DEBC1A96FE” (on the device). This is a random ID that Xcode (or iTunes) picks when it installs the app on the Simulator or the device. Anything inside that folder is part of the app’s sandbox.</p>

<p>For the rest of this section, run the app on the Simulator instead of a device. That makes it easier to look at the files we’ll be writing. Because the Simulator stores the app’s files in a regular folder on your Mac, we can easily examine them from Finder.</p>

<p><strong>&raquo;</strong> Open a new Finder window by clicking on the Desktop and typing Cmd+N. Then press Cmd+Shift+G and paste the full path to the Documents folder in the dialog.</p>

<p>The Finder window will go to that folder. Keep this window open so you can see that the Checklists.plist file is actually being created when we get to that part.</p>

<figure class="image"><figcaption>The app’s directory structure in the Simulator</figcaption><a href="HTML/Figures/Documents_directory.png" target="_blank"><img src="HTML/Figures/Thumbnail-Documents_directory.png" alt="The app’s directory structure in the Simulator"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Documents_directory.png" target="_blank">(Click to enlarge)</a></span></figure>

<aside>

<p><strong>Tip:</strong> Are you using OS X Lion (10.7) or Mountain Lion (10.8) and you cannot
find the Library folder in your home directory? To fix this, open Terminal and type the following command:</p>

<p><code class="objc">chflags nohidden ~<span class="sy0">/</span>Library</code></p>

</aside>

<p>You can see several things inside the app’s directory:</p>

<ul>
<li>Checklists, which is our application bundle.</li>
<li>The Documents directory where we’ll put our data files. Currently the Documents folder is still empty.</li>
<li>The Library directory has cache files and preferences files. The contents of this directory are managed by the operating system.</li>
<li>The tmp directory. This is for temporary files. Sometimes apps need to create files for temporary usage. You don’t want these to clutter up your Documents folder, so tmp is a good place to put them. The OS will clear out this folder from time to time.</li>
</ul>

<p>If you’re curious about what is exactly in the application bundle, then right click its filename and choose Show Package Contents. The app bundle is really a folder although Finder pretends it isn’t. With Show Package Contents you can see what is inside that folder.</p>

<figure class="image"><figcaption>The contents of our application bundle</figcaption><img src="HTML/Figures/Application_bundle_contents.png" alt="The contents of our application bundle"/></figure>

<p>Later we’ll discuss in more detail what is going on here.</p>

<p>As of iOS 5 it is also possible to look inside the Documents directory of apps on your device. On your iPhone or iPod, go to Settings → General → Usage and tap the name of an app. You’ll now see the contents of its Documents folder:</p>

<figure class="image"><figcaption>Viewing the Documents folder on the device</figcaption><img src="HTML/Figures/Documents_folder_on_device.png" alt="Viewing the Documents folder on the device"/></figure>

<h3>Saving the checklist items</h3>

<p>Back to our app. We are going to write some code that will save the list of checklist items to the Checklists.plist file when the user adds a new item or edits an existing item. Once we are able to save the items we will add the code that is required to load this list.</p>

<p>So what is a .plist file? You’ve already seen an Info.plist in the Bull’s Eye lesson. All apps have one, including our Checklists app (see the Project Navigator for the file named Checklists-Info.plist). Plist stands for Property List and is an XML file format that stores structured data, usually in a form similar to the Info.plist file (a list of settings and their values). Property List files are very common in iOS, are suitable for many types of data storage and best of all, they are simple to use. I like that!</p>

<p>To save our checklist items we’ll use the <code class="objc"><span class="kw5">NSCoder</span></code> system, which lets objects store their data in a structured file format. We actually don’t really care much about that file format. In this case it happens to be a .plist file but we’re not directly going to mess with that file. All we care about is that the data gets stored in some kind of file in our app’s Documents folder, but we’ll leave the technical details for <code class="objc"><span class="kw5">NSCoder</span></code> to deal with.</p>

<p>We’ve already used <code class="objc"><span class="kw5">NSCoder</span></code> behind the scenes because that’s exactly how nibs and Storyboards work. When you create nib for a view controller or add a view controller to a Storyboard, Xcode uses the <code class="objc"><span class="kw5">NSCoder</span></code> system to write this object to a file (encoding). Then when your application starts up, it uses <code class="objc"><span class="kw5">NSCoder</span></code> again to read the objects from the nib or Storyboard file (decoding). This process of converting objects to files and back again is also known as <em>serialization</em>.</p>

<p>I like to think of this whole process as freezing objects. We take a living object and freeze it so that it is now suspended in time. We store that frozen object into a file where it will spend some time in cryostasis. Later we can read that file into memory and defrost the object to bring it back to life again.</p>

<p><strong>&raquo;</strong> Add the following method to ChecklistsViewController.m, below <code class="objc">dataFilePath</code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>saveChecklistItems
<span class="br0">&#123;</span>
    <span class="kw5">NSMutableData</span> <span class="sy0">*</span>data <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableData</span> alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    <span class="kw5">NSKeyedArchiver</span> <span class="sy0">*</span>archiver <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSKeyedArchiver</span> alloc<span class="br0">&#93;</span> initForWritingWithMutableData<span class="sy0">:</span>data<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>archiver encodeObject<span class="sy0">:</span>items forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItems&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>archiver finishEncoding<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>data writeToFile<span class="sy0">:</span><span class="br0">&#91;</span><span class="kw1">self</span> dataFilePath<span class="br0">&#93;</span> atomically<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This method takes the contents of our <code class="objc">items</code> array and in two steps converts this to a block of binary data and then writes this data to a file:</p>

<ol>
<li><code class="objc"><span class="kw5">NSKeyedArchiver</span></code>, which is a form of <code class="objc"><span class="kw5">NSCoder</span></code> that creates plist files, encodes the array and all the <code class="objc">ChecklistItem</code>s in it into some sort of binary data format that can be written to a file.</li>
<li>That data is placed in an <code class="objc"><span class="kw5">NSMutableData</span></code> object, which will write itself to the file specified by <code class="objc">dataFilePath</code>.</li>
</ol>

<p>It’s not really important that you understand how <code class="objc"><span class="kw5">NSKeyedArchiver</span></code> works internally. The format that it stores the data in isn’t of great significance to us. All we care about is that it allows us to put our objects into a file and read them back later.</p>

<p>We have to call the <code class="objc">saveChecklistItems</code> method whenever the list of items is modified, which is in the <code class="objc">ItemDetailViewControllerDelegate</code> methods.</p>

<p><strong>&raquo;</strong> Make the following changes in these methods:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>itemDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ItemDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    . . .
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> saveChecklistItems<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>itemDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ItemDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    . . .
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> saveChecklistItems<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Let’s not forget the swipe-to-delete function:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView commitEditingStyle<span class="sy0">:</span><span class="br0">&#40;</span>UITableViewCellEditingStyle<span class="br0">&#41;</span>editingStyle forRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span>items removeObjectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> saveChecklistItems<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw5">NSArray</span> <span class="sy0">*</span>indexPaths <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObject<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>tableView deleteRowsAtIndexPaths<span class="sy0">:</span>indexPaths withRowAnimation<span class="sy0">:</span>UITableViewRowAnimationAutomatic<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> And when we turn the checkmark on a row on or off:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    . . .
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> saveChecklistItems<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span>tableView deselectRowAtIndexPath<span class="sy0">:</span>indexPath animated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Just calling <code class="objc"><span class="kw5">NSKeyedArchiver</span></code> on our <code class="objc">items</code> array is not enough. If you were to run the app now and do something that results in a save, such as tapping a row, the app crashes with the following error:</p>

<pre>
*** Terminating app due to uncaught exception 'NSInvalidArgumentException',
reason: '-[ChecklistItem encodeWithCoder:]: unrecognized selector sent to
instance 0x6a26810'
</pre>

<p>The Xcode debugger will point to this line as the culprit:</p>

<pre class="objc"><span class="br0">&#91;</span>archiver encodeObject<span class="sy0">:</span>items forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItems&quot;</span><span class="br0">&#93;</span>;</pre>

<p>You’ve already seen the “unrecognized selector” error message before. This means we forgot to implement a certain method. In this case, the missing method appears to be <code class="objc">encodeWithCoder</code> on the <code class="objc">ChecklistItem</code> object.</p>

<p>We asked <code class="objc"><span class="kw5">NSKeyedArchiver</span></code> to encode our array of items, so it not only has to encode the array itself but also each <code class="objc">ChecklistItem</code> object inside that array. <code class="objc"><span class="kw5">NSKeyedArchiver</span></code> knows how to encode an <code class="objc"><span class="kw5">NSMutableArray</span></code> object but it doesn’t know anything about <code class="objc">ChecklistItem</code>. So we have to help it out a bit.</p>

<p><strong>&raquo;</strong> Change the <code class="objc"><span class="kw1">@interface</span></code> line in ChecklistItem.h:</p>

<figure class="code"><figcaption>ChecklistItem.h</figcaption><pre class="objc"><span class="kw1">@interface</span> ChecklistItem <span class="sy0">:</span> <span class="kw5">NSObject</span> &lt;NSCoding&gt;</pre></figure>

<p>Recall that &lt; &gt; means that an object conforms to a protocol. In this case we’re adding the <code class="objc"><span class="kw6">NSCoding</span></code> protocol to <code class="objc">ChecklistItem</code>.</p>

<p><strong>&raquo;</strong> Add the following to ChecklistItem.m, below the <code class="objc">init</code> method (if your ChecklistItem.m does not have an <code class="objc">init</code> method, then simply add this below the <code class="objc"><span class="kw1">@synthesize</span></code> line):</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>encodeWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aCoder
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span>aCoder encodeObject<span class="sy0">:</span><span class="kw1">self</span>.text forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Text&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>aCoder encodeBool<span class="sy0">:</span><span class="kw1">self</span>.checked forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checked&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This is the missing method from the unrecognized selector error. When <code class="objc"><span class="kw5">NSKeyedArchiver</span></code> tries to encode the <code class="objc">ChecklistItem</code> object it will send it an <code class="objc">encodeWithCoder</code> message.</p>

<p>Here we simply say: we have an object named “Text” that contains the value of our property <code class="objc"><span class="kw1">self</span>.text</code> and a boolean named “Checked” that contains the value of <code class="objc"><span class="kw1">self</span>.checked</code>. Just these two lines are enough to make the coder system work.</p>

<p><strong>&raquo;</strong> Run the app again and tap a row to toggle a checkmark. The app didn’t crash? Good!</p>

<p>Note: At this point Xcode may give a warning that the implementation of <code class="objc">ChecklistItem</code> is incomplete. That’s OK, you will add the missing method shortly.</p>

<p><strong>&raquo;</strong> Go to the Finder window that has the app’s Documents directory open. (If you forgot where that was, it’s in the Library folder in your home directory and then Application Support/iPhone Simulator/5.0/Applications/weird number/Documents.)</p>

<figure class="image"><figcaption>The Documents directory now contains a Checklists.plist file</figcaption><img src="HTML/Figures/Checklists_plist_file.png" alt="The Documents directory now contains a Checklists.plist file"/></figure>

<p>There is now a Checklists.plist file in the Documents folder, which contains the items from our list. You can look inside this file if you want, but the contents won’t make much sense to you. Even though it is XML, this file wasn’t intended to be read by humans, only by the <code class="objc"><span class="kw5">NSKeyedArchiver</span></code> system.</p>

<p>If you’re having trouble viewing the XML it may be because the plist file isn’t stored as text but as a binary format. Some text editors support this file format and can read it as if it were text (TextWrangler is a good one and is a free download on the Mac App Store). You can also use Finder’s Quick Look feature to view the file. Simply select the file in Finder and press the space bar.</p>

<p>Naturally, you can also open the plist file with Xcode.</p>

<p><strong>&raquo;</strong> Right-click the Checklists.plist file and choose Open With → Xcode.</p>

<figure class="image"><figcaption>Checklist.plist in Xcode</figcaption><img src="HTML/Figures/Contents_of_Checklist_plist.png" alt="Checklist.plist in Xcode"/></figure>

<p>It still won’t make much sense but it’s fun to look at anyway. If you expand some of the rows you can see that this file was made by <code class="objc"><span class="kw5">NSKeyedArchiver</span></code> and that the names of our <code class="objc">ChecklistItem</code>s are also in there. But exactly how everything fits together, I have no idea.</p>

<h3>Loading the file</h3>

<p>Saving is all well and good but pretty useless by itself so let’s implement the loading of the Checklists.plist file. It’s very straightforward, we’re basically going to do the same thing we just did but in reverse.</p>

<p>You may have noticed Xcode is complaining that <code class="objc">ChecklistItem</code> does not implement another method from the <code class="objc"><span class="kw6">NSCoding</span></code> protocol, <code class="objc">initWithCoder</code>. That is the method for unfreezing the objects from the file.</p>

<p><strong>&raquo;</strong> Add the following directly above the <code class="objc">encodeWithCoder</code> method:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.text <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Text&quot;</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.checked <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeBoolForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checked&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Inside <code class="objc">initWithCoder</code> we do the opposite from <code class="objc">encodeWithCoder</code>. We take objects from the <code class="objc"><span class="kw5">NSCoder</span></code>’s decoder object and put their values inside our own properties. That’s all it takes! What we stored earlier under the “Text” key now goes back into our <code class="objc"><span class="kw1">self</span>.text</code> property. Likewise for the boolean “Checked” value and <code class="objc"><span class="kw1">self</span>.checked</code>.</p>

<p>Loading the Checklists.plist file will be done by an <code class="objc"><span class="kw5">NSKeyedUnarchiver</span></code> object. That unarchiver does the following behind the scenes to create the <code class="objc">ChecklistItem</code> objects:</p>

<pre class="objc">ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> initWithCoder<span class="sy0">:</span>someDecoderObject<span class="br0">&#93;</span>;</pre>

<p>When we created the <code class="objc">ChecklistItem</code>s by hand, we did this:</p>

<pre class="objc">ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;</pre>

<p>The difference is that <code class="objc"><span class="kw5">NSKeyedUnarchiver</span></code> will not use the regular <code class="objc">init</code> method but the one named <code class="objc">initWithCoder</code>. It is not uncommon for objects to have more than one init method. They are always named “initSomething”, which is a mandatory convention. But which one is used depends on the circumstances.</p>

<p>We use the regular <code class="objc">init</code> method for creating <code class="objc">ChecklistItem</code> objects when the user presses the + button and fills in the Add Item screen, and we use <code class="objc">initWithCoder</code> to restore <code class="objc">ChecklistItem</code>s that were saved to disk.</p>

<aside>
<h3>Init methods</h3>

<p>Method names beginning with the word “init” are special in Objective-C. You only use them when you’re creating new objects. First you <code class="objc">alloc</code> the object to reserve a chunk of memory big enough to hold all of the object’s data (its instance variables), followed by a call to an <code class="objc">init</code> method to initialize the object so that it is ready for use.</p>

<p>The implementations of these init methods, whether they’re called <code class="objc">init</code> or <code class="objc">initWithCoder</code> or something else, always follow the same series of steps. When you write your own init methods, you need to stick to those steps as well.</p>

<p>When we created the ChecklistItem.h and .m source files, Xcode may have already added the following init method for us (depending on your version of Xcode):</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>init
<span class="br0">&#123;</span>
    <span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="co2">// Initialization code here.</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre>

<p>This is the standard way to write an init method. First you call <code class="objc"><span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span></code> to initialize this object’s superclass and then assign the result to <code class="objc"><span class="kw1">self</span></code>. If you’re coming from another programming language and this looks weird to you, well, that’s Objective-C for you.</p>

<p>If you haven’t done any object-oriented programming at all, then you may not know what a <em>superclass</em> is. That’s fine, we’ll completely ignore this topic until the next tutorial. Just remember that sometimes objects need to send messages to something called <code class="objc"><span class="kw1">super</span></code> and if you forget to do this, bad things are likely to happen.</p>

<p>After assigning the result from <code class="objc"><span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span></code> to <code class="objc"><span class="kw1">self</span></code>, you have to look at the value of <code class="objc"><span class="kw1">self</span></code> to determine that it is not <code class="objc"><span class="kw2">nil</span></code>:</p>

<pre class="objc no-border">    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="co2">// Initialization code here.</span>
    <span class="br0">&#125;</span></pre>

<p>The statement <code class="objc"><span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span><span class="br0">&#41;</span></code> is shorthand for: <code class="objc"><span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span></code>.</p>

<p>In the <code class="objc">initWithCoder</code> method from <code class="objc">ChecklistItem</code>, I used a common Objective-C idiom:</p>

<pre class="objc no-border">    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        . . .
    <span class="br0">&#125;</span></pre>

<p>This combines these two lines into one:</p>

<pre class="objc no-border">    <span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        . . .
    <span class="br0">&#125;</span></pre>

<p>If you wanted to be fully explicit, you’d write it as:</p>

<pre class="objc no-border">    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        . . .
    <span class="br0">&#125;</span></pre>

<p>This still calls <code class="objc"><span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span></code>, assigns it to <code class="objc"><span class="kw1">self</span></code> and then checks if <code class="objc"><span class="kw1">self</span></code> is not <code class="objc"><span class="kw2">nil</span></code>, except it does it all inside the if-statement.</p>

<p>Note the double pair of parentheses. If you were to write it like this,</p>

<pre class="objc no-border">    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        . . .
    <span class="br0">&#125;</span></pre>

<p>then Xcode complains. It is not sure whether you meant to make the assignment or whether you intended to compare the value of <code class="objc"><span class="kw1">self</span></code> to the return value of <code class="objc"><span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span></code>, in which case you should have used two equals signs:</p>

<pre class="objc no-border">    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">==</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        . . .
    <span class="br0">&#125;</span></pre>

<p>That doesn’t really make sense, as we definitely want to assign the result of <code class="objc"><span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span></code> to <code class="objc"><span class="kw1">self</span></code>, not compare the two. The extra pair of parentheses is used to make the intention clear to the compiler.</p>

<p>It doesn’t really matter which approach you will use to write this, they are all equivalent:</p>

<pre class="objc no-border">    <span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> . . . <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> . . . <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> . . . <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> . . . <span class="br0">&#125;</span></pre>

<p>As long as you don’t forget to do it!</p>

<p>It can happen that the call to <code class="objc"><span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span></code> returns <code class="objc"><span class="kw2">nil</span></code> in which case the initialization for the object’s superclass failed and this object cannot be used. The object has already been destroyed at that point and there is nothing left to do but bail out. That’s why we use the if-statement.</p>

<p>Fortunately, that doesn’t happen a lot. An instance where this could happen is if your object tries to load an image but the image is not available and without it your object cannot function. Then you’d destroy the object and return <code class="objc"><span class="kw2">nil</span></code>. That is exactly what the <code class="objc"><span class="kw7">UIImage</span></code> object does if you give it the name of an image file that is not present in your application bundle.</p>

<p>If <code class="objc"><span class="kw1">self</span></code> is not <code class="objc"><span class="kw2">nil</span></code>, then the superclass was properly initialized and we can perform our own initialization. In <code class="objc">ChecklistItem</code>’s <code class="objc">init</code> method there really isn’t a need to do any other initialization, which is why we haven’t changed this method. However, in <code class="objc">initWithCoder</code> we initialize the object by reading the values from the <code class="objc"><span class="kw5">NSCoder</span></code> object and stuffing them into <code class="objc">ChecklistItem</code>’s properties.</p>

<p>Finally, you return <code class="objc"><span class="kw1">self</span></code>. That is necessary so the caller can assign the new object to a variable.</p>

<p>In summary, this is what an init method needs to do:</p>

<ol>
<li>Call <code class="objc"><span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span></code> and assign the result to <code class="objc"><span class="kw1">self</span></code>.</li>
<li>Check whether <code class="objc"><span class="kw1">self</span></code> is <code class="objc"><span class="kw2">nil</span></code>. If so, then exit this method right away and return <code class="objc"><span class="kw2">nil</span></code> to the caller.</li>
<li>If <code class="objc"><span class="kw1">self</span></code> was not <code class="objc"><span class="kw2">nil</span></code>, do additional initialization if necessary. Usually this means you give properties and instance variables their initial values. By default, objects are <code class="objc"><span class="kw2">nil</span></code>, <code class="objc"><span class="kw4">int</span></code>s are 0 and <code class="objc"><span class="kw4">BOOL</span></code>s are <code class="objc"><span class="kw2">NO</span></code>. If you want to give these variables different initial values, then this is the place to do so.</li>
<li>Return <code class="objc"><span class="kw1">self</span></code> to the caller.</li>
</ol>

<p>You don’t always need to provide an init method. If your init method doesn’t need to do anything &mdash; if there are no properties or instance variables to fill in &mdash; then you can leave it out completely and the compiler will provide one for you.</p>

</aside>

<p>The implementation of <code class="objc">ChecklistItem</code> is complete, as it can now bring back to life objects that were serialized (or frozen) into the plist file. But we still have to write the code that will actually load this plist. That happens in <code class="objc">ChecklistsViewController</code>.</p>

<p>Until now we’ve done the initialization of our data model in <code class="objc">viewDidLoad</code>. That was convenient for the purposes of the tutorial but not always correct. <code class="objc">viewDidLoad</code> is the place where you should set up your views, i.e. the visible user elements from your app. Data model objects should be initialized earlier because typically the data model tends to live longer than the view.</p>

<p>When the iPhone runs low on available memory (and that happens more often than you’d think!), UIKit will unload the views of any view controller that is not currently visible. This could happen to our app too. The user may be working in the Add/Edit Item screen when the device gives out a “low memory” warning. To reclaim as much memory as possible, UIKit will then unload the <code class="objc">ChecklistsViewController</code>’s table view. That screen is not visible at that point so it doesn’t really need a live view object anyway.</p>

<figure class="image"><figcaption>The lifecycle of a view controller; viewDidLoad may be called more than once</figcaption><img src="HTML/Figures/View_Controller_lifecycle.png" alt="The lifecycle of a view controller; viewDidLoad may be called more than once"/></figure>

<p>Even when the view is (temporarily) unloaded, the data model needs to stick around. The Add/Edit Item screen will still send delegate messages to <code class="objc">ChecklistsViewController</code> and in response the controller needs to update the data model, even if the view is not present. We don’t want to tie the lifecycle of the data model to the existence of the view, so we shouldn’t create it in <code class="objc">viewDidLoad</code>. A better place for creating the data model is in the view controller’s init method.</p>

<aside>

<p>The situation described above is how it works for iOS 5, but Apple changed the rules for iOS 6 so that views are no longer automatically unloaded in low-memory situations. That said, it’s still wise not to create the data model in <code class="objc">viewDidLoad</code>, especially if you still want your apps to run on iOS 5.</p>

</aside>

<p>A table view controller, like many objects, has more than one init method. There is:</p>

<ul>
<li><code class="objc">initWithCoder</code>, for view controllers that are automatically loaded from a nib or Storyboard</li>
<li><code class="objc">initWithNibName</code>, for view controllers that you manually want to load from a nib</li>
<li><code class="objc">initWithStyle</code>, for table view controllers that you manually want to create without using a nib</li>
</ul>

<p>Our view controller comes from a storyboard, so we’ll use <code class="objc">initWithCoder</code> to create the data model and load the plist file. Yup, that’s actually the same method we’ve just implemented in <code class="objc">ChecklistItem</code>. The <code class="objc"><span class="kw7">UITableViewController</span></code> object gets loaded and unfrozen from the Storyboard file using the same <code class="objc"><span class="kw5">NSCoder</span></code> system that we used for our own files. If it’s good enough for Storyboards then it’s certainly good enough for us!</p>

<p><strong>&raquo;</strong> Add the <code class="objc">initWithCoder</code> method above <code class="objc">viewDidLoad</code> in ChecklistsViewController.m:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> initWithCoder<span class="sy0">:</span>aDecoder<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="br0">&#91;</span><span class="kw1">self</span> loadChecklistItems<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Notice the same pattern: This is an init method so we call <code class="objc"><span class="kw1">super</span></code> and assign the result to <code class="objc"><span class="kw1">self</span></code>. If <code class="objc"><span class="kw1">self</span></code> is not <code class="objc"><span class="kw2">nil</span></code> we will do stuff, and finally we return a reference to <code class="objc"><span class="kw1">self</span></code>. The only difference is that we don’t call <code class="objc"><span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span></code> but <code class="objc"><span class="br0">&#91;</span><span class="kw1">super</span> initWithCoder<span class="br0">&#93;</span></code>. That ensures the rest of the view controller is properly unfrozen from the storyboard file.</p>

<p><strong>&raquo;</strong> Add the <code class="objc">loadChecklistItems</code> method above <code class="objc">initWithCoder</code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>loadChecklistItems
<span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>path <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span> dataFilePath<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSFileManager</span> defaultManager<span class="br0">&#93;</span> fileExistsAtPath<span class="sy0">:</span>path<span class="br0">&#93;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="kw5">NSData</span> <span class="sy0">*</span>data <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSData</span> alloc<span class="br0">&#93;</span> initWithContentsOfFile<span class="sy0">:</span>path<span class="br0">&#93;</span>;
        <span class="kw5">NSKeyedUnarchiver</span> <span class="sy0">*</span>unarchiver <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSKeyedUnarchiver</span> alloc<span class="br0">&#93;</span> initForReadingWithData<span class="sy0">:</span>data<span class="br0">&#93;</span>;
        items <span class="sy0">=</span> <span class="br0">&#91;</span>unarchiver decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItems&quot;</span><span class="br0">&#93;</span>;
        <span class="br0">&#91;</span>unarchiver finishDecoding<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">else</span>
    <span class="br0">&#123;</span>
        items <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>Let’s go through this. There are basically two paths that this method can take:</p>

<pre class="objc"><span class="kw5">NSString</span> <span class="sy0">*</span>path <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span> dataFilePath<span class="br0">&#93;</span>;
<span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSFileManager</span> defaultManager<span class="br0">&#93;</span> fileExistsAtPath<span class="sy0">:</span>path<span class="br0">&#93;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    . . .
<span class="br0">&#125;</span>
<span class="kw1">else</span>
<span class="br0">&#123;</span>
    items <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre>

<p>We first put the results of <code class="objc"><span class="br0">&#91;</span><span class="kw1">self</span> dataFilePath<span class="br0">&#93;</span></code> in a temporary variable named <code class="objc">path</code>. We will use the path name more than once in this method so having it available in a local variable instead of calling <code class="objc">dataFilePath</code> several times over is a small optimization.</p>

<p>Then we check whether the file actually exists and decide what happens based on that.</p>

<p>If there is no Checklists.plist then there are obviously no <code class="objc">ChecklistItem</code> objects for us to load. In that case, we go to the <code class="objc"><span class="kw1">else</span></code> section and create an empty <code class="objc"><span class="kw5">NSMutableArray</span></code>. That is what we used to do in <code class="objc">viewDidLoad</code>, so this shouldn’t be too surprising. This is what happens when the app is started up for the very first time.</p>

<p>When we do have a Checklists.plist file, we don’t have to make the array ourselves. We’ll load the entire array and its contents from the Checklists.plist file:</p>

<pre class="objc"><span class="kw5">NSData</span> <span class="sy0">*</span>data <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSData</span> alloc<span class="br0">&#93;</span> initWithContentsOfFile<span class="sy0">:</span>path<span class="br0">&#93;</span>;
<span class="kw5">NSKeyedUnarchiver</span> <span class="sy0">*</span>unarchiver <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSKeyedUnarchiver</span> alloc<span class="br0">&#93;</span> initForReadingWithData<span class="sy0">:</span>data<span class="br0">&#93;</span>;
items <span class="sy0">=</span> <span class="br0">&#91;</span>unarchiver decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItems&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#91;</span>unarchiver finishDecoding<span class="br0">&#93;</span>;</pre>

<p>This is essentially the reverse of what <code class="objc">saveChecklistItems</code> does. First we load the contents of the file into an <code class="objc"><span class="kw5">NSData</span></code> object. Then we create an <code class="objc"><span class="kw5">NSKeyedUnarchiver</span></code> object (note: this is an <em>un</em>archiver) and ask it to decode that data into our <code class="objc">items</code> array. This will create an <code class="objc"><span class="kw5">NSMutableArray</span></code> for us and populate it with exact copies of the <code class="objc">ChecklistItem</code> objects that were frozen into this file.</p>

<p><strong>&raquo;</strong> You can now remove the code that created fake items from <code class="objc">viewDidLoad</code>:</p>

<figure class="code"><figcaption>ChecklistsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>There is currently nothing left to do in <code class="objc">viewDidLoad</code> (other than calling <code class="objc"><span class="kw1">super</span></code>), but we’ll give it something new to do soon enough.</p>

<p><strong>&raquo;</strong> Run the app and make some changes to the to-do items. Press Stop to terminate the app. Start it again and notice that your changes are still there.</p>

<p><strong>&raquo;</strong> Stop the app again. Go to the Finder window with the Documents folder and remove the Checklists.plist file. Run the app once more. You should now have an empty screen. Add an item and notice that the Checklists.plist file re-appears.</p>

<p>Awesome! We’ve written an app that not only lets you add and edit data, but that also persists that data between sessions. These techniques form the basis of many, many apps. Being able to use a navigation controller, show modal edit screens, and pass data around through delegates are essential iOS development skills.</p>

<p>You can find the project files for the app up to this point under “06 - Saving and Loading” in the tutorial’s Source Code folder.</p>

<aside>
<h3>Using FileMerge to compare files</h3>

<p>You can compare your own work with my version of the app using the FileMerge tool. With Xcode 4.2 you can find this tool in the /Developer/Applications folder, but as of Xcode 4.3 you have to open it from the Xcode menu:</p>

<figure class="image"><figcaption></figcaption><a href="HTML/Figures/Xcode_developer_tool_FileMerge.png" target="_blank"><img src="HTML/Figures/Thumbnail-Xcode_developer_tool_FileMerge.png" alt=""/></a><br><span class="enlarge-image"><a href="HTML/Figures/Xcode_developer_tool_FileMerge.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>You give FileMerge two files or two folders to compare:</p>

<figure class="image"><figcaption></figcaption><img src="HTML/Figures/FileMerge_choose_files.png" alt=""/></figure>

<p>After working hard for a few seconds or so, FileMerge tells you what is different:</p>

<figure class="image"><figcaption></figcaption><a href="HTML/Figures/FileMerge_folder_diffs.png" target="_blank"><img src="HTML/Figures/Thumbnail-FileMerge_folder_diffs.png" alt=""/></a><br><span class="enlarge-image"><a href="HTML/Figures/FileMerge_folder_diffs.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>Double-click on a filename from the list and FileMerge shows the differences between the two files:</p>

<figure class="image"><figcaption></figcaption><a href="HTML/Figures/FileMerge_file_diffs.png" target="_blank"><img src="HTML/Figures/Thumbnail-FileMerge_file_diffs.png" alt=""/></a><br><span class="enlarge-image"><a href="HTML/Figures/FileMerge_file_diffs.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>FileMerge is a wonderful tool for spotting the differences between two files or even entire folders. I use it all the time! If something from the tutorials doesn’t work as it should, then do a “diff” between your own files and the ones from the Source Code folder.</p>

</aside>

<p>Just to make sure you get everything we’ve done, in the second part of this tutorial we will expand the app with some new features that more or less repeat what we just did. We’ll also add cool stuff such as local notifications.</p>

<p><a href="Checklists%20-%20Part%202.html">Continue with part 2</a></p>


</article>
</section>
</body>
</html>