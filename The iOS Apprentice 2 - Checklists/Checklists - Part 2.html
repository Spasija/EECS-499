<!DOCTYPE html>
<html lang="en">
<head>
<title>The iOS Apprentice 2: Checklists (Part 2)</title>
<meta charset="utf-8">
<!--[if lt IE 9]>
<script src="HTML/html5.js"></script>
<![endif]-->
<link rel="stylesheet" type="text/css" href="HTML/style.css"/>
<link rel="stylesheet" type="text/css" href="HTML/print.css" media="print"/>
<link rel="stylesheet" type="text/css" href="HTML/objc.css"/>
</head>
<body>
<section>
<article>

<div id="topheader">The iOS Apprentice 2</div>

<h1>Checklists (Part 2)</h1>

<hr>

<h2>Adding multiple checklists</h2>

<p>The app is named Checklist<strong>s</strong> for a reason: it allows you to keep more than one list of to-do items. So far the app has only supported a single list but now we’ll give it the capability to handle multiple checklists.</p>

<p>The steps for this section are:</p>

<ul>
<li>Add a new screen that shows all the checklists</li>
<li>Create a screen that lets you add/edit checklists</li>
<li>Show the to-do items that belong to a particular checklist when you tap the name of that list</li>
<li>Save all the checklists to a file and load them in again</li>
</ul>

<p>Two new screens means we’ll add two new view controllers: <code class="objc">AllListsViewController</code> that shows all your lists and <code class="objc">ListDetailViewController</code> that allows you to add a new list or edit the name and icon of an existing list.</p>

<p>The app’s main screen is currently the <code class="objc">ChecklistsViewController</code>. This file was created by Xcode as part of the Single View Application template and was named after the Class Prefix we chose. In light of the changes we’re about to make, the plural form “Checklists” no longer makes sense as this screen only shows the to-do items that belong to a single checklist.</p>

<p><strong>&raquo;</strong> Use Xcode’s Refactor tool to rename this object to <code class="objc">ChecklistViewController</code> (drop the “s” after “Checklist”). Don’t forget to change the Storyboard as well!</p>

<p>When you’re done, do a clean build and run the app to make sure it all still works.</p>

<h3>The All Lists screen</h3>

<p>We will first add the new <code class="objc">AllListsViewController</code>. This will now become the main screen of our app.</p>

<p>When we’re done this is what it will look like:</p>

<figure class="image"><figcaption>The new main screen of our app</figcaption><img src="HTML/Figures/All_Lists_screen.png" alt="The new main screen of our app"/></figure>

<p>This screen is very similar to what we created before. It’s a table view controller that shows a list of <code class="objc">Checklist</code> objects (not <code class="objc">ChecklistItem</code> objects). From now on, I will refer to this screen as the “All Lists” screen and to the screen that shows the to-do items from a single checklist as the “Checklist” screen.</p>

<p><strong>&raquo;</strong> Right-click the Checklists group in the Project Navigator and choose New File. Under Cocoa Touch choose the “UIViewController subclass” template (or just “Objective-C class” if you have Xcode 4.3). Press Next and name the new file “AllListsViewController”. Choose “Subclass of UITableViewController”. Uncheck “Targeted for iPad” and also “With XIB for user interface”.</p>

<p>The default template for this file needs some work before we can run the app. As a first step, we’ll put some fake data in the table view just to get it up and running. I always like to take as small a step as possible, then run the app to see if it’s working. Once everything works, we can expand on what we have and put in the real data.</p>

<p><strong>&raquo;</strong> In AllListsViewController.m, remove the <code class="objc">numberOfSectionsInTableView</code> method.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">numberOfRowsInSection</code> method to:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="nu0">3</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Change <code class="objc">cellForRowAtIndexPath</code> to:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw1">static</span> <span class="kw5">NSString</span> <span class="sy0">*</span>CellIdentifier <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Cell&quot;</span>;
&nbsp;
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span>CellIdentifier<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>cell <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UITableViewCell</span> alloc<span class="br0">&#93;</span> initWithStyle<span class="sy0">:</span>UITableViewCellStyleDefault reuseIdentifier<span class="sy0">:</span>CellIdentifier<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    cell.textLabel.text <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;List %d&quot;</span>, indexPath.row<span class="br0">&#93;</span>;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p>This is very similar to what the template already put in that method, except that you’re adding this line to put some text in the cells:</p>

<pre class="objc">    cell.textLabel.text <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;List %d&quot;</span>, indexPath.row<span class="br0">&#93;</span>;</pre>

<p>The final step is to add this new view controller to the Storyboard.</p>

<p><strong>&raquo;</strong> Open the Storyboard editor and drag a new Table View Controller onto the canvas.</p>

<p><strong>&raquo;</strong> Ctrl-drag from the very first navigation controller to this new table view controller. From the popup menu choose “Relationship - Root View Controller”.</p>

<p>This will break the connection that existed between the navigation controller and the Checklist View Controller so that “Checklists” is no longer the app’s main screen.</p>

<figure class="image"><figcaption>Ctrl-drag from the navigation controller to the new table view controller</figcaption><img src="HTML/Figures/Ctrl-drag_to_new_table_view_controller.png" alt="Ctrl-drag from the navigation controller to the new table view controller"/></figure>

<p><strong>&raquo;</strong> Select the new table view controller and set its Class in the Identity Inspector to “AllListsViewController”.</p>

<p><strong>&raquo;</strong> Double-click the view controller’s navigation bar and change its title to “Checklists”.</p>

<p>Just for the fun of it, we’re not going to use prototype cells for this table view. It would be perfectly fine if you did, and as an exercise you could rewrite the code to use prototype cells later, but I want to show you another way of making table view cells.</p>

<p><strong>&raquo;</strong> Delete the empty prototype cell from the All Lists View Controller.</p>

<p><strong>&raquo;</strong> Ctrl-drag from the All Lists View Controller icon in the dock (or the scene list) into the Checklist View Controller and create a segue.</p>

<p>This adds a push transition from the All Lists screen to the Checklist screen. This segue isn’t connected to any button or table view cell so we’ll have to invoke it manually.</p>

<figure class="image"><figcaption>The All Lists View Controller is connected to the Checklist View Controller with a push segue</figcaption><a href="HTML/Figures/ShowChecklist_segue.png" target="_blank"><img src="HTML/Figures/Thumbnail-ShowChecklist_segue.png" alt="The All Lists View Controller is connected to the Checklist View Controller with a push segue"/></a><br><span class="enlarge-image"><a href="HTML/Figures/ShowChecklist_segue.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> Click on the segue to select it, go to the Attributes Inspector and give it the identifier “ShowChecklist”. The Style should be Push because we’re pushing the Checklist View Controller onto the navigation stack when we perform this segue.</p>

<p><strong>&raquo;</strong> In AllListsViewController.m, change <code class="objc">didSelectRowAtIndexPath</code> to the following:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span> performSegueWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ShowChecklist&quot;</span> sender<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Recall that this table view delegate method is invoked when you tap a row. Previously, a tap on a row would automatically perform the segue because we hooked up the segue to the prototype cell. However, the table view for this screen isn’t using prototype cells and therefore we have to perform the segue manually. That’s simple enough: just call <code class="objc">performSegueWithIdentifier</code> with the name of the segue and things will start moving.</p>

<p><strong>&raquo;</strong> Run the app. It now looks like this:</p>

<figure class="image"><figcaption>Our first version of the All Lists screen (left). Tapping a row opens the Checklist screen (right).</figcaption><img src="HTML/Figures/All_Lists_screen_and_Checklist_screen.png" alt="Our first version of the All Lists screen (left). Tapping a row opens the Checklist screen (right)."/></figure>

<p>If you tap on a row, the familiar <code class="objc">ChecklistViewController</code> slides into the screen. You can tap the Checklists button in the top-left to go back to the main list. Now we’re truly using the power of the navigation controller!</p>

<p>We’re going to duplicate most of the functionality from the <code class="objc">ChecklistViewController</code> for this new All Lists screen. We’ll add a + button at the top that lets you add a new checklist, we’ll do swipe-to-delete, and we’ll let you edit the name of the checklist from a disclosure button. We’ll also save the array of <code class="objc">Checklist</code> objects to the Checklists.plist file. Because you’ve already seen how this works, we’ll go through the steps a bit quicker this time.</p>

<p>We begin by creating a data model object that represents a checklist.</p>

<p><strong>&raquo;</strong> Add a new file to the project based on the “Objective-C class” template, “Subclass of NSObject”, and name it “Checklist”.</p>

<p>This adds the files Checklist.h and Checklist.m to the project.</p>

<p><strong>&raquo;</strong> Give Checklist.h a <code class="objc">name</code> property:</p>

<figure class="code"><figcaption>Checklist.h</figcaption><pre class="objc"><span class="kw1">@interface</span> Checklist <span class="sy0">:</span> <span class="kw5">NSObject</span>
&nbsp;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">copy</span><span class="br0">&#41;</span> <span class="kw5">NSString</span> <span class="sy0">*</span>name;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p><strong>&raquo;</strong> Synthesize this property in Checklist.m, below the <code class="objc"><span class="kw1">@implementation</span></code> line:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> name;</pre></figure>

<p>That takes care of the <code class="objc">Checklist</code> object. Next, we’ll give <code class="objc">AllListsViewController</code> an array that will store these new <code class="objc">Checklist</code> objects.</p>

<p><strong>&raquo;</strong> Add to AllListsViewController.m, somewhere above the <code class="objc"><span class="kw1">@implementation</span></code> line:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="co1">#import &quot;Checklist.h&quot;</span></pre></figure>

<p><strong>&raquo;</strong> Add a new instance variable block with an array named <code class="objc">lists</code> that will hold the <code class="objc">Checklist</code> objects:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> AllListsViewController <span class="br0">&#123;</span>
    <span class="kw5">NSMutableArray</span> <span class="sy0">*</span>lists;
<span class="br0">&#125;</span></pre></figure>

<p>We have to fill this list up with some test data, which we’ll do from the <code class="objc">initWithCoder</code> method. Remember that this method is automatically invoked by UIKit as it loads the view controller from the Storyboard file.</p>

<p><strong>&raquo;</strong> Add the <code class="objc">initWithCoder</code> method:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> initWithCoder<span class="sy0">:</span>aDecoder<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
        lists <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
&nbsp;
        Checklist <span class="sy0">*</span>list;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        list.name <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Birthdays&quot;</span>;
        <span class="br0">&#91;</span>lists addObject<span class="sy0">:</span>list<span class="br0">&#93;</span>;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        list.name <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Groceries&quot;</span>;
        <span class="br0">&#91;</span>lists addObject<span class="sy0">:</span>list<span class="br0">&#93;</span>;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        list.name <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Cool Apps&quot;</span>;
        <span class="br0">&#91;</span>lists addObject<span class="sy0">:</span>list<span class="br0">&#93;</span>;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        list.name <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;To Do&quot;</span>;
        <span class="br0">&#91;</span>lists addObject<span class="sy0">:</span>list<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Notice that the file already has an <code class="objc">initWithStyle</code> method. You can remove that method as we won’t be using it. Since the view controller is part of a Storyboard, it will always be initialized using <code class="objc">initWithCoder</code>.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">numberOfRowsInSection</code> method to return the number of objects in our new array:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span>lists count<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Finally, change <code class="objc">cellForRowAtIndexPath</code> to create the cells for the rows:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw1">static</span> <span class="kw5">NSString</span> <span class="sy0">*</span>CellIdentifier <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Cell&quot;</span>;
&nbsp;
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span>CellIdentifier<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>cell <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UITableViewCell</span> alloc<span class="br0">&#93;</span> initWithStyle<span class="sy0">:</span>UITableViewCellStyleDefault reuseIdentifier<span class="sy0">:</span>CellIdentifier<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span>lists objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    cell.textLabel.text <span class="sy0">=</span> checklist.name;
    cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryDetailDisclosureButton;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Run the app. It looks like this:</p>

<figure class="image"><figcaption>The table view shows Checklist objects</figcaption><img src="HTML/Figures/Hardcoded_checklists.png" alt="The table view shows Checklist objects"/></figure>

<p>The data model now consists of the <code class="objc">lists</code> array from <code class="objc">AllListsViewController</code> and the <code class="objc">items</code> array from <code class="objc">ChecklistViewController</code>, and the <code class="objc">Checklist</code> and <code class="objc">ChecklistItem</code> objects that they respectively contain.</p>



<aside>
<h3>Ways to make table view cells</h3>

<p>Our <code class="objc">cellForRowAtIndexPath</code> method does a lot more than the one from <code class="objc">ChecklistViewController</code>. There we just did the following to obtain a new table view cell:</p>

<pre class="objc no-border"><span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span>
    <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItem&quot;</span><span class="br0">&#93;</span>;</pre>

<p>But here we have a whole chunk of code to accomplish the same:</p>

<pre class="objc no-border"><span class="kw1">static</span> <span class="kw5">NSString</span> <span class="sy0">*</span>CellIdentifier <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Cell&quot;</span>;
&nbsp;
<span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span>CellIdentifier<span class="br0">&#93;</span>;
<span class="kw1">if</span> <span class="br0">&#40;</span>cell <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    cell <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UITableViewCell</span> alloc<span class="br0">&#93;</span> initWithStyle<span class="sy0">:</span>UITableViewCellStyleDefault
                                  reuseIdentifier<span class="sy0">:</span>CellIdentifier<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre>

<p>The call to <code class="objc">dequeueReusableCellWithIdentifier</code> is still there, except that previously the Storyboard had a prototype cell with that identifier and now it doesn’t. If the table view cannot find a cell to re-use (and it won’t until it has enough cells to fill the entire visible area), this method will return <code class="objc"><span class="kw2">nil</span></code> and we have to create our own cell by hand.</p>

<p>There are four ways that you can make table view cells:</p>

<ol>
<li>Using prototype cells. This is a new feature in iOS 5 and very handy. We did this in <code class="objc">ChecklistViewController</code>.</li>

<li>Using static cells. We did this for the Add/Edit Item screen. Also new with iOS 5 and also very handy, but limited to screens where you know in advance which cells you’ll have. The big advantage with static cells is that you don’t need to provide any of the data source methods (<code class="objc">cellForRowAtIndexPath</code> and so on).</li>

<li>By hand, what we did above. This is how you were supposed to do it before iOS 5 and chances are you’ll run across code examples that do it this way, especially from older articles and books. It’s a bit more work but also offers you most of the flexibility.</li>

<li>Using a nib. The nibs we have seen so far contained an entire view controller but it is also possible to make a nib with just a custom <code class="objc"><span class="kw7">UITableViewCell</span></code> object. This is very similar to using prototype cells, except that you can do it outside of a Storyboard.</li>
</ol>

<p>When you create a cell by hand you specify a certain <em>cell style</em>, which gives you a cell with a preconfigured layout that already has labels and an image view. For the All Lists View Controller we’re using the “Default” style but later in this tutorial we’ll switch to “Subtitle”, which gives us a second, smaller label below the main label.</p>

<p>Using standard cell styles means you don’t have to design your own cell layout. For many apps these standard layouts are sufficient so that saves you some work. Prototype cells and static cells can also use these standard cell styles. The default style for a prototype or static cell is “Custom”, which requires you to use your own labels, but you can change that to one of the built-in styles in the Storyboard editor.</p>

<p>And finally, a warning: Sometimes I see people writing code that creates a new cell for every row rather than trying to reuse cells. Don’t do that! Always ask the table view first whether it has a cell available that can be recycled using <code class="objc">dequeueReusableCellWithIdentifier</code>. Creating a new cell for each row will cause your app to slow down, as object creation is slower than simply re-using an existing object. Creating all these new objects also takes up more memory, which is a precious commodity on mobile devices. For the best performance, reuse those cells!</p>

</aside>

<p>You may have noticed that when you tap the name of a checklist, the Checklist screen slides into view but it currently always shows the same to-do items, regardless of which row you tap on. Each checklist should really have its own list of to-do items. We’ll work on that later in this tutorial as this requires a significant change to our data model.</p>

<p>As a start, let’s set the title of the screen to reflect the chosen checklist.</p>

<p><strong>&raquo;</strong> Change ChecklistViewController.h to the following:</p>

<figure class="code"><figcaption>ChecklistViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
<span class="co1">#import &quot;ItemDetailViewController.h&quot;</span>
&nbsp;
<span class="kw1">@class</span> Checklist;
&nbsp;
<span class="kw1">@interface</span> ChecklistViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;ItemDetailViewControllerDelegate&gt;
&nbsp;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> Checklist <span class="sy0">*</span>checklist;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>We’ve just added a property for a <code class="objc">Checklist</code> object named <code class="objc">checklist</code>. Don’t forget the forward declaration <code class="objc"><span class="kw1">@class</span> Checklist;</code> at the top or Xcode will complain that <code class="objc">ChecklistViewController</code> doesn’t know anything about the <code class="objc">Checklist</code> object.</p>

<p><strong>&raquo;</strong> At the top of ChecklistViewController.m, add an import statement to load the complete definition of the <code class="objc">Checklist</code> object:</p>

<figure class="code"><figcaption>ChecklistViewController.m</figcaption><pre class="objc"><span class="co1">#import &quot;Checklist.h&quot;</span></pre></figure>

<p><strong>&raquo;</strong> Also add a <code class="objc"><span class="kw1">@synthesize</span></code> below the <code class="objc"><span class="kw1">@implementation</span></code> bit:</p>

<figure class="code"><figcaption>ChecklistViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> ChecklistViewController <span class="br0">&#123;</span>
    <span class="kw5">NSMutableArray</span> <span class="sy0">*</span>items;
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">@synthesize</span> checklist;</pre></figure>

<p><strong>&raquo;</strong> Change <code class="objc">viewDidLoad</code> to:</p>

<figure class="code"><figcaption>ChecklistViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
    <span class="kw1">self</span>.title <span class="sy0">=</span> <span class="kw1">self</span>.checklist.name;
<span class="br0">&#125;</span></pre></figure>

<p>This changes the title of the screen (which is shown in the navigation bar) to the name of the <code class="objc">Checklist</code> object.</p>

<p>Now all we have to do is give this <code class="objc">Checklist</code> object to the <code class="objc">ChecklistViewController</code> when the segue is performed.</p>

<p><strong>&raquo;</strong> In <code class="objc">AllListsViewController</code>, update <code class="objc">didSelectRowAtIndexPath</code> to the following:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span>lists objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> performSegueWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ShowChecklist&quot;</span> sender<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>As before, we use <code class="objc">performSegueWithIdentifier</code> to start the segue. This method has a <code class="objc">sender</code> parameter that we previously set to <code class="objc"><span class="kw2">nil</span></code>. Now we’ll use it to send along the <code class="objc">Checklist</code> object from the row that the user tapped on.</p>

<p>You can put anything you want into <code class="objc">sender</code>. If the segue is performed by the Storyboard (rather than manually like we do here) then <code class="objc">sender</code> will refer to the control that triggered it, for example the <code class="objc"><span class="kw7">UIBarButtonItem</span></code> for the Add button or the <code class="objc"><span class="kw7">UITableViewCell</span></code> for a row in the table. But because we start this particular segue by ourselves, we can put into <code class="objc">sender</code> whatever is most convenient for us.</p>

<p>Putting the <code class="objc">Checklist</code> object into the <code class="objc">sender</code> parameter doesn’t give this object to the <code class="objc">ChecklistViewController</code> yet. That happens in <code class="objc">prepareForSegue</code>.</p>

<p><strong>&raquo;</strong> Add the following method below <code class="objc">didSelectRowAtIndexPath</code>:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>prepareForSegue<span class="sy0">:</span><span class="br0">&#40;</span>UIStoryboardSegue <span class="sy0">*</span><span class="br0">&#41;</span>segue sender<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>sender
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>segue.identifier isEqualToString<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ShowChecklist&quot;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        ChecklistViewController <span class="sy0">*</span>controller <span class="sy0">=</span> segue.destinationViewController;
        controller.checklist <span class="sy0">=</span> sender;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>We’ve seen this method already. <code class="objc">prepareForSegue</code> is called by the Storyboard right before the segue happens. Here we get a chance to set the properties of the new view controller before it will become visible.</p>

<p>We need to give it the <code class="objc">Checklist</code> object from the row that the user tapped. That’s why we put that object in the <code class="objc">sender</code> parameter earlier. We could have temporarily stored the <code class="objc">Checklist</code> object in an ivar instead but passing it along in the <code class="objc">sender</code> parameter is much easier.</p>

<p>All of this happens before <code class="objc">ChecklistViewController</code>’s view is loaded, so <code class="objc">viewDidLoad</code> can set the title of the screen accordingly.</p>

<figure class="image"><figcaption>The sequence of events involved in performing a segue</figcaption><img src="HTML/Figures/Segue_sequence_of_events.png" alt="The sequence of events involved in performing a segue"/></figure>

<p><strong>&raquo;</strong> Add an import at the top of AllListsViewController.m, so the compiler can find the <code class="objc">ChecklistViewController</code> object:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="co1">#import &quot;ChecklistViewController.h&quot;</span></pre></figure>

<p>That should do it.</p>

<p><strong>&raquo;</strong> Run the app and notice that when you tap the row for a checklist, the next screen properly takes over the title.</p>

<figure class="image"><figcaption>The name of the chosen checklist now appears in the navigation bar</figcaption><img src="HTML/Figures/Title_in_Checklists_screen.png" alt="The name of the chosen checklist now appears in the navigation bar"/></figure>

<p>Note that giving the <code class="objc">Checklist</code> object to the <code class="objc">ChecklistViewController</code> does not make a copy of it. We only pass the view controller a reference (also known as a <em>pointer</em>) to that object, so any changes we make to it are also seen by <code class="objc">AllListsViewController</code>. Both view controllers have access to the exact same <code class="objc">Checklist</code> object. We’ll use that to our advantage later in order to add new <code class="objc">ChecklistItem</code>s to the <code class="objc">Checklist</code>.</p>

<h3>Adding and editing checklists</h3>

<p>Let’s quickly add the Add Checklist / Edit Checklist screen. This is going to be yet another <code class="objc"><span class="kw7">UITableViewController</span></code>, this time with static cells, and we’ll present it modally from the <code class="objc">AllListsViewController</code>. If the previous sentence made perfect sense to you, then you’re getting the hang of this!</p>

<p><strong>&raquo;</strong> Add a new file to the project, a <code class="objc"><span class="kw7">UITableViewController</span></code> subclass named “ListDetailViewController”.</p>

<p><strong>&raquo;</strong> Change ListDetailViewController.h to:</p>

<figure class="code"><figcaption>ListDetailViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
&nbsp;
<span class="kw1">@class</span> ListDetailViewController;
<span class="kw1">@class</span> Checklist;
&nbsp;
<span class="kw1">@protocol</span> ListDetailViewControllerDelegate &lt;NSObject&gt;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewControllerDidCancel<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingChecklist<span class="sy0">:</span><span class="br0">&#40;</span>Checklist <span class="sy0">*</span><span class="br0">&#41;</span>checklist;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingChecklist<span class="sy0">:</span><span class="br0">&#40;</span>Checklist <span class="sy0">*</span><span class="br0">&#41;</span>checklist;
<span class="kw1">@end</span>
&nbsp;
<span class="kw1">@interface</span> ListDetailViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;UITextFieldDelegate&gt;
&nbsp;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw4">IBOutlet</span> <span class="kw7">UITextField</span> <span class="sy0">*</span>textField;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw4">IBOutlet</span> <span class="kw7">UIBarButtonItem</span> <span class="sy0">*</span>doneBarButton;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">weak</span><span class="br0">&#41;</span> <span class="kw4">id</span> &lt;ListDetailViewControllerDelegate&gt; delegate;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> Checklist <span class="sy0">*</span>checklistToEdit;
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>cancel;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>This may seem like a lot of code all at once, but I simply took the contents of ItemDetailViewController.h and changed the names. Also, instead of a <code class="objc">ChecklistItem</code> we’re now dealing with a <code class="objc">Checklist</code>.</p>

<p><strong>&raquo;</strong> To the top of ListDetailViewController.m add:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="co1">#import &quot;Checklist.h&quot;</span></pre></figure>

<p><strong>&raquo;</strong> Below the <code class="objc"><span class="kw1">@implementation</span></code> line add:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> textField;
<span class="kw1">@synthesize</span> doneBarButton;
<span class="kw1">@synthesize</span> delegate;
<span class="kw1">@synthesize</span> checklistToEdit;</pre></figure>

<p><strong>&raquo;</strong> Change <code class="objc">viewDidLoad</code> to:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.checklistToEdit <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.title <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Edit Checklist&quot;</span>;
        <span class="kw1">self</span>.textField.text <span class="sy0">=</span> <span class="kw1">self</span>.checklistToEdit.name;
        <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="kw2">YES</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> And change (or add if it doesn’t exist yet) the <code class="objc">viewWillAppear</code> method:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewWillAppear<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>animated
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewWillAppear<span class="sy0">:</span>animated<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span>.textField becomeFirstResponder<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Throw away everything below the <code class="objc"><span class="co1">#pragma mark - Table view data source</span></code> line and replace it with:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>cancel
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.delegate listDetailViewControllerDidCancel<span class="sy0">:</span><span class="kw1">self</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.checklistToEdit <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        checklist.name <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
&nbsp;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate listDetailViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishAddingChecklist<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.checklistToEdit.name <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate listDetailViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishEditingChecklist<span class="sy0">:</span><span class="kw1">self</span>.checklistToEdit<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView willSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">nil</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>textField<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITextField</span> <span class="sy0">*</span><span class="br0">&#41;</span>theTextField shouldChangeCharactersInRange<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSRange</span><span class="br0">&#41;</span>range replacementString<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>string
<span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>newText <span class="sy0">=</span> <span class="br0">&#91;</span>theTextField.text stringByReplacingCharactersInRange<span class="sy0">:</span>range withString<span class="sy0">:</span>string<span class="br0">&#93;</span>;
    <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>newText length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span><span class="br0">&#41;</span>;
    <span class="kw1">return</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Again, this is what we did in <code class="objc">ItemDetailViewController</code> but now for <code class="objc">Checklist</code> objects instead of <code class="objc">ChecklistItem</code> objects.</p>

<p>Let’s make the user interface for this new view controller in the Storyboard editor.</p>

<p><strong>&raquo;</strong> Go to the Storyboard editor. Drag a new Navigation Controller from the Object Library into the canvas and move it below the other view controllers.</p>

<figure class="image"><figcaption>Dragging a new navigation controller into the canvas</figcaption><a href="HTML/Figures/Adding_a_new_navigation_controller.png" target="_blank"><img src="HTML/Figures/Thumbnail-Adding_a_new_navigation_controller.png" alt="Dragging a new navigation controller into the canvas"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Adding_a_new_navigation_controller.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> Delete the “Root View Controller” that is attached to the new navigation controller. The Storyboard editor automatically added this second view controller but we don’t need it.</p>

<p><strong>&raquo;</strong> Select the existing Item Detail View Controller. Press Cmd+D to create a duplicate. Move the duplicate next to the new navigation controller. The navigation bar with the Cancel and Done buttons has disappeared from this duplicate but that’s no problem.</p>

<p><strong>&raquo;</strong> Ctrl-drag from the navigation controller into this second Item Detail View Controller and choose “Relationship - Root View Controller”. Now it is hooked up again and the navigation bar with the Cancel/Done buttons has reappeared.</p>

<p><strong>&raquo;</strong> Select the clone of the Item Detail View Controller and go to the Identity Inspector. Change its class to “ListDetailViewController”.</p>

<p><strong>&raquo;</strong> Change the navigation bar title to “Add Checklist” and the placeholder text in the text field to “Name of the Checklist”.</p>

<p>This completes the steps for converting this view controller to the Add / Edit Checklist screen:</p>

<figure class="image"><figcaption>The List Detail View Controller is now hooked up to the new navigation controller</figcaption><a href="HTML/Figures/ListDetailViewController_hooked_up.png" target="_blank"><img src="HTML/Figures/Thumbnail-ListDetailViewController_hooked_up.png" alt="The List Detail View Controller is now hooked up to the new navigation controller"/></a><br><span class="enlarge-image"><a href="HTML/Figures/ListDetailViewController_hooked_up.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> Go to the All Lists View Controller and drag a Bar Button Item into its navigation bar. Change it into an Add button. Ctrl-drag from this button to the navigation controller below to add a new Modal segue.</p>

<p><strong>&raquo;</strong> Click on the new segue and name it “AddChecklist”.</p>

<p><strong>&raquo;</strong> Just so we don’t get confused as to which screen does what, change the title of the Checklist View Controller from “Checklists” to “Checklist Name”.</p>

<p>Our storyboard now looks like this:</p>

<figure class="image"><figcaption>The full storyboard</figcaption><a href="HTML/Figures/Full_storyboard.png" target="_blank"><img src="HTML/Figures/Thumbnail-Full_storyboard.png" alt="The full storyboard"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Full_storyboard.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>Almost there. We still have to make the <code class="objc">AllListsViewController</code> the delegate for the <code class="objc">ListDetailViewController</code> and then we’re done. Again, it’s very similar to what we did before.</p>

<p><strong>&raquo;</strong> In AllListsViewController.m, extend <code class="objc">prepareForSegue</code> to:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>prepareForSegue<span class="sy0">:</span><span class="br0">&#40;</span>UIStoryboardSegue <span class="sy0">*</span><span class="br0">&#41;</span>segue sender<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>sender
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>segue.identifier isEqualToString<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ShowChecklist&quot;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        ChecklistViewController <span class="sy0">*</span>controller <span class="sy0">=</span> segue.destinationViewController;
        controller.checklist <span class="sy0">=</span> sender;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>segue.identifier isEqualToString<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;AddChecklist&quot;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw7">UINavigationController</span> <span class="sy0">*</span>navigationController <span class="sy0">=</span> segue.destinationViewController;
        ListDetailViewController <span class="sy0">*</span>controller <span class="sy0">=</span> <span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>navigationController.topViewController;
        controller.delegate <span class="sy0">=</span> <span class="kw1">self</span>;
        controller.checklistToEdit <span class="sy0">=</span> <span class="kw2">nil</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>The first <code class="objc"><span class="kw1">if</span></code> doesn’t change. We’ve added a second <code class="objc"><span class="kw1">if</span></code> for the “AddChecklist” segue that we just defined in the Storyboard editor. As before, we look for the view controller inside the navigation controller (which is the <code class="objc">ListDetailViewController</code>) and set its <code class="objc">delegate</code> property to <code class="objc"><span class="kw1">self</span></code>.</p>

<p><strong>&raquo;</strong> At the bottom of the AllListsViewController.m, implement the following delegate methods. You’ll get some error messages from Xcode because it doesn’t know anything about <code class="objc">ListDetailViewController</code> here. We’ll fix this in a minute with an <code class="objc"><span class="co1">#import</span></code> so just ignore the errors for now.</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewControllerDidCancel<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingChecklist<span class="sy0">:</span><span class="br0">&#40;</span>Checklist <span class="sy0">*</span><span class="br0">&#41;</span>checklist
<span class="br0">&#123;</span>
    <span class="kw4">int</span> newRowIndex <span class="sy0">=</span> <span class="br0">&#91;</span>lists count<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>lists addObject<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw5">NSIndexPath</span> <span class="sy0">*</span>indexPath <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSIndexPath</span> indexPathForRow<span class="sy0">:</span>newRowIndex inSection<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="kw5">NSArray</span> <span class="sy0">*</span>indexPaths <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObject<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.tableView insertRowsAtIndexPaths<span class="sy0">:</span>indexPaths withRowAnimation<span class="sy0">:</span>UITableViewRowAnimationAutomatic<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingChecklist<span class="sy0">:</span><span class="br0">&#40;</span>Checklist <span class="sy0">*</span><span class="br0">&#41;</span>checklist
<span class="br0">&#123;</span>
    <span class="kw4">int</span> index <span class="sy0">=</span> <span class="br0">&#91;</span>lists indexOfObject<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
    <span class="kw5">NSIndexPath</span> <span class="sy0">*</span>indexPath <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSIndexPath</span> indexPathForRow<span class="sy0">:</span>index inSection<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.tableView cellForRowAtIndexPath<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
    cell.textLabel.text <span class="sy0">=</span> checklist.name;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>None of this code should surprise you. It’s exactly what we did before but now for the <code class="objc">ListDetailViewController</code> and <code class="objc">Checklist</code> objects. These methods are called when the user presses Cancel or Done inside the new Add/Edit Checklist screen.</p>

<p><strong>&raquo;</strong> Also add the table view data source method that allows the user to delete checklists:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView commitEditingStyle<span class="sy0">:</span><span class="br0">&#40;</span>UITableViewCellEditingStyle<span class="br0">&#41;</span>editingStyle forRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span>lists removeObjectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw5">NSArray</span> <span class="sy0">*</span>indexPaths <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObject<span class="sy0">:</span>indexPath<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>tableView deleteRowsAtIndexPaths<span class="sy0">:</span>indexPaths withRowAnimation<span class="sy0">:</span>UITableViewRowAnimationAutomatic<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Finally, declare this view controller to conform to the delegate protocol by adding <code class="objc">&lt;ListDetailViewControllerDelegate&gt;</code> to its <code class="objc"><span class="kw1">@interface</span></code> line. This also takes care of the Xcode errors.</p>

<figure class="code"><figcaption>AllListsViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
<span class="co1">#import &quot;ListDetailViewController.h&quot;</span>
&nbsp;
<span class="kw1">@interface</span> AllListsViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;ListDetailViewControllerDelegate&gt;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p><strong>&raquo;</strong> Run the app. Now you can add new checklists and delete them again, but you can’t edit the names of existing lists yet. That requires one last addition to the code.</p>

<p>To bring up the Edit Checklist screen, the user taps the blue accessory button. In the <code class="objc">ChecklistViewController</code> we did that by triggering a segue that was defined on the view controller itself (rather than on a specific control). We could do that here too, but I want to show you another way. This time we’re not going to use a segue at all, but load the new view controller by hand from the Storyboard.</p>

<p><strong>&raquo;</strong> Add the accessory-tapped delegate method to AllListsViewController.m:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView accessoryButtonTappedForRowWithIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UINavigationController</span> <span class="sy0">*</span>navigationController <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.storyboard instantiateViewControllerWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ListNavigationController&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    ListDetailViewController <span class="sy0">*</span>controller <span class="sy0">=</span> <span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>navigationController.topViewController;
    controller.delegate <span class="sy0">=</span> <span class="kw1">self</span>;
&nbsp;
    Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span>lists objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
    controller.checklistToEdit <span class="sy0">=</span> checklist;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> presentViewController<span class="sy0">:</span>navigationController animated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Inside this method we create the view controller object for the Add/Edit Checklist screen and show it (“present” it) on the screen. In the Bull’s Eye app we did something similar with the About screen, except there we loaded the view controller directly from a nib. This time the view controller is embedded in a Storyboard, so we have to ask the Storyboard object to load it for us.</p>

<p>Where did we get that Storyboard object from? As it happens, each view controller has a <code class="objc"><span class="kw1">self</span>.storyboard</code> property that refers to the Storyboard the view controller was loaded from. We can use that property to do other things with the Storyboard as well, such as instantiating other view controllers.</p>

<p>The call to <code class="objc">instantiateViewControllerWithIdentifier</code>  takes an identifier string, <code class="objc"><span class="co3">@</span><span class="st0">&quot;ListNavigationController&quot;</span></code>. That is how we ask the storyboard to create the new view controller. In our case, this will be the navigation controller that contains the <code class="objc">ListDetailViewController</code>. We could instantiate the <code class="objc">ListDetailViewController</code> directly, but we designed it to work inside the navigation controller so that wouldn’t make much sense (it would no longer have a title bar or Cancel and Done buttons).</p>

<p>We still have to set this identifier on the navigation controller, otherwise the Storyboard cannot find it.</p>

<p><strong>&raquo;</strong> Open the Storyboard editor and select the navigation controller that points to List Detail View Controller.</p>

<p>If you’re still using Xcode version 4.2, 4.3 or 4.4, go to the Attributes Inspector and type “ListNavigationController” into the Identifier field:</p>

<figure class="image"><figcaption>Setting an identifier on the navigation controller in Xcode 4.4 or lower</figcaption><a href="HTML/Figures/ListNavigationController_identifier.png" target="_blank"><img src="HTML/Figures/Thumbnail-ListNavigationController_identifier.png" alt="Setting an identifier on the navigation controller in Xcode 4.4 or lower"/></a><br><span class="enlarge-image"><a href="HTML/Figures/ListNavigationController_identifier.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>On Xcode 4.5 this field has moved into the Identity inspector and is called Storyboard ID:</p>

<figure class="image"><figcaption>Setting an identifier on the navigation controller in Xcode 4.5</figcaption><img src="HTML/Figures/ListNavigationController_identifier_Xcode45.png" alt="Setting an identifier on the navigation controller in Xcode 4.5"/></figure>

<p><strong>&raquo;</strong> That should do the trick. Now run the app and tap some detail disclosure buttons.</p>

<p><strong>Exercise:</strong> Set the “ListNavigationController” identifier on the List Detail View Controller instead and see what happens when you run the app. <strong>◼</strong></p>

<p>You can find the project files for the app up to this point under “07 - Lists” in the tutorial’s Source Code folder.</p>

<hr>

<h2>Putting items into checklists</h2>

<p>This is all well and good, but checklists don’t actually contain any to-do items yet. So far the list of to-do items and the actual checklists have been separate from each other.</p>

<p>Let’s change our data model to look like this:</p>

<figure class="image"><figcaption>Each Checklist object has an array of ChecklistItem objects</figcaption><img src="HTML/Figures/Checklist_data_model.png" alt="Each Checklist object has an array of ChecklistItem objects"/></figure>

<p>There will still be a <code class="objc">lists</code> array that contains the <code class="objc">Checklist</code> objects, but each of these <code class="objc">Checklist</code>s will have its own array of <code class="objc">ChecklistItem</code> objects.</p>

<p><strong>&raquo;</strong> Add a new property to Checklist.h:</p>

<figure class="code"><figcaption>Checklist.h</figcaption><pre class="objc"><span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw5">NSMutableArray</span> <span class="sy0">*</span>items;</pre></figure>

<p><strong>&raquo;</strong> Synthesize it in Checklist.m:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> items;</pre></figure>

<p><strong>&raquo;</strong> Change <code class="objc">Checklist</code>’s <code class="objc">init</code> method to the following:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>init
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.items <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The <code class="objc">Checklist</code> object will now contain the array of <code class="objc">ChecklistItem</code> objects. Initially, that array will be empty.</p>

<p>Earlier we fixed <code class="objc">prepareForSegue</code> so that when you tap on a row in the main screen, we segue into the <code class="objc">ChecklistViewController</code> and the <code class="objc">Checklist</code> object that belongs to that row is passed along. Currently <code class="objc">ChecklistViewController</code> still gets the <code class="objc">ChecklistItem</code> objects from its own <code class="objc">items</code> array but we will change that so it reads from the <code class="objc">items</code> array inside that <code class="objc">Checklist</code> object instead.</p>

<p><strong>&raquo;</strong> Make the following changes in ChecklistViewController.m:</p>

<figure class="code"><figcaption>ChecklistViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span><span class="kw1">self</span>.checklist.items count<span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    . . .
&nbsp;
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.checklist.items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    . . .
&nbsp;
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.checklist.items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView commitEditingStyle<span class="sy0">:</span><span class="br0">&#40;</span>UITableViewCellEditingStyle<span class="br0">&#41;</span>editingStyle forRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.checklist.items removeObjectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView accessoryButtonTappedForRowWithIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    . . .
&nbsp;
    ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.checklist.items objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>itemDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ItemDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    <span class="kw4">int</span> newRowIndex <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.checklist.items count<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.checklist.items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>itemDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ItemDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    <span class="kw4">int</span> index <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.checklist.items indexOfObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span></pre></figure>

<p>Anywhere it said <code class="objc">items</code> you have changed it to say <code class="objc"><span class="kw1">self</span>.checklist.items</code> instead.</p>

<p><strong>&raquo;</strong> Delete the following methods from ChecklistViewController.m:</p>

<ul>
<li><code class="objc"><span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>documentsDirectory</code></li>
<li><code class="objc"><span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>dataFilePath</code></li>
<li><code class="objc"><span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>saveChecklistItems</code></li>
<li><code class="objc"><span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>loadChecklistItems</code></li>
<li><code class="objc"><span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder</code></li>
</ul>

<p>We recently added these methods to load and save the checklist items from a file. That is no longer the responsibility of this view controller, though. It is better for our design if we make the <code class="objc">Checklist</code> object do that. Loading and saving data model objects really belongs in the data model itself, rather than in a controller.</p>

<p>But before we get to that, let’s first test whether our changes were successful. Xcode is complaining about 4 errors because we still call the method <code class="objc">saveChecklistItems</code> at several places in our code. We should remove those lines as we will soon be saving the items in a different place.</p>

<p><strong>&raquo;</strong> Remove the lines that call <code class="objc">saveChecklistItems</code>.</p>

<p><strong>&raquo;</strong> Also remove the <code class="objc">items</code> ivar from the <code class="objc"><span class="kw1">@implementation</span></code>’s variable section at the top.</p>

<p>This:</p>

<pre class="objc"><span class="kw1">@implementation</span> ChecklistViewController <span class="br0">&#123;</span>
    <span class="kw5">NSMutableArray</span> <span class="sy0">*</span>items;
<span class="br0">&#125;</span></pre>

<p>simply becomes again:</p>

<pre class="objc"><span class="kw1">@implementation</span> ChecklistViewController</pre>

<p>Since there are no ivars anymore, the { } brackets are no longer necessary. Note that unlike regular statements, the <code class="objc"><span class="kw1">@implementation</span></code> line never ends in a semicolon!</p>



<aside>
<h3>Xcode errors</h3>

<p>When Xcode detects a problem it shows a warning or error icon at the top of the window:</p>

<figure class="image"><figcaption>Xcode shows an error icon</figcaption><img src="HTML/Figures/Xcode_error.png" alt="Xcode shows an error icon"/></figure>

<p>When you fix the problem, this error icon may not immediately go away. Xcode is pretty smart about detecting any changes you make, but it doesn’t always pick up on everything. At times that may be a bit confusing. After all, you just fixed the problem but Xcode still complains about it.</p>

<p>Just press Run to launch the app or press Cmd+B to do a build without running the app. If there are truly still errors or warnings then Xcode will tell you.</p>

</aside>

<p>Let’s add some fake data into the various <code class="objc">Checklist</code> objects so that we can test whether this new design actually works. In <code class="objc">AllListsViewController</code>’s <code class="objc">initWithCoder</code> method we already put fake <code class="objc">Checklist</code> objects into the <code class="objc">lists</code> array. It’s time to add something new to this method.</p>

<p><strong>&raquo;</strong> At the top of the AllListsViewController.m file, add an import:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="co1">#import &quot;ChecklistItem.h&quot;</span></pre></figure>

<p><strong>&raquo;</strong> Change the <code class="objc">initWithCoder</code> method to the following:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> initWithCoder<span class="sy0">:</span>aDecoder<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        lists <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
&nbsp;
        Checklist <span class="sy0">*</span>list;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        list.name <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Birthdays&quot;</span>;
        <span class="br0">&#91;</span>lists addObject<span class="sy0">:</span>list<span class="br0">&#93;</span>;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        list.name <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Groceries&quot;</span>;
        <span class="br0">&#91;</span>lists addObject<span class="sy0">:</span>list<span class="br0">&#93;</span>;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        list.name <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Cool Apps&quot;</span>;
        <span class="br0">&#91;</span>lists addObject<span class="sy0">:</span>list<span class="br0">&#93;</span>;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        list.name <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;To Do&quot;</span>;
        <span class="br0">&#91;</span>lists addObject<span class="sy0">:</span>list<span class="br0">&#93;</span>;
&nbsp;
        <span class="kw1">for</span> <span class="br0">&#40;</span>Checklist <span class="sy0">*</span>list <span class="kw1">in</span> lists<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
            item.text <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Item for %@&quot;</span>, list.name<span class="br0">&#93;</span>;
            <span class="br0">&#91;</span>list.items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The only new bit is this:</p>

<pre class="objc">        <span class="kw1">for</span> <span class="br0">&#40;</span>Checklist <span class="sy0">*</span>list <span class="kw1">in</span> lists<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
            item.text <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Item for %@&quot;</span>, list.name<span class="br0">&#93;</span>;
            <span class="br0">&#91;</span>list.items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
        <span class="br0">&#125;</span></pre>

<p>This introduces something we haven’t seen before: the <code class="objc"><span class="kw1">for</span></code>-statement. Like <code class="objc"><span class="kw1">if</span></code>, this is a special language construct.</p>

<aside>
<h3>Programming language constructs</h3>

<p>For the sake of review, let’s go over the programming language stuff we’ve already seen. Most modern programming languages offer at least the following basic building blocks:</p>

<ul>
<li>The ability to remember values by storing things into variables. Some variables are simple, such as <code class="objc"><span class="kw4">int</span></code> and <code class="objc"><span class="kw4">BOOL</span></code>. Others can store objects (<code class="objc"><span class="kw7">UIButton</span></code>, <code class="objc">ChecklistItem</code>) and even others can store collections of objects (<code class="objc"><span class="kw5">NSMutableArray</span></code>).</li>
<li>The ability to read values from variables and use them for basic arithmetic (multiply, add) and comparisons (greater than, not equals, etc).</li>
<li>The ability to make decisions. We’ve already seen the <code class="objc"><span class="kw1">if</span></code>-statement, but there is also a <code class="objc"><span class="kw1">switch</span></code> statement that is shorthand for an <code class="objc"><span class="kw1">if</span></code> with many <code class="objc"><span class="kw1">else</span> <span class="kw1">if</span></code>s.</li>
<li>The ability to group functionality into units such as methods and functions. You can call those methods and receive back a result value that you can then use in further computations.</li>
<li>The ability to group functionality (methods) and data (variables) into objects.</li>
<li>The ability to repeat a set of statements more than once. This is what the <code class="objc"><span class="kw1">for</span></code> statement does. There are several other ways to perform repetitions as well: <code class="objc"><span class="kw1">while</span></code> and <code class="objc"><span class="kw1">do</span> <span class="sy0">-</span> <span class="kw1">while</span></code>. Endlessly repeating things is what computers are good at.</li>
</ul>

<p>Everything else is built on top of these building blocks. We’ve seen most of these already, but repetitions (or <em>loops</em> in programmer slang) are new. If you grok these concepts, then you’re well on your way to becoming a software developer.</p>

</aside>

<p>Let’s go through that <code class="objc"><span class="kw1">for</span></code> loop line-by-line:</p>

<pre class="objc">        <span class="kw1">for</span> <span class="br0">&#40;</span>Checklist <span class="sy0">*</span>list <span class="kw1">in</span> lists<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            . . .
        <span class="br0">&#125;</span></pre>

<p>This means the following: for every <code class="objc">Checklist</code> object in the <code class="objc">lists</code> array, perform the statements that are in between the curly braces.</p>

<p>The first time through the loop the <code class="objc">list</code> variable will hold a reference to the Birthdays checklist as that is the first <code class="objc">Checklist</code> object that we created and added to the <code class="objc">lists</code> array.</p>

<p>Then we do:</p>

<pre class="objc">            ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
            item.text <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Item for %@&quot;</span>, list.name<span class="br0">&#93;</span>;
            <span class="br0">&#91;</span>list.items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;</pre>

<p>This shouldn’t be too unfamiliar. We first create a new <code class="objc">ChecklistItem</code> object. Then we set its <code class="objc">text</code> property to “Item for Birthdays” because we replace the <code class="objc"><span class="sy0">%</span>@</code> placeholder with the name of the <code class="objc">Checklist</code> object (<code class="objc">list.name</code>, which is “Birthdays”). Finally, we add this new <code class="objc">ChecklistItem</code> to the Birthdays checklist object, or rather, to its <code class="objc">items</code> array.</p>

<p>That concludes the first pass through this loop. Now the <code class="objc"><span class="kw1">for</span></code>-statement will look at the <code class="objc">lists</code> array again and sees that there are three more <code class="objc">Checklist</code> objects in that list. So it puts the next one, Groceries, into the <code class="objc">list</code> variable and the process repeats. This time the text is “Item for Groceries”, which will be put into its own <code class="objc">ChecklistItem</code> object that goes into the <code class="objc">items</code> array of the Groceries <code class="objc">Checklist</code> object.</p>

<p>After that, we add a new <code class="objc">ChecklistItem</code> with the text “Item for Cool Apps” to the Cool Apps checklist, and an item “Item for To Do” to the To Do checklist. Then there are no more objects left to look at in the <code class="objc">lists</code> array and the loop ends.</p>

<p>Using loops will often save us a lot of time. We could have written this code as follows:</p>

<pre class="objc">        ChecklistItem <span class="sy0">*</span>item;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span>lists objectAtIndex<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
        item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Item for Birthdays&quot;</span>;
        <span class="br0">&#91;</span>list.items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span>lists objectAtIndex<span class="sy0">:</span><span class="nu0">1</span><span class="br0">&#93;</span>;
        item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Item for Groceries&quot;</span>;
        <span class="br0">&#91;</span>list.items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span>lists objectAtIndex<span class="sy0">:</span><span class="nu0">2</span><span class="br0">&#93;</span>;
        item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Item for Cool Apps&quot;</span>;
        <span class="br0">&#91;</span>list.items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;
&nbsp;
        list <span class="sy0">=</span> <span class="br0">&#91;</span>lists objectAtIndex<span class="sy0">:</span><span class="nu0">3</span><span class="br0">&#93;</span>;
        item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        item.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Item for To Do&quot;</span>;
        <span class="br0">&#91;</span>list.items addObject<span class="sy0">:</span>item<span class="br0">&#93;</span>;</pre>

<p>That’s a little repetitive, which is a good sign it’s better to use a loop. And what if we had 100 <code class="objc">Checklist</code> objects? Would you be willing to copy-paste that code a hundred times? I’d rather use a loop.</p>

<p>Most of the time you won’t even know in advance how many objects you’ll have, so it’s impossible to write it all out by hand. By using a loop you don’t need to worry about that. The loop will work just as well for three items as for three hundred. As you can imagine, loops and arrays work quite well together.</p>

<p><strong>&raquo;</strong> Run the app. You’ll see that each checklist now has its own set of items. Play with it for a minute, remove items, add items, and verify that each list indeed is completely separate from the others.</p>

<figure class="image"><figcaption>Each Checklist now has its own items</figcaption><img src="HTML/Figures/Each_Checklist_now_has_its_own_items.png" alt="Each Checklist now has its own items"/></figure>

<p>Let’s put the load/save code back in. This time we will make <code class="objc">AllListsViewController</code> do the loading and saving.</p>

<p><strong>&raquo;</strong> Add the following to AllListsViewController.m, above <code class="objc">initWithCoder</code>:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>documentsDirectory
<span class="br0">&#123;</span>
    <span class="kw5">NSArray</span> <span class="sy0">*</span>paths <span class="sy0">=</span> NSSearchPathForDirectoriesInDomains<span class="br0">&#40;</span>NSDocumentDirectory, NSUserDomainMask, <span class="kw2">YES</span><span class="br0">&#41;</span>;
    <span class="kw5">NSString</span> <span class="sy0">*</span>documentsDirectory <span class="sy0">=</span> <span class="br0">&#91;</span>paths objectAtIndex<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="kw1">return</span> documentsDirectory;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>dataFilePath
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw1">self</span> documentsDirectory<span class="br0">&#93;</span> stringByAppendingPathComponent<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checklists.plist&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>saveChecklists
<span class="br0">&#123;</span>
    <span class="kw5">NSMutableData</span> <span class="sy0">*</span>data <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableData</span> alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    <span class="kw5">NSKeyedArchiver</span> <span class="sy0">*</span>archiver <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSKeyedArchiver</span> alloc<span class="br0">&#93;</span> initForWritingWithMutableData<span class="sy0">:</span>data<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>archiver encodeObject<span class="sy0">:</span>lists forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checklists&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>archiver finishEncoding<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>data writeToFile<span class="sy0">:</span><span class="br0">&#91;</span><span class="kw1">self</span> dataFilePath<span class="br0">&#93;</span> atomically<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>loadChecklists
<span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>path <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span> dataFilePath<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSFileManager</span> defaultManager<span class="br0">&#93;</span> fileExistsAtPath<span class="sy0">:</span>path<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw5">NSData</span> <span class="sy0">*</span>data <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSData</span> alloc<span class="br0">&#93;</span> initWithContentsOfFile<span class="sy0">:</span>path<span class="br0">&#93;</span>;
        <span class="kw5">NSKeyedUnarchiver</span> <span class="sy0">*</span>unarchiver <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSKeyedUnarchiver</span> alloc<span class="br0">&#93;</span> initForReadingWithData<span class="sy0">:</span>data<span class="br0">&#93;</span>;
        lists <span class="sy0">=</span> <span class="br0">&#91;</span>unarchiver decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checklists&quot;</span><span class="br0">&#93;</span>;
        <span class="br0">&#91;</span>unarchiver finishDecoding<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        lists <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>This is mostly identical to what we had before in <code class="objc">ChecklistViewController</code>, except that we load and save the <code class="objc">lists</code> array instead of the <code class="objc">items</code> array.</p>

<p><strong>&raquo;</strong> Change <code class="objc">initWithCoder</code> to:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> initWithCoder<span class="sy0">:</span>aDecoder<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="br0">&#91;</span><span class="kw1">self</span> loadChecklists<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This gets rid of the test data we put there earlier and makes the <code class="objc">loadChecklists</code> method do all the work.</p>

<p>We also have to make the <code class="objc">Checklist</code> object compliant with <code class="objc"><span class="kw6">NSCoding</span></code>.</p>

<p><strong>&raquo;</strong> Add the <code class="objc"><span class="kw6">NSCoding</span></code> protocol in Checklist.h:</p>

<figure class="code"><figcaption>Checklist.h</figcaption><pre class="objc"><span class="kw1">@interface</span> Checklist <span class="sy0">:</span> <span class="kw5">NSObject</span> &lt;NSCoding&gt;</pre></figure>

<p><strong>&raquo;</strong> Add the following methods to Checklist.m:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.name <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Name&quot;</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.items <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Items&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>encodeWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aCoder
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span>aCoder encodeObject<span class="sy0">:</span><span class="kw1">self</span>.name forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Name&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>aCoder encodeObject<span class="sy0">:</span><span class="kw1">self</span>.items forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Items&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Both the <code class="objc">name</code> and <code class="objc">items</code> properties are objects (<code class="objc"><span class="kw5">NSString</span></code> and <code class="objc"><span class="kw5">NSMutableArray</span></code>) so we use <code class="objc">decodeObjectForKey<span class="sy0">:</span></code> and <code class="objc">encodeObject<span class="sy0">:</span>forKey<span class="sy0">:</span></code> to load and save them.</p>

<p><strong>&raquo;</strong> Before you run the app, remove the old Checklists.plist file from the Simulator’s Documents folder. If you don’t, the app might crash because the internal format of the file no longer corresponds to the way we’re loading and saving.</p>



<aside>
<h3>Weird crashes</h3>

<p>When I first wrote this tutorial, I didn’t think to remove the file before running the app. That was a mistake but the app actually worked quite fine... until I added a new checklist. At that point the app aborted with the following error message:</p>

<pre class="no-border">
*** Terminating app due to uncaught exception 'NSRangeException', reason: '***
-[NSMutableIndexSet addIndexesInRange:]: Range {2147483647, 1} exceeds maximum
index value of NSNotFound - 1'
</pre>

<p>The line where the crash occurred was:</p>

<pre class="objc no-border"><span class="br0">&#91;</span><span class="kw1">self</span>.tableView insertRowsAtIndexPaths<span class="sy0">:</span>indexPaths
                      withRowAnimation<span class="sy0">:</span>UITableViewRowAnimationAutomatic<span class="br0">&#93;</span>;</pre>

<p>That is a very strange error message and I started to wonder whether I tested the code properly. But then I thought of the old file, removed it and ran the app again. It worked perfectly. Just to make sure it was the fault of that file, I put a copy of the old file back and ran the app again. Sure enough, when I tried to add a new checklist it crashed.</p>

<p>The explanation for this error is that somehow the code manages to load the old file, even though its format is all wrong and no longer corresponds to our data model, but that this puts the table view into a bad state. Any subsequent operations on the table view will cause the app to crash.</p>

<p>You’ll run into this type of bug every so often, where the crash isn’t directly caused by what you’re doing but by something that went wrong earlier on. These kinds of bugs can be tricky to solve, because you can’t fix them until you find the true cause.</p>

<p>I’ll devote a big section to debugging techniques in a later tutorial because it’s inevitable that you’ll introduce bugs in your code and knowing how to find and eradicate them is an essential skill that any programmer should master (if only to save you a lot of time and aggravation!).</p>

</aside>

<p><strong>&raquo;</strong> Run the app and add a checklist and a few to-do items. Exit the app (with the Stop button) and run it again. You’ll see that the list is empty again.</p>

<p>You can add all the checklists and items you want, but nothing gets saved anymore. What’s going on here?</p>

<h3>Doing saves differently</h3>

<p>Previously, we saved our data whenever the user changed something: added a new item, deleted an item, toggled a checkmark. That all happened in <code class="objc">ChecklistViewController</code>. However, we moved the saving logic into <code class="objc">AllListsViewController</code>. So how do we make sure changes in <code class="objc">ChecklistViewController</code> get saved now?</p>

<p>We could give <code class="objc">ChecklistViewController</code> a reference to the <code class="objc">AllListsViewController</code> and have it call its <code class="objc">saveChecklists</code> method whenever we change something, but that introduces a <em>child-parent dependency</em> and we’ve been trying hard to avoid those.</p>

<p>You may think: ah, we could use a delegate for this. True &mdash; and if you thought that indeed then I’m very proud &mdash; but instead we’ll rethink our saving strategy.</p>

<p>Is it really necessary to save our changes all the time? While the app is running, the data model sits in working memory and is always up-to-date. We never have to load anything from the file (the long-term storage memory) because we did that already when the app started. From then on we always make the changes to our objects in the working memory. It is the file that becomes out-of-date, which is the reason we always saved our changes &mdash; to keep the file in sync with what we had in memory.</p>

<p>The reason we use the file is that we can restore our data model  in working memory after the app gets terminated. But until that happens, the data in our working memory will do just fine. We just need to make sure that we save our data to the file just before the app gets terminated. In other words, the only time we save is when we actually need to keep our data safe. Not only is this more efficient, especially if we have a lot of data, it  also is simpler to program. We no longer need to worry about saving every time the user makes a change to the data, only right before the app terminates.</p>

<p>There are three situations in which an app can terminate:</p>

<ol>
<li>While the user is running the app. This doesn’t happen very often anymore on iOS 4 and up, but earlier versions of iOS did not support multitasking apps. Receiving an incoming phone call, for example, would kill the currently running app. On iOS 4 and better the app will simply be suspended in the background when that happens. There are also situations where iOS may forcefully terminate a running app, for example if the app becomes unresponsive or runs out of memory.</li>

<li>When the app is suspended in the background. Most of the time iOS keeps these apps around for a long time. Their data is frozen in memory and no computations are taking place. (When you resume a suspended app, it literally continues from where it left off.) Sometimes the OS needs to make room for an app that requires a lot of working memory &mdash; often a game &mdash; and then it simply wipes the suspended apps from memory. The apps are not notified of this.</li>

<li>The app crashes. There are ways to detect crashes but handling them can be very tricky. Trying to deal with the crash may actually make things worse. The best way to avoid crashes is to make no programming mistakes! :-)</li>
</ol>

<p>Fortunately for us, iOS will inform the app about significant changes such as: you are about to be terminated, and: you are about to be suspended. We can listen for these events and save our data at that point. That will ensure our on-file representation of the data model is always up-to-date when the app does terminate.</p>

<p>The ideal place for handling these notifications is inside the <em>application delegate</em>. We haven’t spend much time with this object before, but every app has one and as its name implies, it is the delegate object for notifications that concern the app as a whole. This is where you receive the “app will terminate” and “app will be suspended” notifications.</p>

<p>In fact, if you look inside ChecklistsAppDelegate.m, you’ll see the methods:</p>

<pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>applicationDidEnterBackground<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIApplication</span> <span class="sy0">*</span><span class="br0">&#41;</span>application</pre>

<p>and:</p>

<pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>applicationWillTerminate<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIApplication</span> <span class="sy0">*</span><span class="br0">&#41;</span>application</pre>

<p>There are a few others, but these are the ones we need. (The Xcode template put helpful comments inside these methods, so you know what to do with them.)</p>

<p>Now the trick is, how do we call <code class="objc">AllListsViewController</code>’s <code class="objc">saveChecklist</code> method from these delegate methods? The app delegate does not know anything about <code class="objc">AllListsViewController</code> yet. When you use a nib, it is easy to connect the view controller to an outlet in the App Delegate object. Unfortunately, Storyboards do not seem to have this feature at the moment.</p>

<p>We have to use some trickery to find the <code class="objc">AllListsViewController</code> from within the app delegate.</p>

<p><strong>&raquo;</strong> At the top of ChecklistsAppDelegate.m, add:</p>

<figure class="code"><figcaption>ChecklistsAppDelegate.m</figcaption><pre class="objc"><span class="co1">#import &quot;AllListsViewController.h&quot;</span></pre></figure>

<p><strong>&raquo;</strong> Above <code class="objc">applicationDidEnterBackground</code>, add this new method:</p>

<figure class="code"><figcaption>ChecklistsAppDelegate.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>saveData
<span class="br0">&#123;</span>
    <span class="kw7">UINavigationController</span> <span class="sy0">*</span>navigationController <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UINavigationController</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="kw1">self</span>.window.rootViewController;
    AllListsViewController <span class="sy0">*</span>controller <span class="sy0">=</span> <span class="br0">&#40;</span>AllListsViewController <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>navigationController.viewControllers objectAtIndex<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>controller saveChecklists<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Change the <code class="objc">applicationDidEnterBackground</code> and <code class="objc">applicationWillTerminate</code> methods to:</p>

<figure class="code"><figcaption>ChecklistsAppDelegate.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>applicationDidEnterBackground<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIApplication</span> <span class="sy0">*</span><span class="br0">&#41;</span>application
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span> saveData<span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>applicationWillTerminate<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIApplication</span> <span class="sy0">*</span><span class="br0">&#41;</span>application
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span> saveData<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The <code class="objc">saveData</code> method looks at the <code class="objc"><span class="kw1">self</span>.window</code> property to find the <code class="objc"><span class="kw7">UIWindow</span></code> object that contains the storyboard. <code class="objc"><span class="kw7">UIWindow</span></code> is the top-level container for all your app’s views. There is only one <code class="objc"><span class="kw7">UIWindow</span></code> object in your app (unlike desktop apps, which usually have multiple windows).</p>

<p>Normally you don’t need to do anything with your <code class="objc"><span class="kw7">UIWindow</span></code>, but in this case we ask it for its <code class="objc">rootViewController</code>. This is the very first view controller from our storyboard, the navigation controller all the way over on the left. You can see this in the Storyboard editor because this navigation controller has the “Is Initial View Controller” flag set and a big arrow pointing at it:</p>

<figure class="image"><figcaption>The left-most navigation controller is the window’s root view controller</figcaption><img src="HTML/Figures/Initial_view_controller.png" alt="The left-most navigation controller is the window’s root view controller"/></figure>

<p>Once we have the navigation controller, we can find the <code class="objc">AllListsViewController</code> and then call its <code class="objc">saveChecklists</code> method. Unfortunately, the <code class="objc"><span class="kw7">UINavigationController</span></code> does not have a “rootViewController” property, so we have to look into its <code class="objc">viewControllers</code> array to find the bottom one.</p>

<p>The <code class="objc"><span class="kw7">UINavigationController</span></code> does have a <code class="objc">topViewController</code> property but we cannot use it here: the “top” view controller is the screen that is currently displaying, which may very well be the <code class="objc">ChecklistViewController</code>. We don’t want to send the <code class="objc">saveChecklists</code> message to that screen &mdash; it doesn’t have a method to handle that message and the app will crash!</p>

<figure class="image"><figcaption>From the root view controller to the AllListsViewController</figcaption><img src="HTML/Figures/RootViewController.png" alt="From the root view controller to the AllListsViewController"/></figure>

<p>There is a small problem with the changes we’ve made so far: Xcode gives the error that “Receiver type 'AllListsViewController' for instance message does not declare a method with selector 'saveChecklists'” or the error “No visible @interface for 'AllListsViewController' declares the selector 'saveChecklists'”. How can this be when we’ve definitely added the <code class="objc">saveChecklists</code> method to the <code class="objc">AllListsViewController</code> object?</p>

<figure class="image"><figcaption>Xcode error: we’re calling a method on AllListsViewController that it doesn’t have</figcaption><a href="HTML/Figures/Missing_method.png" target="_blank"><img src="HTML/Figures/Thumbnail-Missing_method.png" alt="Xcode error: we’re calling a method on AllListsViewController that it doesn’t have"/></a><br><span class="enlarge-image"><a href="HTML/Figures/Missing_method.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>We haven’t talked much about the distinction between interface and implementation yet, but what an object shows on the outside is different from what it has on the inside. That’s done on purpose because its internals &mdash; the so-called <em>implementation details</em> &mdash; are not interesting to the user of the object. So we hide as much as possible inside the object and only show a few things on the outside.</p>

<p>For example, instance variables are necessary for the implementation only, not for the users of the object. That’s the reason we put them in the <code class="objc"><span class="kw1">@implementation</span></code> section and not in the <code class="objc"><span class="kw1">@interface</span></code> section.</p>

<p>Simply put, the .h file is the interface of an object and the .m file is its implementation.</p>

<p>We’ve only added the <code class="objc">saveChecklists</code> method to the AllListsViewController.m file, inside the <code class="objc"><span class="kw1">@implementation</span></code> section. That means it can be used only by this object itself and no one else. Other objects cannot see this method. It is usually a good idea to hide methods unless other objects need to be able to use them.</p>

<p>To make the <code class="objc">saveChecklists</code> method accessible to other objects, we need to add its <em>signature</em> to the .h file.</p>

<p><strong>&raquo;</strong> Open AllListsViewController.h and add the line:</p>

<figure class="code"><figcaption>AllListsViewController.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>saveChecklists;</pre></figure>

<p>The complete .h file now looks like this:</p>

<figure class="code"><figcaption>AllListsViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
<span class="co1">#import &quot;ListDetailViewController.h&quot;</span>
&nbsp;
<span class="kw1">@interface</span> AllListsViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;ListDetailViewControllerDelegate&gt;
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>saveChecklists;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>Because we’ve added <code class="objc">saveChecklists</code> to the object’s <code class="objc"><span class="kw1">@interface</span></code> section, other objects can now use it.</p>

<p><strong>&raquo;</strong> Run the app, add some checklists, add items to those lists, set some checkmarks. Then press the Home button on the simulator to make the app go to the background. Look inside the app’s Documents folder using Finder. There is now a new Checklists.plist file here. Press Stop in Xcode to terminate the app. Run the app again and your data should still be there. Awesome!</p>

<aside>
<h3>Xcode’s Stop button</h3>

<p>Important note: When you press Xcode’s Stop button, the application delegate will not receive the <code class="objc">applicationWillTerminate</code> notification. Xcode kills the app without mercy. Therefore, to test the saving behavior, first tap the Home button to make the app go into the background and then press Stop. If you don’t press Home first, you’ll lose your data.</p>

</aside>

<h3>Improving the data model</h3>

<p>The above code works but we can do a little better. We have made data model objects for <code class="objc">Checklist</code> and <code class="objc">ChecklistItem</code>, but there is still code in <code class="objc">AllListsViewController</code> &mdash; loading and saving the Checklists.plist object &mdash; that really belongs in the data model.</p>

<p>I prefer to create a top-level <code class="objc">DataModel</code> object for most of my apps. For this app, the <code class="objc">DataModel</code> object will contain the array of <code class="objc">Checklist</code> objects. We can move the code for loading and saving into this new <code class="objc">DataModel</code> object.</p>

<p><strong>&raquo;</strong> Add a new file to the project, Objective-C class, “Subclass of NSObject”. Save as “DataModel”.</p>

<p><strong>&raquo;</strong> Change DataModel.h to the following:</p>

<figure class="code"><figcaption>DataModel.h</figcaption><pre class="objc"><span class="co1">#import &lt;Foundation/Foundation.h&gt;</span>
&nbsp;
<span class="kw1">@interface</span> DataModel <span class="sy0">:</span> <span class="kw5">NSObject</span>
&nbsp;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw5">NSMutableArray</span> <span class="sy0">*</span>lists;
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>saveChecklists;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>We’ve added a <code class="objc">lists</code> property and the <code class="objc">saveChecklist</code> method. <code class="objc">DataModel</code> will be taking over these responsibilities from <code class="objc">AllListsViewController</code>.</p>

<p><strong>&raquo;</strong> Inside DataModel.m, add a <code class="objc"><span class="kw1">@synthesize</span></code> statement below the <code class="objc"><span class="kw1">@implementation</span></code> line:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> lists;</pre></figure>

<p><strong>&raquo;</strong> Change the <code class="objc">init</code> method to:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>init
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="br0">&#91;</span><span class="kw1">self</span> loadChecklists<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Add the following above <code class="objc">init</code>:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>documentsDirectory
<span class="br0">&#123;</span>
    <span class="kw5">NSArray</span> <span class="sy0">*</span>paths <span class="sy0">=</span> NSSearchPathForDirectoriesInDomains<span class="br0">&#40;</span>NSDocumentDirectory, NSUserDomainMask, <span class="kw2">YES</span><span class="br0">&#41;</span>;
    <span class="kw5">NSString</span> <span class="sy0">*</span>documentsDirectory <span class="sy0">=</span> <span class="br0">&#91;</span>paths objectAtIndex<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="kw1">return</span> documentsDirectory;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>dataFilePath
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw1">self</span> documentsDirectory<span class="br0">&#93;</span> stringByAppendingPathComponent<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checklists.plist&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>saveChecklists
<span class="br0">&#123;</span>
    <span class="kw5">NSMutableData</span> <span class="sy0">*</span>data <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableData</span> alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    <span class="kw5">NSKeyedArchiver</span> <span class="sy0">*</span>archiver <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSKeyedArchiver</span> alloc<span class="br0">&#93;</span> initForWritingWithMutableData<span class="sy0">:</span>data<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>archiver encodeObject<span class="sy0">:</span><span class="kw1">self</span>.lists forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checklists&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>archiver finishEncoding<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>data writeToFile<span class="sy0">:</span><span class="br0">&#91;</span><span class="kw1">self</span> dataFilePath<span class="br0">&#93;</span> atomically<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>loadChecklists
<span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>path <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span> dataFilePath<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSFileManager</span> defaultManager<span class="br0">&#93;</span> fileExistsAtPath<span class="sy0">:</span>path<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw5">NSData</span> <span class="sy0">*</span>data <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSData</span> alloc<span class="br0">&#93;</span> initWithContentsOfFile<span class="sy0">:</span>path<span class="br0">&#93;</span>;
        <span class="kw5">NSKeyedUnarchiver</span> <span class="sy0">*</span>unarchiver <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSKeyedUnarchiver</span> alloc<span class="br0">&#93;</span> initForReadingWithData<span class="sy0">:</span>data<span class="br0">&#93;</span>;
        <span class="kw1">self</span>.lists <span class="sy0">=</span> <span class="br0">&#91;</span>unarchiver decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checklists&quot;</span><span class="br0">&#93;</span>;
        <span class="br0">&#91;</span>unarchiver finishDecoding<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.lists <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>I simply cut these lines out of <code class="objc">AllListsViewController</code>, so make sure they are no longer in that file. Also note that <code class="objc">lists</code> is now a property, so we should access it as <code class="objc"><span class="kw1">self</span>.lists</code>.</p>

<p><strong>&raquo;</strong> Change AllListsViewController.h to:</p>

<figure class="code"><figcaption>AllListsViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
<span class="co1">#import &quot;ListDetailViewController.h&quot;</span>
<span class="co1">#import &quot;DataModel.h&quot;</span>
&nbsp;
<span class="kw1">@interface</span> AllListsViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;ListDetailViewControllerDelegate&gt;
&nbsp;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> DataModel <span class="sy0">*</span>dataModel;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p><strong>&raquo;</strong> We’ve removed the <code class="objc">saveChecklists</code> method and added the <code class="objc">dataModel</code> property.</p>

<p>You should already have removed the <code class="objc">documentsDirectory</code>, <code class="objc">dataFilePath</code>, <code class="objc">saveChecklists</code> and <code class="objc">loadChecklists</code> methods from AllListsViewController.m.</p>

<p><strong>&raquo;</strong> Also remove the <code class="objc">lists</code> ivar.</p>

<p><strong>&raquo;</strong> Synthesize the new <code class="objc">dataModel</code> property:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> dataModel;</pre></figure>

<p><strong>&raquo;</strong> Change <code class="objc">initWithCoder</code> to the following:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> initWithCoder<span class="sy0">:</span>aDecoder<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.dataModel <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>DataModel alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This method creates the <code class="objc">DataModel</code> object.</p>

<p>We can no longer reference the <code class="objc">lists</code> ivar directly, because it no longer exists. Instead, we’ll have to ask the <code class="objc">DataModel</code> for its <code class="objc">lists</code> property.</p>

<p><strong>&raquo;</strong> Make the following changes:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists count<span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    . . .
&nbsp;
    Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView commitEditingStyle<span class="sy0">:</span><span class="br0">&#40;</span>UITableViewCellEditingStyle<span class="br0">&#41;</span>editingStyle forRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists removeObjectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView accessoryButtonTappedForRowWithIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    . . .
&nbsp;
    Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingChecklist<span class="sy0">:</span><span class="br0">&#40;</span>Checklist <span class="sy0">*</span><span class="br0">&#41;</span>checklist
<span class="br0">&#123;</span>
    <span class="kw4">int</span> newRowIndex <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists count<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists addObject<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingChecklist<span class="sy0">:</span><span class="br0">&#40;</span>Checklist <span class="sy0">*</span><span class="br0">&#41;</span>checklist
<span class="br0">&#123;</span>
    <span class="kw4">int</span> index <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists indexOfObject<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> One last change, in ChecklistsAppDelegate.m:</p>

<figure class="code"><figcaption>ChecklistsAppDelegate.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>saveData
<span class="br0">&#123;</span>
    <span class="kw7">UINavigationController</span> <span class="sy0">*</span>navigationController <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UINavigationController</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="kw1">self</span>.window.rootViewController;
    AllListsViewController <span class="sy0">*</span>controller <span class="sy0">=</span> <span class="br0">&#40;</span>AllListsViewController <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>navigationController.viewControllers objectAtIndex<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>controller.dataModel saveChecklists<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We no longer call <code class="objc">saveChecklists</code> on <code class="objc">AllListsViewController</code> but on its <code class="objc">dataModel</code> property.</p>

<p><strong>&raquo;</strong> Do a clean build (Product → Clean) and run the app. Verify that everything still works.</p>

<p>You can find the project files for the app up to this point under “08 - Improved Data Model” in the tutorial’s Source Code folder.</p>

<hr>

<h2>Using NSUserDefaults to remember stuff</h2>

<p>We now have an app that lets you create checklists and add to-do items to those lists.<br>All of this data is saved to long-term storage so even if the app gets terminated, nothing is lost. There are some user interface improvements we can make, though.</p>

<p>Imagine the user is on the Birthdays checklist and presses the Home button to switch to another app. The Checklists app is now suspended. Suppose that at some point the app gets terminated. When the user reopens the app it no longer is on Birthdays but on the main screen. Because it was terminated the app didn’t simply resume where it left off, but got launched anew.</p>

<p>You might be able to get away with this, as apps don’t get terminated often (unless you play a lot of games that eat up memory) but little things like this matter in iOS apps. Fortunately, it’s fairly easy to remember whether the user has opened a checklist and to switch to it when the app starts up.</p>

<p>We could store this information in the Checklists.plist file, but especially for simple settings such as this there is the <code class="objc"><span class="kw5">NSUserDefaults</span></code> object.</p>

<p><code class="objc"><span class="kw5">NSUserDefaults</span></code> works like a dictionary, which is a collection object for storing key-value pairs. We’ve already seen the array collection, which stores an ordered list of objects. The dictionary is another very common collection that looks like this:</p>

<figure class="image"><figcaption>A dictionary is a collection of key-value pairs</figcaption><img src="HTML/Figures/Dictionary.png" alt="A dictionary is a collection of key-value pairs"/></figure>

<p>Dictionaries in Objective-C are handled by the <code class="objc"><span class="kw5">NSDictionary</span></code> and <code class="objc"><span class="kw5">NSMutableDictionary</span></code> objects. You can put objects into the dictionary under a reference key and then retrieve it later using that key. This is, in fact, how Info.plist works. This plist file is read into a dictionary and then iOS uses the various keys (on the left hand) to obtain the values (on the right hand). Keys are usually strings but values can be any type of object.</p>

<p><code class="objc"><span class="kw5">NSUserDefaults</span></code> isn’t a true dictionary, but it acts like one. When you insert new values into <code class="objc"><span class="kw5">NSUserDefaults</span></code>, they are saved somewhere in your app’s sandbox so these values persist even after the app terminates. You don’t want to store huge amounts of data inside <code class="objc"><span class="kw5">NSUserDefaults</span></code>, but it’s ideal for small things like settings &mdash; and for remembering what screen the app was on when it closed.</p>

<p>This is what we are going to do:</p>

<ul>
<li>On the segue from the main screen (<code class="objc">AllListsViewController</code>) to the checklist screen (<code class="objc">ChecklistViewController</code>), we write the row index of the selected checklist into <code class="objc"><span class="kw5">NSUserDefaults</span></code>. This is how we’ll remember which checklist was selected. We could have saved the name of the checklist instead of the row index, but what would happen then if two checklists have the same name? Unlikely, but not impossible. Using the row index guarantees that we’ll always select the proper one.</li>

<li>When the user presses the back button to return to the main screen, we have to remove this value from <code class="objc"><span class="kw5">NSUserDefaults</span></code> again. It is common to set a value such as this to -1 to mean “no value”. Why -1? We start counting rows at 0, so we can’t use 0 or a positive number (unless we use a huge number such as 1000000; it’s very unlikely the user will make that many checklists). -1 is not a valid row index and because it’s a negative value it looks weird, so that makes it easy to spot during debugging.</li>

<li>If the app starts up and the value from <code class="objc"><span class="kw5">NSUserDefaults</span></code> isn’t -1, then the user was previously viewing the contents of a checklist and we have to manually perform a segue to the <code class="objc">ChecklistViewController</code> for the corresponding row.</li>
</ul>

<p>Phew, it’s more work to explain this in English than writing the actual code. ;-)</p>

<p>Let’s start with the segue from the main screen.</p>

<p><strong>&raquo;</strong> In AllListsViewController.m, change <code class="objc">didSelectRowAtIndexPath</code> to the following:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span> setInteger<span class="sy0">:</span>indexPath.row forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistIndex&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span> performSegueWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ShowChecklist&quot;</span> sender<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>In addition to what this method did before, we now store the index of the selected row into <code class="objc"><span class="kw5">NSUserDefaults</span></code> under the key “ChecklistIndex”.</p>

<p>To recognize whether the user presses the back button on the navigation bar, we have to set a delegate for the navigation controller. The logical place for this delegate is the <code class="objc">AllListsViewController</code>.</p>

<p><strong>&raquo;</strong> Add the delegate protocol to the <code class="objc">AllListsViewController</code> <code class="objc"><span class="kw1">@interface</span></code> line:</p>

<figure class="code"><figcaption>AllListsViewController.h</figcaption><pre class="objc"><span class="kw1">@interface</span> AllListsViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;ListDetailViewControllerDelegate, UINavigationControllerDelegate&gt;</pre></figure>

<p>As you can see, a view controller can be a delegate for many other objects at once. <code class="objc">AllListsViewController</code> is now the delegate for both the <code class="objc">ListDetailViewController</code> and the <code class="objc"><span class="kw7">UINavigationController</span></code>, but also implicitly for the <code class="objc"><span class="kw7">UITableView</span></code> (because it is a table view controller).</p>

<p><strong>&raquo;</strong> Add the delegate method to the bottom of AllListsViewController.m:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>navigationController<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UINavigationController</span> <span class="sy0">*</span><span class="br0">&#41;</span>navigationController willShowViewController<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIViewController</span> <span class="sy0">*</span><span class="br0">&#41;</span>viewController animated<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>animated
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>viewController <span class="sy0">==</span> <span class="kw1">self</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span> setInteger<span class="sy0">:-</span><span class="nu0">1</span> forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistIndex&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>This method is called whenever the navigation controller will slide to a new screen. If the back button was pressed, then the new view controller is the <code class="objc">AllListsViewController</code> itself and we set the “ChecklistIndex” value in <code class="objc"><span class="kw5">NSUserDefaults</span></code> to -1.</p>

<p>The only thing that remains is to check at startup which checklist we need to show and then perform the segue manually. We’ll do that in <code class="objc">viewDidAppear</code>.</p>

<p><strong>&raquo;</strong> Change (or add) the <code class="objc">viewDidAppear</code> method:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidAppear<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>animated
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidAppear<span class="sy0">:</span>animated<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">self</span>.navigationController.delegate <span class="sy0">=</span> <span class="kw1">self</span>;
&nbsp;
    <span class="kw4">int</span> index <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span> integerForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistIndex&quot;</span><span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>index <span class="sy0">!=</span> <span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists objectAtIndex<span class="sy0">:</span>index<span class="br0">&#93;</span>;
        <span class="br0">&#91;</span><span class="kw1">self</span> performSegueWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ShowChecklist&quot;</span> sender<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>This method is called after the view controller has become visible. We make ourselves the delegate for the navigation controller and then check <code class="objc"><span class="kw5">NSUserDefaults</span></code> whether we have to perform the segue.</p>

<p>If the value of the “ChecklistIndex” setting is not -1, then the user was previously viewing a checklist and we should segue to that screen. As before, we send the <code class="objc">Checklist</code> object along with the <code class="objc">sender</code> parameter of <code class="objc">performSegueWithIdentifier</code>.</p>

<p>Note that <code class="objc"><span class="sy0">!=</span></code> means: not equal. It is the opposite of the <code class="objc"><span class="sy0">==</span></code> operator. (Some languages use <code class="objc">&lt;&gt;</code> for not equal but that won’t work in Objective-C.)</p>

<aside>

<p>I’m actually guilty of a bit of trickery here. <code class="objc">viewDidAppear</code> isn’t just called when the app starts up but also every time the navigation controller slides the main screen back into view. Checking whether to restore the checklist screen needs to happen just once when the app starts, so why did I put this logic in <code class="objc">viewDidAppear</code>?</p>

<p>The very first time that <code class="objc">AllListsViewController</code>’s screen becomes visible we do not want the <code class="objc">willShowViewController</code> delegate method to be called, as that would always overwrite the old value of “ChecklistIndex” with -1, before we’ve had a chance to restore the old screen. By waiting to register <code class="objc">AllListsViewController</code> as the navigation controller delegate until it is visible, we avoid this problem.</p>



<p>When the user presses the back button, the navigation controller will call <code class="objc">willShowViewController</code> before <code class="objc">viewDidAppear</code>. Because the value of “ChecklistIndex” will now always be -1, <code class="objc">viewDidAppear</code> does not trigger a segue again. There are other ways to solve this particular issue but this approach is simple, so I like it.</p>

<p>Is all of this going way over your head? Don’t worry about it.  Let it sink in and soon enough it will all start to make sense. Even better, probe around in the code. Change things around to see what the effect is. That’s the quickest way to learn!</p>

</aside>

<p><strong>&raquo;</strong> Run the app and go to a checklist screen. Press the simulator’s Home button, followed by Stop to quit the app.</p>

<p>Tip: You need to press the Home button because <code class="objc"><span class="kw5">NSUserDefaults</span></code> may not immediately save its settings to disk and therefore you may lose your changes if you kill the app from within Xcode.</p>

<p><strong>&raquo;</strong> Run the app again and you’ll notice that Xcode immediately switches to the screen where you were last at. Cool, huh!</p>

<p><strong>&raquo;</strong> Now do the following: Stop the app and delete it from the Simulator. You can either reset the whole simulator from its menu (iOS Simulator → Reset Contents and Settings) or hold down the app icon until it starts to wiggle and then delete it just as you would on your iPhone.</p>

<p>Then run the app again from within Xcode and watch it crash:</p>

<pre>
*** Terminating app due to uncaught exception 'NSRangeException', reason: '***
-[__NSArrayM objectAtIndex:]: index 0 beyond bounds for empty array'
</pre>

<p>The app crashes in <code class="objc">viewDidAppear</code> on the line:</p>

<pre class="objc">Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists objectAtIndex<span class="sy0">:</span>index<span class="br0">&#93;</span>;</pre>

<p>What’s going on here? Apparently the value of the <code class="objc">index</code> variable is 0, even though there should be nothing in <code class="objc"><span class="kw5">NSUserDefaults</span></code> yet because this is a fresh install of our app. We didn’t write anything in the “ChecklistIndex” key yet.</p>

<p>It turns out that <code class="objc"><span class="kw5">NSUserDefaults</span></code>’s <code class="objc">integerForKey</code> method returns 0 if it cannot find the value for the key you specify, but in our app 0 is a valid row index. At this point the app doesn’t have any checklists yet, so index 0 does not exist in the <code class="objc">lists</code> array. That is why the app crashes.</p>

<p>What we would like instead, is that <code class="objc"><span class="kw5">NSUserDefaults</span></code> returns -1 if the “ChecklistIndex” key isn’t set, because to us -1 means: show the main screen instead of a specific checklist. Fortunately, <code class="objc"><span class="kw5">NSUserDefaults</span></code> will let us set default values for the default values. Yep, you read that correctly.</p>

<p>Let’s do that in our <code class="objc">DataModel</code> object.</p>

<p><strong>&raquo;</strong> Add the following method above <code class="objc">init</code> inside DataModel.m:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>registerDefaults
<span class="br0">&#123;</span>
    <span class="kw5">NSDictionary</span> <span class="sy0">*</span>dictionary <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSDictionary</span> dictionaryWithObjectsAndKeys<span class="sy0">:</span>
        <span class="br0">&#91;</span><span class="kw5">NSNumber</span> numberWithInt<span class="sy0">:-</span><span class="nu0">1</span><span class="br0">&#93;</span>, <span class="co3">@</span><span class="st0">&quot;ChecklistIndex&quot;</span>,
        <span class="kw2">nil</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span> registerDefaults<span class="sy0">:</span>dictionary<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This creates a new <code class="objc"><span class="kw5">NSDictionary</span></code> object and adds the value -1 for the key “ChecklistIndex”. <code class="objc"><span class="kw5">NSUserDefaults</span></code> will use the values from this dictionary if you ask it for a key but it cannot find anything under that key.</p>

<p><strong>&raquo;</strong> Change <code class="objc">init</code> to call this new method:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>init
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="br0">&#91;</span><span class="kw1">self</span> loadChecklists<span class="br0">&#93;</span>;
        <span class="br0">&#91;</span><span class="kw1">self</span> registerDefaults<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Run the app again and now it should no longer crash.</p>

<p>Why did we do this in <code class="objc">DataModel</code>? Well, I don’t really like to sprinkle all of these calls to <code class="objc"><span class="kw5">NSUserDefaults</span></code> throughout the code. In fact, lets move all of the <code class="objc"><span class="kw5">NSUserDefaults</span></code> stuff into <code class="objc">DataModel</code>.</p>

<p><strong>&raquo;</strong> Add the following methods to the bottom of DataModel.m, before <code class="objc"><span class="kw1">@end</span></code>:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>indexOfSelectedChecklist
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span> integerForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistIndex&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>setIndexOfSelectedChecklist<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>index
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span> setInteger<span class="sy0">:</span>index forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistIndex&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We’re doing this so the rest of the code won’t have to worry about <code class="objc"><span class="kw5">NSUserDefaults</span></code>. Our other objects just have to call the proper methods on <code class="objc">DataModel</code>. Hiding implementation details is an important Object-Oriented Programming principle. If we decide later that we want to store these settings somewhere else, for example in a database, then we only have to change this in one place, in <code class="objc">DataModel</code>. The rest of the code will be oblivious to these changes and that’s a good thing.</p>

<p>We need to add these methods to DataModel.h too, otherwise the other objects cannot use them.</p>

<p><strong>&raquo;</strong> Add the method signatures to DataModel.h:</p>

<figure class="code"><figcaption>DataModel.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>indexOfSelectedChecklist;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>setIndexOfSelectedChecklist<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>index;</pre></figure>

<p><strong>&raquo;</strong> Update the code in AllListsViewController.m to use these new methods:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidAppear<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>animated
<span class="br0">&#123;</span>
      . . .
&nbsp;
    <span class="kw4">int</span> index <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel indexOfSelectedChecklist<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel setIndexOfSelectedChecklist<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>navigationController<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UINavigationController</span> <span class="sy0">*</span><span class="br0">&#41;</span>navigationController willShowViewController<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIViewController</span> <span class="sy0">*</span><span class="br0">&#41;</span>viewController animated<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>animated
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>viewController <span class="sy0">==</span> <span class="kw1">self</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel setIndexOfSelectedChecklist<span class="sy0">:-</span><span class="nu0">1</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Run the app again and make sure everything still works.</p>

<p>It’s pretty nice that the app now remembers what screen you were on, but this new feature has also introduced a subtle bug in the app. Here’s how to reproduce it:</p>

<p><strong>&raquo;</strong> Start the app and add a new checklist. Also add a new to-do item to this list. Now kill the app from within Xcode.</p>

<p>Because you did not press the Home button, the new checklist and its item were not saved to Checklists.plist. However, there is a (small) chance that <code class="objc"><span class="kw5">NSUserDefaults</span></code> did save its changes to disk and now thinks this new list is selected. That’s a problem because that list doesn’t exist anymore (it never made it into Checklists.plist).</p>

<p><code class="objc"><span class="kw5">NSUserDefaults</span></code> will save its changes at indeterminate times so it could have saved before you terminated the app. (This is especially true when you implement local notifications later in this tutorial, where we force <code class="objc"><span class="kw5">NSUserDefaults</span></code> to save its changes every time you add a new to-do item. Then the app is guaranteed to crash at this point.)</p>

<p><strong>&raquo;</strong> Run the app again and &mdash; if you’re lucky? &mdash; it will crash with:</p>

<pre>
Checklists[1124:707] *** Terminating app due to uncaught exception
'NSRangeException', reason: '*** -[__NSArrayM objectAtIndex:]:
index 1 beyond bounds [0 .. 0]'
</pre>

<p>The problem is that <code class="objc"><span class="kw5">NSUserDefaults</span></code> and the contents of Checklists.plist are out-of-sync. <code class="objc"><span class="kw5">NSUserDefaults</span></code> thinks we need to select a checklist that doesn’t actually exist. Every time you run the app it will now crash. Yikes!</p>

<p>This situation shouldn’t really happen during regular usage because we used the Xcode Stop button to kill the app. Under normal circumstances the user would press the Home button at some point and as the app goes into the background it will save both Checklists.plist and <code class="objc"><span class="kw5">NSUserDefaults</span></code> and everything is in sync again. However, the OS can always decide to terminate the app and then this situation could occur.</p>

<p>Even though there’s only a small chance that this can go wrong in practice, we should really protect ourselves against it. These are the kinds of bug reports you don’t want to get because often you have no idea what the user did to make it happen. It’s good to stick to the practice of <em>defensive programming</em>, to check for boundary cases and be able to gracefully handle them even if they are unlikely to occur.</p>

<p>In our case, we can fix <code class="objc">AllListsViewController</code>’s <code class="objc">viewDidAppear</code> method to deal with this situation.</p>

<p><strong>&raquo;</strong> Change <code class="objc">viewDidAppear</code> to:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidAppear<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>animated
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidAppear<span class="sy0">:</span>animated<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">self</span>.navigationController.delegate <span class="sy0">=</span> <span class="kw1">self</span>;
&nbsp;
    <span class="kw4">int</span> index <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel indexOfSelectedChecklist<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>index &gt;<span class="sy0">=</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> index &lt; <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists count<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists objectAtIndex<span class="sy0">:</span>index<span class="br0">&#93;</span>;
        <span class="br0">&#91;</span><span class="kw1">self</span> performSegueWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ShowChecklist&quot;</span> sender<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>The changed line is this:</p>

<pre class="objc">    <span class="kw1">if</span> <span class="br0">&#40;</span>index &gt;<span class="sy0">=</span> <span class="nu0">0</span> <span class="sy0">&amp;&amp;</span> index &lt; <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists count<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span></pre>

<p>Instead of just checking for <code class="objc">index <span class="sy0">!=</span> <span class="sy0">-</span><span class="nu0">1</span></code>, we now do a more precise check to determine whether <code class="objc">index</code> is valid. It should be between 0 and the number of checklists in our data model. If not, then we simply don’t segue. This will prevent <code class="objc">objectAtIndex</code> from asking for an object that doesn’t exist.</p>

<p>We haven’t seen the <code class="objc"><span class="sy0">&amp;&amp;</span></code> operator before. This symbol means “logical and”. It is used as follows:</p>

<pre class="objc"><span class="kw1">if</span> <span class="br0">&#40;</span>something <span class="sy0">&amp;&amp;</span> somethingElse<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co2">// do stuff</span>
<span class="br0">&#125;</span></pre>

<p>This reads: if something is true <em>and</em> something else is also true, then do stuff.</p>

<p>In <code class="objc">viewDidAppear</code> we only perform the segue when <code class="objc">index</code> is 0 or greater <em>and also</em> less than the number of checklists, which means it’s only valid if it lies in between those two values.</p>

<p>With this defensive check in place, we’re guaranteed that the app will not try to segue to a checklist that doesn’t exist, even if our data is out-of-sync.</p>

<aside>

<p>Note that the app doesn’t remember whether the user had the Add/Edit Checklist or Add/Edit Item screen open. These kinds of modal screens are supposed to be temporary. You open them to make a few changes and then close them again. If the app goes to the background and is terminated, then it’s no big deal if the modal screen disappears.</p>

<p>At least that is true for this app. If you have an app that allows the user to make many complicated edits in a modal screen, then you may want to persist those changes when the app closes so the user won’t lose all his work in case the app is killed.</p>

</aside>

<h3>The first-run experience</h3>

<p>Let’s use <code class="objc"><span class="kw5">NSUserDefaults</span></code> for something else. It would be nice if the first time you ran the app it created a default checklist for you, simply named “List”, and switched the screen to that list. This enables you to start adding to-do items right away. That’s how the standard Notes app works too: you can start typing a note right after launching the app for the very first time, but you can also go one level back in the navigation hierarchy to see a list of all notes.</p>

<p>To pull this off, we need to keep track in <code class="objc"><span class="kw5">NSUserDefaults</span></code> whether this is the first time the user runs the app. If it is, then we create a new <code class="objc">Checklist</code> object. We can do all of this inside <code class="objc">DataModel</code>.</p>

<p><strong>&raquo;</strong> Add the following import to the top of DataModel.m:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="co1">#import &quot;Checklist.h&quot;</span></pre></figure>

<p>We will add a new default to the <code class="objc">registerDefaults</code> method. The key for this value is “FirstTime”.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">registerDefaults</code> method:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>registerDefaults
<span class="br0">&#123;</span>
    <span class="kw5">NSDictionary</span> <span class="sy0">*</span>dictionary <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSDictionary</span> dictionaryWithObjectsAndKeys<span class="sy0">:</span>
        <span class="br0">&#91;</span><span class="kw5">NSNumber</span> numberWithInt<span class="sy0">:-</span><span class="nu0">1</span><span class="br0">&#93;</span>, <span class="co3">@</span><span class="st0">&quot;ChecklistIndex&quot;</span>,
        <span class="br0">&#91;</span><span class="kw5">NSNumber</span> numberWithBool<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>, <span class="co3">@</span><span class="st0">&quot;FirstTime&quot;</span>,
        <span class="kw2">nil</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span> registerDefaults<span class="sy0">:</span>dictionary<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We say <code class="objc"><span class="br0">&#91;</span><span class="kw5">NSNumber</span> numberWithBool<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span></code> because we want the value of “FirstTime” to be <code class="objc"><span class="kw2">YES</span></code> if this is the first time we run the app after a fresh install.</p>

<aside>
<h3>Primitive values vs objects</h3>

<p>Dictionaries cannot contain primitive values such as <code class="objc"><span class="kw4">int</span></code> and <code class="objc"><span class="kw4">BOOL</span></code>, only objects. The same thing goes for arrays. If you want to put an <code class="objc"><span class="kw4">int</span></code> or <code class="objc"><span class="kw4">BOOL</span></code> value into a dictionary or array, you have to convert it into an <code class="objc"><span class="kw5">NSNumber</span></code> object first.</p>

<p>I have briefly mentioned the difference between primitive datatypes and objects a few times before. In some programming languages everything is an object; in Objective-C <em>almost</em> everything is an object. There is a cost associated with using objects and for certain simple operations, such as doing arithmetic with whole numbers, it’s easier and faster to do this with primitive values instead.</p>

<p>You can tell primitive types and objects apart by the <code class="objc"><span class="sy0">*</span></code> that follows their name. Only objects have this asterisk. In addition, you do not use <code class="objc"><span class="br0">&#91;</span><span class="br0">&#91;</span>alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span></code> to create primitive values.</p>

<p>Sometimes you need to convert between primitive types and objects. To put an <code class="objc"><span class="kw4">int</span></code> or <code class="objc"><span class="kw4">BOOL</span></code> value into a dictionary, you need to stuff it into an <code class="objc"><span class="kw5">NSNumber</span></code> object first. The other way around is possible too: to get an integer value out of an <code class="objc"><span class="kw5">NSNumber</span></code>, you’d do <code class="objc"><span class="br0">&#91;</span>number intValue<span class="br0">&#93;</span></code>. For a <code class="objc"><span class="kw4">BOOL</span></code> that is <code class="objc"><span class="br0">&#91;</span>boolValue<span class="br0">&#93;</span></code>.</p>

<p>If you’re still confused about the difference between primitive values and objects, then rest assured, a more detailed explanation is forthcoming in the next tutorial.</p>

</aside>

<p><strong>&raquo;</strong> Add the <code class="objc">handleFirstTime</code> method, above <code class="objc">init</code>:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>handleFirstTime
<span class="br0">&#123;</span>
    <span class="kw4">BOOL</span> firstTime <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span> boolForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;FirstTime&quot;</span><span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>firstTime<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        checklist.name <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;List&quot;</span>;
        <span class="br0">&#91;</span><span class="kw1">self</span>.lists addObject<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
        <span class="br0">&#91;</span><span class="kw1">self</span> setIndexOfSelectedChecklist<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>;
        <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span> setBool<span class="sy0">:</span><span class="kw2">NO</span> forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;FirstTime&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>Here we check <code class="objc"><span class="kw5">NSUserDefaults</span></code> for the value of the “FirstTime” key. Interestingly enough, we can simply forget about the whole <code class="objc"><span class="kw5">NSNumber</span></code> thing and ask the <code class="objc"><span class="kw5">NSUserDefaults</span></code> directly for a boolean value. Converting to an <code class="objc"><span class="kw5">NSNumber</span></code> was only necessary when we registered the defaults. (That’s because <code class="objc"><span class="kw5">NSUserDefaults</span></code> isn’t a true dictionary object but only acts like one.)</p>

<p>If the “FirstTime” value is <code class="objc"><span class="kw2">YES</span></code>, then this is the first time the app is being run. We create a new <code class="objc">Checklist</code> object and add it to the array. We call <code class="objc">setIndexOfSelectedChecklist</code> to make sure we’ll automatically segue to this new checklist in <code class="objc">AllListsViewController</code>’s <code class="objc">viewDidAppear</code>. Finally, we’ll set “FirstTime” to <code class="objc"><span class="kw2">NO</span></code>, so this bit of code won’t be executed again the next time the app starts up.</p>

<p><strong>&raquo;</strong> Call this new method in <code class="objc">init</code>:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>init
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="br0">&#91;</span><span class="kw1">self</span> loadChecklists<span class="br0">&#93;</span>;
        <span class="br0">&#91;</span><span class="kw1">self</span> registerDefaults<span class="br0">&#93;</span>;
        <span class="br0">&#91;</span><span class="kw1">self</span> handleFirstTime<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Remove the app from the Simulator and run it again from Xcode. Because it’s the first time we run the app (at least from the app’s perspective), it will automatically create a new checklist named List and switch to it.</p>

<hr>

<h2>Improving the user experience</h2>

<h3>Showing the number of to-do items remaining</h3>

<p>There are a few small features I’d like to add, just to polish the app a little more. After all, we’re building a real app here &mdash; if you want to make top-notch apps, you have to pay attention to those details.</p>

<p>In the main screen, for each checklist I want to show the number of to-do items that do not have checkmarks yet:</p>

<figure class="image"><figcaption>Each checklist shows how many items are still left to-do</figcaption><img src="HTML/Figures/Show_remaining_items.png" alt="Each checklist shows how many items are still left to-do"/></figure>

<p>First, we need a way to count these items.</p>

<p><strong>&raquo;</strong> Add the following method to Checklist.h:</p>

<figure class="code"><figcaption>Checklist.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>countUncheckedItems;</pre></figure>

<p>With this method we can ask any <code class="objc">Checklist</code> object how many of its <code class="objc">ChecklistItem</code> objects do not yet have their checkmark set. The method returns this count as an <code class="objc"><span class="kw4">int</span></code> value.</p>

<p><strong>&raquo;</strong> Add the implementation of the <code class="objc">countUncheckedItems</code> method to Checklist.m:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>countUncheckedItems
<span class="br0">&#123;</span>
    <span class="kw4">int</span> count <span class="sy0">=</span> <span class="nu0">0</span>;
    <span class="kw1">for</span> <span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span>item <span class="kw1">in</span> <span class="kw1">self</span>.items<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>item.checked<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            count <span class="sy0">+=</span> <span class="nu0">1</span>;
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> count;
<span class="br0">&#125;</span></pre></figure>

<p>This method loops through the <code class="objc">ChecklistItem</code> objects from the <code class="objc">items</code> array. If the <code class="objc">item</code> object has its <code class="objc">checked</code> property set to <code class="objc"><span class="kw2">NO</span></code>, we increment the local variable <code class="objc">count</code> by 1. When we’ve looked at all the objects, we return the value of this count to the caller.</p>

<p>Remember that the <code class="objc"><span class="sy0">!</span></code> operator negates the result. So it <code class="objc">item.checked</code> is <code class="objc"><span class="kw2">YES</span></code>, then <code class="objc"><span class="sy0">!</span>item.checked</code> will make it <code class="objc"><span class="kw2">NO</span></code>. You should read it as “if not <code class="objc">item.checked</code>”.</p>

<p>This also needs an import for <code class="objc">ChecklistItem</code> or Xcode won’t let us call <code class="objc">item.checked</code> on the object.</p>

<p><strong>&raquo;</strong> Add the import at the top of Checklist.m:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="co1">#import &quot;ChecklistItem.h&quot;</span></pre></figure>

<p><strong>&raquo;</strong> Go to AllListsViewController.m and change <code class="objc">cellForRowAtIndexPath</code> to:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw1">static</span> <span class="kw5">NSString</span> <span class="sy0">*</span>CellIdentifier <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Cell&quot;</span>;
&nbsp;
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span>CellIdentifier<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>cell <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UITableViewCell</span> alloc<span class="br0">&#93;</span> initWithStyle<span class="sy0">:</span>UITableViewCellStyleSubtitle reuseIdentifier<span class="sy0">:</span>CellIdentifier<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
&nbsp;
    cell.textLabel.text <span class="sy0">=</span> checklist.name;
    cell.accessoryType <span class="sy0">=</span> UITableViewCellAccessoryDetailDisclosureButton;
    cell.detailTextLabel.text <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;%d Remaining&quot;</span>, <span class="br0">&#91;</span>checklist countUncheckedItems<span class="br0">&#93;</span><span class="br0">&#93;</span>;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p>Most of the code stays the same, except we now use <code class="objc">UITableViewCellStyleSubtitle</code> instead of <code class="objc">UITableViewCellStyleDefault</code>. The “subtitle” cell style adds a smaller, gray label below the main label. You can use the <code class="objc">detailTextLabel</code> property to access this subtitle label.</p>

<p>We call the <code class="objc">countUncheckedItems</code> method on the <code class="objc">Checklist</code> object and put the count into a new string that we place into the <code class="objc">detailTextLabel</code>.</p>

<p><strong>&raquo;</strong> Run the app. For each checklist it will now show how many items still remain to be done.</p>

<p>One problem: The to-do count never changes. If you toggle a checkmark on or off, or add new items, the “to do” count remains the same. That’s because we create these table view cells once and never update their labels.</p>

<p><strong>Exercise:</strong> Think of all the situations that will cause this “still to do” count to change. <strong>◼</strong></p>

<p>Answer:</p>

<ul>
<li>The user toggles a checkmark on an item. When the checkmark is set, the count goes down. When the checkmark is removed, the count goes up again.</li>
<li>The user adds a new item. New items don’t have their checkmark set, so adding a new item should increment the count.</li>
<li>The user deletes an item. The count should go down but only if that item had no checkmark.</li>
</ul>

<p>These changes all happen in the <code class="objc">ChecklistViewController</code> but the “still to do” label is shown in the <code class="objc">AllListsViewController</code>. So how do we let the <code class="objc">AllListsViewController</code> know about this?</p>

<p>If you thought, use a delegate, then you’re starting to get the hang of this. We could make a new <code class="objc">ChecklistViewControllerDelegate</code> protocol that sends messages when the following things happen:</p>

<ul>
<li>the user toggles a checkmark on an item</li>
<li>the user adds a new item</li>
<li>the user deletes an item</li>
</ul>

<p>But what would the delegate &mdash; which would be <code class="objc">AllListsViewController</code> &mdash; do in return? It would simply set a new text on the cell’s <code class="objc">detailTextLabel</code> in all cases.</p>

<p>This approach sounds good, only we’re going to cheat and not use a delegate at all.</p>

<p><strong>&raquo;</strong> Go to AllListsViewController.m and update (or add) the <code class="objc">viewWillAppear</code> method to do the following:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewWillAppear<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>animated
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewWillAppear<span class="sy0">:</span>animated<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span>.tableView reloadData<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Don’t confuse this method with <code class="objc">viewDidAppear</code>. The difference is in the verb: <em>will</em> versus <em>did</em>. <code class="objc">viewWillAppear</code> is called before <code class="objc">viewDidAppear</code>.</p>

<p>The iOS API often does this: there is a “will” method that is invoked before something happens and a “did” method that is invoked after that something happened. Sometimes you need to do things before, sometimes after, and having two methods gives you the ability to choose whichever situation works best for you.</p>

<aside>

<p>API (ay-pee-eye) stands for Application Programming Interface. When people say “the iOS API” they mean all the frameworks, objects, protocols and functions  that are provided by iOS that you as a programmer can use to write apps. The iOS API consists of everything from UIKit, Foundation, Core Graphics, and so on. When people talk about “the Facebook API” or “the Google API”, then they mean the services that these companies provide that allow you to write apps for those platforms.</p>

</aside>

<p>In our case, we will simply tell the table view to reload its entire contents. That will cause <code class="objc">cellForRowAtIndexPath</code> to be called again for every visible row.</p>

<p>When you tap the back button on the <code class="objc">ChecklistViewController</code>’s navigation bar, the <code class="objc">AllListsViewController</code> screen will slide back into view. Just before that happens, <code class="objc">viewWillAppear</code> is called and thanks to the call to <code class="objc">reloadData</code> we will update all of the table cells, including the <code class="objc">detailTextLabels</code>.</p>

<p>Reloading all of the cells may be a little overkill but in this situation we can get away with it. It’s unlikely the All Lists screen will contain many rows so reloading them is quite fast. And it saves us some work of having to make yet another delegate. Sometimes a delegate is the best solution, sometimes you can simply reload the entire table.</p>

<p><strong>&raquo;</strong> Run the app and test that it works!</p>

<p><strong>Exercise:</strong> Change the label to read “All Done!” when there are no more to-do items left to check. <strong>◼</strong></p>

<p>Answer: Change the relevant code in <code class="objc">cellForRowAtIndexPath</code> to:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc">    <span class="kw4">int</span> count <span class="sy0">=</span> <span class="br0">&#91;</span>checklist countUncheckedItems<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>count <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell.detailTextLabel.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;All Done!&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        cell.detailTextLabel.text <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;%d Remaining&quot;</span>, count<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span></pre></figure>

<p><strong>Exercise:</strong> Now update the label to say “No Items” when the list is empty. <strong>◼</strong></p>

<p>Answer:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc">    <span class="kw4">int</span> count <span class="sy0">=</span> <span class="br0">&#91;</span>checklist countUncheckedItems<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>checklist.items count<span class="br0">&#93;</span> <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell.detailTextLabel.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;(No Items)&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>count <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        cell.detailTextLabel.text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;All Done!&quot;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        cell.detailTextLabel.text <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;%d Remaining&quot;</span>, count<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span></pre></figure>

<h3>Sorting the lists</h3>

<p>Another thing you often need to do with lists is sort them in some particular order. Let’s sort the list of checklists by name. Currently when you add a new checklist it is always appended to the end of the list.</p>

<p>Before we figure out how to sort an array, let’s think about when we need to perform this sort:</p>

<ul>
<li>When a new checklist is added</li>
<li>When a checklist is renamed</li>
</ul>

<p>There is no need to re-sort when a checklist is deleted because that doesn’t have any impact on the order of the other objects.</p>

<p>Currently we handle these two situations in <code class="objc">AllListsViewController</code>’s implementation of
<code class="objc">didFinishAddingChecklist</code> and <code class="objc">didFinishEditingChecklist</code>.</p>

<p><strong>&raquo;</strong> Change these methods to the following:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishAddingChecklist<span class="sy0">:</span><span class="br0">&#40;</span>Checklist <span class="sy0">*</span><span class="br0">&#41;</span>checklist
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel.lists addObject<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel sortChecklists<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.tableView reloadData<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>listDetailViewController<span class="sy0">:</span><span class="br0">&#40;</span>ListDetailViewController <span class="sy0">*</span><span class="br0">&#41;</span>controller didFinishEditingChecklist<span class="sy0">:</span><span class="br0">&#40;</span>Checklist <span class="sy0">*</span><span class="br0">&#41;</span>checklist
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel sortChecklists<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.tableView reloadData<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We were able to remove a whole bunch of stuff from both methods because we now always do <code class="objc">reloadData</code> on the table view. It is no longer necessary to insert the new row manually, or to update the cell’s <code class="objc">textLabel</code>. Instead we simply call <code class="objc">reloadData</code> to refresh the entire table’s contents.</p>

<p>Again, we can get away with this because the table will only hold a handful of rows. If this table held hundreds of rows, a more advanced approach might be necessary. (You could figure out where the new or renamed <code class="objc">Checklist</code> object should be inserted and just update that row.)</p>

<p>The <code class="objc">sortChecklists</code> method on <code class="objc">DataModel</code> is new.</p>

<p><strong>&raquo;</strong> Add its signature to DataModel.h:</p>

<figure class="code"><figcaption>DataModel.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>sortChecklists;</pre></figure>

<p><strong>&raquo;</strong> And the full implementation in DataModel.m:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>sortChecklists
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.lists sortUsingSelector<span class="sy0">:</span><span class="kw1">@selector</span><span class="br0">&#40;</span>compare<span class="sy0">:</span><span class="br0">&#41;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><code class="objc"><span class="kw5">NSMutableArray</span></code> has a <code class="objc">sortUsingSelector</code> method that is really easy to use. A <em>selector</em> is the name of a method. Here we tell the <code class="objc">lists</code> array that it should be sorted using the <code class="objc">compare<span class="sy0">:</span></code> method. This method is not defined on the array itself but on the objects it contains, the <code class="objc">Checklist</code>s.</p>

<p>The sort algorithm will call <code class="objc"><span class="br0">&#91;</span>Checklist compare<span class="br0">&#93;</span></code> to see how the <code class="objc">Checklist</code> objects relate to one another. Because the sorting algorithm doesn’t really know anything about our <code class="objc">Checklist</code> objects &mdash; or what it means for one <code class="objc">Checklist</code> to come before another &mdash; we have to help it out by providing this method.</p>

<p><strong>&raquo;</strong> Add the <code class="objc">compare</code> method to Checklist.m:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSComparisonResult</span><span class="br0">&#41;</span>compare<span class="sy0">:</span><span class="br0">&#40;</span>Checklist <span class="sy0">*</span><span class="br0">&#41;</span>otherChecklist
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span><span class="kw1">self</span>.name localizedStandardCompare<span class="sy0">:</span>otherChecklist.name<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>That’s all we need to do. We’re only looking at the name of this <code class="objc">Checklist</code> object versus the name of the <code class="objc">otherChecklist</code> object. The <code class="objc">name</code> property is an <code class="objc"><span class="kw5">NSString</span></code>, which already has a very convenient comparison method, <code class="objc">localizedStandardCompare</code>.</p>

<p>This method will compare the two <code class="objc">name</code> objects while ignoring lowercase vs uppercase (so “a” and “A” are considered equal) and taking into consideration the rules of the current locale. A <em>locale</em> is an object that knows about country and language-specific rules. Sorting in German may be different than sorting in English, for example.</p>

<p>So <code class="objc"><span class="kw5">NSMutableArray</span></code>’s <code class="objc">sortWithSelector</code> method will repeatedly ask one <code class="objc">Checklist</code> object how it compares to another <code class="objc">Checklist</code> object and then shuffle them around until the array is sorted. Inside that <code class="objc">Checklist</code> object’s <code class="objc">compare</code> method, we simply compare the names of the two objects. If you wanted to sort on other criteria all you have to do is change the compare method.</p>

<aside>
<h3>Dynamic method name resolution (using selectors)</h3>

<p>If you’re wondering why we didn’t add the signature for the <code class="objc">compare<span class="sy0">:</span></code> method to Checklist.h, then here’s a little secret: you could do this but it’s not necessary.</p>

<p>If we were calling <code class="objc"><span class="br0">&#91;</span>checklist compare<span class="br0">&#93;</span></code> directly in our code then we would indeed need to declare this method in the Checklist.h file. But here we’re using a selector, which will resolve the method name at <em>runtime</em> (i.e. when the app is running in the Simulator or on the device) rather than at compile-time.</p>

<p>For this type of dynamic method name resolution you don’t need to add methods to the .h file, as the .h file isn’t used for this. It’s also a little more dangerous: you can call a selector on an object that doesn’t exist. We’ve already seen that this makes the app crash with an “unrecognized selector sent to instance xxx” error message.</p>

</aside>

<p><strong>&raquo;</strong> Run the app and add some new checklists. Change their names and notice that the list is always sorted alphabetically.</p>

<figure class="image"><figcaption>New checklists are always sorted alphabetically</figcaption><img src="HTML/Figures/Sorted_checklists.png" alt="New checklists are always sorted alphabetically"/></figure>

<h3>Adding icons to the checklists</h3>

<p>Because I can’t get enough of view controllers and delegates, let’s add a new setting to the <code class="objc">Checklist</code> object that lets you choose an icon. I really want to cement these principles in your mind.</p>

<p>When we’re done, the Add/Edit Checklist screen will look like this:</p>

<figure class="image"><figcaption>You can assign an icon to a checklist</figcaption><img src="HTML/Figures/Edit_Checklist_screen_with_icon.png" alt="You can assign an icon to a checklist"/></figure>

<p>We will add a row to the Add/Edit Checklist screen that opens a new screen that lets you pick an icon. This icon picker is a new view controller. We won’t show it modally this time but push it on the navigation stack so it slides into the screen.</p>

<p>The Resources folder for this tutorial contains a folder named “Checklist Icons” with a selection of PNG images that depict different categories.</p>

<figure class="image"><figcaption>The various checklist icon images</figcaption><img src="HTML/Figures/Checklist_icons_folder.png" alt="The various checklist icon images"/></figure>

<p><strong>&raquo;</strong> Add this entire folder to the project. You can either right-click the project name in the Project Navigator and choose “Add Files to Checklists” or simply drag the entire folder from Finder into the Project Navigator.</p>

<p>Make sure the “Copy items into destination group's folder (if needed)” option is checked.</p>

<figure class="image"><figcaption>Copy the icon files into the project</figcaption><img src="HTML/Figures/Options_for_adding_files.png" alt="Copy the icon files into the project"/></figure>

<p><strong>&raquo;</strong> Add the following property to Checklist.h:</p>

<figure class="code"><figcaption>Checklist.h</figcaption><pre class="objc"><span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">copy</span><span class="br0">&#41;</span> <span class="kw5">NSString</span> <span class="sy0">*</span>iconName;</pre></figure>

<p><strong>&raquo;</strong> Inside Checklist.m, add a line to synthesize the property:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> iconName;</pre></figure>

<p><strong>&raquo;</strong> Extend <code class="objc">initWithCoder</code> and <code class="objc">encodeWithCoder</code> to respectively load and save this icon name in the Checklists.plist file:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.name <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Name&quot;</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.items <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Items&quot;</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.iconName <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;IconName&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>encodeWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aCoder
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span>aCoder encodeObject<span class="sy0">:</span><span class="kw1">self</span>.name forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Name&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>aCoder encodeObject<span class="sy0">:</span><span class="kw1">self</span>.items forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Items&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>aCoder encodeObject<span class="sy0">:</span><span class="kw1">self</span>.iconName forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;IconName&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Just for testing, update the <code class="objc">init</code> method to the following:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>init
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.items <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.iconName <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Appointments&quot;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This will give all checklists the “Appointments” icon. At this point we just want to see that we can make an icon &mdash; any icon &mdash; show up in the table view. When that works we can worry about letting the user pick the icon.</p>

<p><strong>&raquo;</strong> Change <code class="objc">cellForRowAtIndexPath</code> in AllListsViewController.m to put the icon into the table view cell:</p>

<figure class="code"><figcaption>AllListsViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    . . .
&nbsp;
    cell.imageView.image <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw7">UIImage</span> imageNamed<span class="sy0">:</span>checklist.iconName<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p>The standard cell type we’re using (<code class="objc">UITableViewCellStyleSubtitle</code>) comes with a built-in <code class="objc"><span class="kw7">UIImageView</span></code> on the left. We can simply put our image into it. Easy peasy.</p>

<p><strong>&raquo;</strong> Before running the app, remove the Checklists.plist file or uninstall the app from the Simulator because we’ve modified the file format again. We don’t want weird crashes...</p>

<p><strong>&raquo;</strong> Run the app and now each checklist should have a watch icon in front of its name. This will also look good in Retina mode because we supplied a @2x image as well.</p>

<figure class="image"><figcaption>The checklist now has an icon</figcaption><img src="HTML/Figures/Appointments_icon.png" alt="The checklist now has an icon"/></figure>

<p>Satisfied that this works, we can now change <code class="objc">Checklist</code>’s <code class="objc">init</code> to give each <code class="objc">Checklist</code> object an icon named “No Icon” by default.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">init</code> method to:</p>

<figure class="code"><figcaption>Checklist.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>init
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.items <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSMutableArray</span> alloc<span class="br0">&#93;</span> initWithCapacity<span class="sy0">:</span><span class="nu0">20</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.iconName <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;No Icon&quot;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The “No Icon” image is a fully transparent PNG image with the same dimensions as the other icons. Using a transparent image is necessary to make all the checklists line up properly, even if they have no icon.</p>

<p>If we were to set <code class="objc"><span class="kw1">self</span>.iconName</code> to <code class="objc"><span class="kw2">nil</span></code> instead, then the image view in the table view cell would remain empty and the text would align with the left margin of the screen. But that looks bad when other cells do have icons:</p>

<figure class="image"><figcaption>We use an empty image to properly align the text labels (right)</figcaption><img src="HTML/Figures/Using_No_Icon_to_align_labels.png" alt="We use an empty image to properly align the text labels (right)"/></figure>

<p>Let’s add the icon picker screen. Add a new file for a <code class="objc"><span class="kw7">UITableViewController</span></code> subclass to the project. Name it “IconPickerViewController”.</p>

<p><strong>&raquo;</strong> Change IconPickerViewController.h to:</p>

<figure class="code"><figcaption>IconPickerViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
&nbsp;
<span class="kw1">@class</span> IconPickerViewController;
&nbsp;
<span class="kw1">@protocol</span> IconPickerViewControllerDelegate &lt;NSObject&gt;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>iconPicker<span class="sy0">:</span><span class="br0">&#40;</span>IconPickerViewController <span class="sy0">*</span><span class="br0">&#41;</span>picker didPickIcon<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>iconName;
<span class="kw1">@end</span>
&nbsp;
<span class="kw1">@interface</span> IconPickerViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span>
&nbsp;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">weak</span><span class="br0">&#41;</span> <span class="kw4">id</span> &lt;IconPickerViewControllerDelegate&gt; delegate;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p><strong>&raquo;</strong> In IconPickerViewController.m, change the top of the file to:</p>

<figure class="code"><figcaption>IconPickerViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> IconPickerViewController <span class="br0">&#123;</span>
    <span class="kw5">NSArray</span> <span class="sy0">*</span>icons;
<span class="br0">&#125;</span>
&nbsp;
<span class="kw1">@synthesize</span> delegate;</pre></figure>

<p><strong>&raquo;</strong> Also change <code class="objc">viewDidLoad</code>:</p>

<figure class="code"><figcaption>IconPickerViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    icons <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObjects<span class="sy0">:</span>
        <span class="co3">@</span><span class="st0">&quot;No Icon&quot;</span>,
        <span class="co3">@</span><span class="st0">&quot;Appointments&quot;</span>,
        <span class="co3">@</span><span class="st0">&quot;Birthdays&quot;</span>,
        <span class="co3">@</span><span class="st0">&quot;Chores&quot;</span>,
        <span class="co3">@</span><span class="st0">&quot;Drinks&quot;</span>,
        <span class="co3">@</span><span class="st0">&quot;Folder&quot;</span>,
        <span class="co3">@</span><span class="st0">&quot;Groceries&quot;</span>,
        <span class="co3">@</span><span class="st0">&quot;Inbox&quot;</span>,
        <span class="co3">@</span><span class="st0">&quot;Photos&quot;</span>,
        <span class="co3">@</span><span class="st0">&quot;Trips&quot;</span>,
        <span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The instance variable <code class="objc">icons</code> is an <code class="objc"><span class="kw5">NSArray</span></code> that contains a list of icon names. These strings are both the text we will show on the screen and the name of the PNG file. The <code class="objc">icons</code> array is the data model for this table view. Note that it is a non-mutable <code class="objc"><span class="kw5">NSArray</span></code> (instead of an <code class="objc"><span class="kw5">NSMutableArray</span></code>) because the user cannot add or delete icons.</p>

<aside>
<h3>Convenience constructors</h3>

<p>Earlier you’ve seen that new objects are created using a combination of <code class="objc">alloc</code> and <code class="objc">init</code>:</p>

<pre class="objc no-border">Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;</pre>

<p>But here we’re creating a new array using a different method:</p>

<pre class="objc no-border"><span class="kw5">NSArray</span> <span class="sy0">*</span>array <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSArray</span> arrayWithObjects<span class="sy0">:</span>object1, object2, <span class="kw2">nil</span><span class="br0">&#93;</span>;</pre>

<p>No <code class="objc">alloc</code> or <code class="objc">init</code> in sight. What gives? This form is called a <em>convenience constructor</em>. You can actually also write it as:</p>

<pre class="objc no-border"><span class="kw5">NSArray</span> <span class="sy0">*</span>array <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSArray</span> alloc<span class="br0">&#93;</span> initWithObjects<span class="sy0">:</span>object1, object2, <span class="kw2">nil</span><span class="br0">&#93;</span>;</pre>

<p>For most intents and purposes these two forms are equivalent. They both allocate and initialize a new <code class="objc"><span class="kw5">NSArray</span></code> object.</p>

<p>Another example that we’ve been using quite a bit:</p>

<pre class="objc no-border"><span class="kw5">NSString</span> <span class="sy0">*</span>string <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;I ate %d ice cream today&quot;</span>, <span class="nu0">3</span><span class="br0">&#93;</span>;</pre>

<p>This can also be written as:</p>

<pre class="objc no-border"><span class="kw5">NSString</span> <span class="sy0">*</span>string <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSString</span> alloc<span class="br0">&#93;</span> initWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;I ate %d ice cream today&quot;</span>, <span class="nu0">3</span><span class="br0">&#93;</span>;</pre>

<p>So why are there two approaches to the same thing? For convenience, mostly. Using <code class="objc">arrayWithObjects</code> and <code class="objc">stringWithFormat</code> saves you from typing <code class="objc">alloc</code>. There is also a historical reason that has to do with memory management, but that went out the door with the arrival of iOS 5.</p>

</aside>

<p>Because this new view controller is a <code class="objc"><span class="kw7">UITableViewController</span></code>, we have to implement the data source methods for the table view.</p>

<p><strong>&raquo;</strong> Remove the existing data source stuff from the source file and replace it with:</p>

<figure class="code"><figcaption>IconPickerViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#91;</span>icons count<span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>tableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;IconCell&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw5">NSString</span> <span class="sy0">*</span>icon <span class="sy0">=</span> <span class="br0">&#91;</span>icons objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
    cell.textLabel.text <span class="sy0">=</span> icon;
    cell.imageView.image <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw7">UIImage</span> imageNamed<span class="sy0">:</span>icon<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span></pre></figure>

<p>Here we get a table view cell and give it text and an image. We will design this cell in the Storyboard editor momentarily. It will be a prototype cell with the cell style “Default” (or “Basic” as it is called in the Storyboard editor). Cells with this style already contain a text label and an image view, which is very convenient.</p>

<p><strong>&raquo;</strong> Go to the Storyboard editor. Drag a new Table View Controller from the Object Library next to the List Detail View Controller.</p>

<p><strong>&raquo;</strong> In the Identity Inspector, change the class of this new table view controller to “IconPickerViewController”.</p>

<p><strong>&raquo;</strong> Select the prototype cell and set its style to Basic and its (re-use) Identifier to “IconCell”.</p>

<p>That takes care of the design for the icon picker, but we also have to add a new row to the Add/Edit Checklist screen.</p>

<p><strong>&raquo;</strong> Select the List Detail View Controller and add a static cell. You can do that by dragging a Table View Cell from the Object Library into the table.</p>

<p><strong>&raquo;</strong> Add a label to this cell and name it “Icon”. System Bold font, size 18. Set the label’s Highlighted color to white.</p>

<p><strong>&raquo;</strong> Set the cell’s Accessory to Disclosure Indicator.</p>

<p><strong>&raquo;</strong> Add an Image View to the right of the cell. Make it 36x36 points big. Use the Assistant Editor to add a property for this image view to the <code class="objc">ListDetailViewController</code> and name it <code class="objc">iconImageView</code>.</p>

<p>Now that we’ve finished the designs for both screens, we can connect them with a segue.</p>

<p><strong>&raquo;</strong> Ctrl-drag from the “Icon” table view cell to the Icon Picker View Controller and add a segue. Keep the segue’s style Push but give it an Identifier: “PickIcon”.</p>

<p><strong>&raquo;</strong> Thanks to the segue, the new view controller has been given a navigation bar. Double-click that navigation bar and change its title to “Choose Icon”.</p>

<p>This part of the Storyboard should now look like this:</p>

<figure class="image"><figcaption>The Icon Picker view controller in the Storyboard</figcaption><a href="HTML/Figures/The_Icon_Picker_view_controller.png" target="_blank"><img src="HTML/Figures/Thumbnail-The_Icon_Picker_view_controller.png" alt="The Icon Picker view controller in the Storyboard"/></a><br><span class="enlarge-image"><a href="HTML/Figures/The_Icon_Picker_view_controller.png" target="_blank">(Click to enlarge)</a></span></figure>

<p><strong>&raquo;</strong> In ListDetailViewController.m, change <code class="objc">willSelectRowAtIndexPath</code> to:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView willSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> indexPath;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="kw2">nil</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>This is necessary otherwise we cannot tap the row to trigger the segue. Previously this method always returned <code class="objc"><span class="kw2">nil</span></code>, which meant tapping on rows was not possible. Now, however, we want to allow the user to tap on the “Icon” row so we should return the index-path for that row. Users still can’t select the first row.</p>

<p><strong>&raquo;</strong> Run the app and verify that there is now an Icon row in the Add/Edit Checklist screen and that tapping it will open the Choose Icon screen. The icon picker should show a list of icons. You can press the back button to go back.</p>

<figure class="image"><figcaption>The icon picker screen</figcaption><img src="HTML/Figures/Icon_picker.png" alt="The icon picker screen"/></figure>

<p>We have to hook up the icon picker to the Add/Edit Checklist screen through its own delegate protocol.</p>

<p><strong>&raquo;</strong> Add the following to ListDetailViewController.h:</p>

<figure class="code"><figcaption>ListDetailViewController.h</figcaption><pre class="objc"><span class="co1">#import &quot;IconPickerViewController.h&quot;</span>
&nbsp;
. . .
&nbsp;
<span class="kw1">@interface</span> ListDetailViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;<span class="kw8">UITextFieldDelegate</span>, IconPickerViewControllerDelegate&gt;</pre></figure>

<p><strong>&raquo;</strong> Add an instance variable in ListDetailViewController.m:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> ListDetailViewController <span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>iconName;
<span class="br0">&#125;</span></pre></figure>

<p>We add an ivar to keep track of the chosen icon name. Even though the <code class="objc">Checklist</code> object now has an <code class="objc">iconName</code> property, we cannot keep track of the chosen icon in the <code class="objc">Checklist</code> object for the simple reason that we may not always have a <code class="objc">Checklist</code> object, i.e. when we’re adding a new checklist. So we’ll store the icon name in a temporary variable and copy that into the <code class="objc">Checklist</code>’s <code class="objc">iconName</code> property at the right time.</p>

<p>We should initialize the <code class="objc">iconName</code> variable with something reasonable. Let’s go with the folder icon. To do this, we need to add the <code class="objc">initWithCoder</code> method as this is the method that is used to initialize this view controller (since it’s being loaded from a Storyboard).</p>

<p><strong>&raquo;</strong> Add a new <code class="objc">initWithCoder</code> method to ListDetailViewController.m:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> initWithCoder<span class="sy0">:</span>aDecoder<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        iconName <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Folder&quot;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This sets the <code class="objc">iconName</code> variable to <code class="objc"><span class="co3">@</span><span class="st0">&quot;Folder&quot;</span></code>. This is only necessary for new <code class="objc">Checklist</code>s, which we’ll give the Folder icon by default.</p>

<p><strong>&raquo;</strong> You can get rid of the <code class="objc">initWithStyle</code> method as it’s not being used for anything.</p>

<p><strong>&raquo;</strong> Update <code class="objc">viewDidLoad</code> to the following:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.checklistToEdit <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.title <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Edit Checklist&quot;</span>;
        <span class="kw1">self</span>.textField.text <span class="sy0">=</span> <span class="kw1">self</span>.checklistToEdit.name;
        <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="kw2">YES</span>;
        iconName <span class="sy0">=</span> <span class="kw1">self</span>.checklistToEdit.iconName;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">self</span>.iconImageView.image <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw7">UIImage</span> imageNamed<span class="sy0">:</span>iconName<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This has two new lines: If the <code class="objc">checklistToEdit</code> property is not <code class="objc"><span class="kw2">nil</span></code>, then we copy the <code class="objc">Checklist</code> object’s icon name into our own <code class="objc">iconName</code> ivar. We also set the icon on the <code class="objc">iconImageView</code> so it shows up in the Icon row.</p>

<p>We hooked up the Add/Edit Checklist screen to the <code class="objc">IconPickerViewController</code> with a push segue named “PickIcon”. We need to implement <code class="objc">prepareForSegue</code> in order to tell the <code class="objc">IconPickerViewController</code> that this screen is now its delegate.</p>

<p><strong>&raquo;</strong> Add the following method to the bottom of ListDetailViewController.m:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>prepareForSegue<span class="sy0">:</span><span class="br0">&#40;</span>UIStoryboardSegue <span class="sy0">*</span><span class="br0">&#41;</span>segue sender<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>sender
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>segue.identifier isEqualToString<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;PickIcon&quot;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        IconPickerViewController <span class="sy0">*</span>controller <span class="sy0">=</span> segue.destinationViewController;
        controller.delegate <span class="sy0">=</span> <span class="kw1">self</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>Finally, we implement the delegate callback method to remember the name of the chosen icon. We don’t call <code class="objc">dismissViewController</code> here but <code class="objc">popViewControllerAnimated</code> because the Icon Picker is on the navigation stack, it was not presented modally (we used segue style “Push” instead of “Modal”).</p>

<p><strong>&raquo;</strong> Add to the bottom of ListDetailViewController.m:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>iconPicker<span class="sy0">:</span><span class="br0">&#40;</span>IconPickerViewController <span class="sy0">*</span><span class="br0">&#41;</span>picker didPickIcon<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>theIconName
<span class="br0">&#123;</span>
    iconName <span class="sy0">=</span> theIconName;
    <span class="kw1">self</span>.iconImageView.image <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw7">UIImage</span> imageNamed<span class="sy0">:</span>iconName<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.navigationController popViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This puts the name of the chosen icon into the <code class="objc">iconName</code> ivar and also updates the image view.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">done</code> action to:</p>

<figure class="code"><figcaption>ListDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.checklistToEdit <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        Checklist <span class="sy0">*</span>checklist <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>Checklist alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        checklist.name <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
        checklist.iconName <span class="sy0">=</span> iconName;
&nbsp;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate listDetailViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishAddingChecklist<span class="sy0">:</span>checklist<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.checklistToEdit.name <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
        <span class="kw1">self</span>.checklistToEdit.iconName <span class="sy0">=</span> iconName;
&nbsp;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate listDetailViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishEditingChecklist<span class="sy0">:</span><span class="kw1">self</span>.checklistToEdit<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>Here we put the chosen icon name into the <code class="objc">Checklist</code> object when the user closes the screen.</p>

<p>Finally, we must change <code class="objc">IconPickerViewController</code> to actually call the delegate method when a row is tapped.</p>

<p><strong>&raquo;</strong> Add the following method to the bottom of IconPickerViewController.m:</p>

<figure class="code"><figcaption>IconPickerViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView didSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>iconName <span class="sy0">=</span> <span class="br0">&#91;</span>icons objectAtIndex<span class="sy0">:</span>indexPath.row<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span>.delegate iconPicker<span class="sy0">:</span><span class="kw1">self</span> didPickIcon<span class="sy0">:</span>iconName<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>And that’s it. You can now set icons on the <code class="objc">Checklist</code> objects.</p>

<p>We added a new view controller object, designed its user interface in the Storyboard editor, and hooked it up to the Add/Edit Checklist screen using a segue and a delegate. Those are the basic steps you need to take with any new screen that you add.</p>

<h3>Making the app look good</h3>

<p>We’re going to keep it simple in this tutorial as far as fancying up the graphics goes. The standard look of navigation controllers and table views is perfectly adequate, although a little bland. In the next tutorials you’ll see how you can customize the look of these items, especially now that iOS 5 makes this really easy.</p>

<p>For the Checklists app, we’ll just add our own icon and a launch image.</p>

<p>The Resources folder for this tutorial contains a folder named “Icon” with the app icon image in various sizes.</p>

<p><strong>&raquo;</strong> Add this entire folder to the project.</p>

<p><strong>&raquo;</strong> In the Project Navigator, locate Checklists-Info.plist and click to open it. Add a new row for “Icon files” and fill in this section as follows:</p>

<figure class="image"><figcaption>Add entries for the icon to Info.plist</figcaption><img src="HTML/Figures/Info_plist_icon_files.png" alt="Add entries for the icon to Info.plist"/></figure>

<p>Also add a row for the setting “Icon already includes gloss effects” and set its value to <code class="objc"><span class="kw2">YES</span></code>. Without this setting, iOS will add a highlight to the icon. That looks good for some icons, but I prefer the icon for this app to have no such gloss.</p>

<figure class="image"><figcaption>The icon without gloss (left) and with (right)</figcaption><img src="HTML/Figures/Icon_with_and_without_gloss.png" alt="The icon without gloss (left) and with (right)"/></figure>

<p>Besides an icon, apps should also have a launch image. You can find the launch image for this app, in both low-resolution and Retina versions, inside the “Launch Images” folder of this tutorial’s Resources. Add that folder to the project.</p>

<p>The launch image simply has a navigation bar without a title but with the Add button, and an empty table view. This will give the illusion the app’s UI has already been loaded but that the data hasn’t been filled in yet.</p>

<figure class="image"><figcaption>The launch image for this app</figcaption><img src="HTML/Figures/Launch_image.png" alt="The launch image for this app"/></figure>

<p>To make this launch image, I ran the app in the Simulator, then chose File → Save Screen Shot. This puts a new PNG file on your Desktop. Then I opened this image in Photoshop and simply trimmed out the stuff we don’t need.</p>

<p>I also blanked out the status bar portion of the image. The iPhone will draw its own status bar on top anyway. You can also cut the status bar off but then Xcode will complain the image is not the recommended size, though in practice that appears to work just as well.</p>

<p>The app also needs a Retina launch image that is twice the size of the regular one, so I repeated this process with the Simulator in Retina mode. (Remember to stop the app in Xcode before you switch the Simulator to Retina mode, or the app will crash hard.)</p>

<p>When you now run the app, instead of a black screen it immediately shows an empty table view with a navigation bar on top. It makes the app look more professional &mdash; and faster!</p>

<p>You can find the project files for the app up to this point under “10 - UI Improvements” in the tutorial’s Source Code folder.</p>

<hr>

<h2>Bonus Feature: Local Notifications</h2>

<p>I hope you’re still with me! We have discussed in great detail view controllers, navigation controllers, storyboards, segues, tables and cells, and the data model. These are all essential topics to master if you want to build iOS apps because almost every app uses these building blocks.</p>

<p>In this section we’re going to expand the app to add a new feature: local notifications. A <em>local notification</em> allows the app to schedule a reminder to the user that will be displayed even when the app is not running. We will add a “due date” field to our <code class="objc">ChecklistItem</code> object and then remind the user about this deadline with a local notification.</p>

<p>If this sounds like fun, then keep reading. :-)</p>

<p>The steps for this section are as follows:</p>

<ul>
<li>Try out a local notification just to see how it works</li>
<li>Allow the user to pick a due date for to-do items</li>
<li>Create a date picker control</li>
<li>Schedule local notifications for the to-do items, and update them when the user changes the due date</li>
</ul>

<p>Before we’ll wonder about how to integrate this in our app, let’s just schedule a local notification and see what happens.</p>

<p>By the way, local notifications are different from <em>push</em> notifications. Push allows your app to receive messages about external events, such as your favorite team winning the World Series. Local notifications are more similar to an alarm clock: you set a specific time and then it “beeps”. Getting push notifications to work is a bit out of the scope of a beginners tutorial, but you can <a href="http://www.raywenderlich.com/3443/apple-push-notification-services-tutorial-part-12">read more about them here</a> if you’re interested.</p>

<p><strong>&raquo;</strong> Open ChecklistsAppDelegate.m and add the following code to the method <code class="objc">didFinishLaunchingWithOptions</code>:</p>

<figure class="code"><figcaption>ChecklistsAppDelegate.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>application<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIApplication</span> <span class="sy0">*</span><span class="br0">&#41;</span>application didFinishLaunchingWithOptions<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSDictionary</span> <span class="sy0">*</span><span class="br0">&#41;</span>launchOptions
<span class="br0">&#123;</span>
    <span class="kw5">NSDate</span> <span class="sy0">*</span>date <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSDate</span> dateWithTimeIntervalSinceNow<span class="sy0">:</span><span class="nu0">10</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw7">UILocalNotification</span> <span class="sy0">*</span>localNotification <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UILocalNotification</span> alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    localNotification.fireDate <span class="sy0">=</span> date;
    localNotification.timeZone <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSTimeZone</span> defaultTimeZone<span class="br0">&#93;</span>;
    localNotification.alertBody <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;I am a local notification!&quot;</span>;
    localNotification.soundName <span class="sy0">=</span> UILocalNotificationDefaultSoundName;
&nbsp;
    <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UIApplication</span> sharedApplication<span class="br0">&#93;</span> scheduleLocalNotification<span class="sy0">:</span>localNotification<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">return</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span></pre></figure>

<p>The <code class="objc">didFinishLaunchingWithOptions</code> method is called when the app starts up. We create a new local notification here and tell it to fire 10 seconds after the app has started.</p>

<p>A local notification is scheduled in the future using an <code class="objc"><span class="kw5">NSDate</span></code> object, which specifies a certain date and time. We use the <code class="objc">dateWithTimeIntervalSinceNow</code> convenience constructor to create an <code class="objc"><span class="kw5">NSDate</span></code> object that points at a time 10 seconds into the future.</p>

<p>We create the <code class="objc"><span class="kw7">UILocalNotification</span></code> object and give it the <code class="objc"><span class="kw5">NSDate</span></code> object as its “fire date”. We also set a time zone, so the system automatically adjusts the fire date when the device travels across different time zones (for you frequent flyers).</p>

<p>Local notifications can appear in different ways. We set a text so that an alert message will be shown when the notification fires. We also set a default sound.</p>

<p>Finally, we tell the <code class="objc"><span class="kw7">UIApplication</span></code> object to schedule the notification.</p>

<aside>

<p>A word on <code class="objc"><span class="kw7">UIApplication</span></code>. We haven’t used this object before, but every app has one and it deals with application-wide functionality. You always have to provide a delegate object for <code class="objc"><span class="kw7">UIApplication</span></code> that will handle messages that concern the app as a whole, such as <code class="objc">applicationDidEnterBackground</code> that we’ve seen earlier. Our delegate for <code class="objc"><span class="kw7">UIApplication</span></code> is the <code class="objc">ChecklistsAppDelegate</code> object. The Xcode project templates always provide an app delegate object for you. You won’t directly use <code class="objc"><span class="kw7">UIApplication</span></code> a lot, except for special features such as local notifications.</p>

</aside>

<p><strong>&raquo;</strong> Add the following method to ChecklistsAppDelegate.m:</p>

<figure class="code"><figcaption>ChecklistsAppDelegate.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>application<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIApplication</span> <span class="sy0">*</span><span class="br0">&#41;</span>application didReceiveLocalNotification<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UILocalNotification</span> <span class="sy0">*</span><span class="br0">&#41;</span>notification
<span class="br0">&#123;</span>
    <span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="co3">@</span><span class="st0">&quot;didReceiveLocalNotification %@&quot;</span>, notification<span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This method will be invoked when the local notification is posted and the app is still running (or suspended). We won’t do anything here but for some apps it makes sense to react to it, for example to show whatever thing is the subject of the notification.</p>

<p><strong>&raquo;</strong> Run the app. Immediately after it has started, press the Home button on the Simulator (or your device if you’re running this on your iPhone). Wait 10 seconds.</p>

<p>After 10 seconds an alert view should pop up:</p>

<figure class="image"><figcaption>The local notification shows up in an alert</figcaption><img src="HTML/Figures/Local_notification_test.png" alt="The local notification shows up in an alert"/></figure>

<p>The iOS 6 Simulator and your device use Notification Center instead:</p>

<figure class="image"><figcaption>The local notification shows up in a Notification Bar</figcaption><img src="HTML/Figures/Local_notification_test_Notification_Center.png" alt="The local notification shows up in a Notification Bar"/></figure>

<p><strong>&raquo;</strong> Press View to go back to the app.</p>

<p>The Debug Area shows that <code class="objc">didReceiveLocalNotification</code> is called with the notification object. (If you had pressed Close instead, our app would remain in the background and <code class="objc">didReceiveLocalNotification</code> would not be called.)</p>

<p>The Debug Area should show something like this:</p>

<pre>
Checklists[8022:207] didReceiveLocalNotification &lt;UIConcreteLocalNotification:
0x6e17210&gt;{fire date = Saturday, July 16, 2011 12:32:38 AM Central European
Summer Time, time zone = Europe/Amsterdam (CEST) offset 7200 (Daylight),
repeat interval = 0, repeat count = UILocalNotificationInfiniteRepeatCount,
next fire date = (null)}
</pre>

<p>Why did I want you to press the Home button? iOS will only show an alert with the notification message if the app is not currently active.</p>

<p><strong>&raquo;</strong> Stop the app and run it again. Now don’t press Home and just wait.</p>

<p>After 10 seconds you should see the <code class="objc"><span class="kw3">NSLog</span></code> message for <code class="objc">didReceiveLocalNotification</code> in the Debug Area but no alert is shown. When your app is active, it is supposed to handle any fired notifications in its own manner.</p>

<p>By the way, if you’re running this on your device or on the iOS 6 Simulator, you can see the notifications in the Notification Center as well:</p>

<figure class="image"><figcaption>The notification in Notification Center</figcaption><img src="HTML/Figures/Notification_Center.png" alt="The notification in Notification Center"/></figure>

<p>All right, now we know that it works, we should restore <code class="objc">ChecklistsAppDelegate</code> to its former state because we don’t really want to schedule a new notification every time the user starts the app.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">didFinishLaunchingWithOptions</code> method back to the way it was:</p>

<figure class="code"><figcaption>ChecklistsAppDelegate.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>application<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UIApplication</span> <span class="sy0">*</span><span class="br0">&#41;</span>application didFinishLaunchingWithOptions<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSDictionary</span> <span class="sy0">*</span><span class="br0">&#41;</span>launchOptions
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span></pre></figure>

<p>You can keep the <code class="objc">didReceiveLocalNotification</code> method, as it will come in handy when debugging the local notifications.</p>

<h3>Extending the data model</h3>

<p>Let’s think about how our app will handle these notifications. Each <code class="objc">ChecklistItem</code> will get a due date field (an <code class="objc"><span class="kw5">NSDate</span></code> object) and a <code class="objc"><span class="kw4">BOOL</span></code> that says whether we want to be reminded of this item or not. You might not want to be reminded of everything, so we shouldn’t schedule local notifications for those items. Such a <code class="objc"><span class="kw4">BOOL</span></code> is often called a <em>flag</em>. Let’s name it <code class="objc">shouldRemind</code>.</p>

<p>We will add settings for these two new fields to the Add/Edit Item screen and make it look like this:</p>

<figure class="image"><figcaption>The Add/Edit Item screen now has Remind Me and Due Date fields</figcaption><img src="HTML/Figures/Remind_me_and_due_date_in_Add_Item_screen.png" alt="The Add/Edit Item screen now has Remind Me and Due Date fields"/></figure>

<p>The due date field will require some sort of date picker control. iOS comes with a cool date picker view but it cannot be used on its own. We’ll have to write a view controller for that, probably with its own delegate.</p>

<p>First, let’s figure out how and when to schedule the notifications. I can think of the following situations:</p>

<ul>
<li>When the user adds a new <code class="objc">ChecklistItem</code> object that has the <code class="objc">shouldRemind</code> flag set, we must schedule a new notification.</li>
<li>When the user changes the due date on an existing <code class="objc">ChecklistItem</code>, the old notification should be cancelled (if there is one) and a new one scheduled in its place (if <code class="objc">shouldRemind</code> is still set).</li>
<li>When the user toggles the <code class="objc">shouldRemind</code> flag from on to off, the existing notification should be cancelled. The other way around, from off to on, should schedule a new notification.</li>
<li>When the user deletes a <code class="objc">ChecklistItem</code>, its notification should be cancelled if it had one.</li>
<li>When the user deletes an entire <code class="objc">Checklist</code>, all the notifications for those items should be cancelled.</li>
</ul>

<p>So we don’t need just a way to schedule new notifications but also a way to cancel them. We should probably also check that we don’t schedule notifications for to-do items whose due dates are in the past. I’m sure the local notification system can handle that, but let’s be good citizens anyway.</p>

<p><code class="objc"><span class="kw7">UIApplication</span></code> has a method <code class="objc">cancelLocalNotification</code> that allows us to cancel a notification that was previously scheduled. That method takes a <code class="objc"><span class="kw7">UILocalNotification</span></code> object. Somehow we must associate the <code class="objc">ChecklistItem</code> object with a <code class="objc"><span class="kw7">UILocalNotification</span></code> in order to be able to cancel that notification.</p>

<p>It is tempting to put the <code class="objc"><span class="kw7">UILocalNotification</span></code> object in <code class="objc">ChecklistItem</code>, so we always know what it is, but imagine what happens when the app goes to the background. In that case we save the <code class="objc">ChecklistItem</code> object to the Checklists.plist file &mdash; but what about the <code class="objc"><span class="kw7">UILocalNotification</span></code> object? As it happens the <code class="objc"><span class="kw7">UILocalNotification</span></code> conforms to the <code class="objc"><span class="kw6">NSCoding</span></code> protocol so we could serialize it along with the <code class="objc">ChecklistItem</code> object into our file. However, that is asking for trouble.</p>

<p>These <code class="objc"><span class="kw7">UILocalNotification</span></code> objects are owned by the operating system, not by our app. When the app starts again, it is very well possible that iOS uses different objects to represent the same notifications. We cannot unfreeze these objects from our plist file and expect iOS to recognize them. So let’s not store the <code class="objc"><span class="kw7">UILocalNotification</span></code> objects directly.</p>

<p>What will work better is to give the <code class="objc"><span class="kw7">UILocalNotification</span></code> a reference to the associated <code class="objc">ChecklistItem</code>. Each local notification has an <code class="objc"><span class="kw5">NSDictionary</span></code> named <code class="objc">userInfo</code> that you can use to store your own values.</p>

<p>We will not use this dictionary to store the <code class="objc">ChecklistItem</code> object itself, for the same reason as above: when the app closes and later starts again, we will get new <code class="objc">ChecklistItem</code> objects. Even though they look and behave exactly the same as the old <code class="objc">ChecklistItem</code>s (because we froze and unfroze them), they are likely to be placed elsewhere in memory and the references inside the <code class="objc"><span class="kw7">UILocalNotification</span></code>s will be broken.</p>

<p>Instead of direct references, we will use a numeric identifier. We will give each <code class="objc">ChecklistItem</code> object a unique numeric ID. Assigning numeric IDs to objects is a common approach when creating data models &mdash; it is very similar to giving records in a relational database a numeric primary key, if you’re familiar with that sort of thing.</p>

<p>We’ll save this ID in the Checklists.plist file and also store it in the <code class="objc"><span class="kw7">UILocalNotification</span></code>’s <code class="objc">userInfo</code> dictionary. Then we can easily find the notification when we have the <code class="objc">ChecklistItem</code> object, or the <code class="objc">ChecklistItem</code> object when we have the notification. This will work even after the app has terminated and all the original objects have long been destroyed.</p>

<p><strong>&raquo;</strong> Make these changes to ChecklistItem.h:</p>

<figure class="code"><figcaption>ChecklistItem.h</figcaption><pre class="objc"><span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">copy</span><span class="br0">&#41;</span> <span class="kw5">NSDate</span> <span class="sy0">*</span>dueDate;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">assign</span><span class="br0">&#41;</span> <span class="kw4">BOOL</span> shouldRemind;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">assign</span><span class="br0">&#41;</span> <span class="kw4">int</span> itemId;</pre></figure>

<p><strong>&raquo;</strong> Properties must be synthesized, so add the following in ChecklistItem.m:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> dueDate, shouldRemind, itemId;</pre></figure>

<p>Note that I spelled it <code class="objc">itemId</code>, not <code class="objc">itemID</code>. That’s a stylistic thing; I just like it better that way. I also did not simply call it “id” because <code class="objc"><span class="kw4">id</span></code> is a special keyword in Objective-C (and it has nothing to do with identifiers; for example, we’ve already seen the <code class="objc"><span class="kw4">id</span></code> keyword when we created our own delegate protocols).</p>

<p>We have to extend <code class="objc">initWithCoder</code> and <code class="objc">encodeWithCoder</code> in order to be able to load and save these new properties along with the <code class="objc">ChecklistItem</code> objects.</p>

<p><strong>&raquo;</strong> Change these methods:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.text <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Text&quot;</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.checked <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeBoolForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checked&quot;</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.dueDate <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeObjectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;DueDate&quot;</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.shouldRemind <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeBoolForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ShouldRemind&quot;</span><span class="br0">&#93;</span>;
        <span class="kw1">self</span>.itemId <span class="sy0">=</span> <span class="br0">&#91;</span>aDecoder decodeIntForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ItemID&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>encodeWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aCoder
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span>aCoder encodeObject<span class="sy0">:</span><span class="kw1">self</span>.text forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Text&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>aCoder encodeBool<span class="sy0">:</span><span class="kw1">self</span>.checked forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;Checked&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>aCoder encodeObject<span class="sy0">:</span><span class="kw1">self</span>.dueDate forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;DueDate&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>aCoder encodeBool<span class="sy0">:</span><span class="kw1">self</span>.shouldRemind forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ShouldRemind&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>aCoder encodeInt<span class="sy0">:</span><span class="kw1">self</span>.itemId forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ItemID&quot;</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>That takes care of saving and loading existing objects, but we still have to assign an ID to new objects.</p>

<p><strong>&raquo;</strong> Replace <code class="objc">ChecklistItem</code>’s <code class="objc">init</code> method with the following (or add the method if it doesn’t exist yet):</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>init
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> init<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.itemId <span class="sy0">=</span> <span class="br0">&#91;</span>DataModel nextChecklistItemId<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p>Because we haven’t used the <code class="objc">DataModel</code> object before in this source file, we have to import it.</p>

<p><strong>&raquo;</strong> Add the import line at the top of the file:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="co1">#import &quot;DataModel.h&quot;</span></pre></figure>

<p>Now let’s add this new <code class="objc">nextChecklistItemId</code> method to <code class="objc">DataModel</code>. As you can guess from its name this method will return a new, unique ID every time you call it.</p>

<p><strong>&raquo;</strong>  Add the method signature to DataModel.h:</p>

<figure class="code"><figcaption>DataModel.h</figcaption><pre class="objc"><span class="sy0">+</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>nextChecklistItemId;</pre></figure>

<p><strong>&raquo;</strong> Add the implementation to DataModel.m:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">+</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>nextChecklistItemId
<span class="br0">&#123;</span>
    <span class="kw5">NSUserDefaults</span> <span class="sy0">*</span>userDefaults <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSUserDefaults</span> standardUserDefaults<span class="br0">&#93;</span>;
    <span class="kw4">int</span> itemId <span class="sy0">=</span> <span class="br0">&#91;</span>userDefaults integerForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItemId&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>userDefaults setInteger<span class="sy0">:</span>itemId <span class="sy0">+</span> <span class="nu0">1</span> forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ChecklistItemId&quot;</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>userDefaults synchronize<span class="br0">&#93;</span>;
    <span class="kw1">return</span> itemId;
<span class="br0">&#125;</span></pre></figure>

<p>We’re using our old friend <code class="objc"><span class="kw5">NSUserDefaults</span></code> again. This method gets the current “ChecklistItemId” value from <code class="objc"><span class="kw5">NSUserDefaults</span></code>, adds one to it, and writes it back to <code class="objc"><span class="kw5">NSUserDefaults</span></code>. It returns the old value to the caller.</p>

<p>The method also does <code class="objc"><span class="br0">&#91;</span>userDefaults synchronize<span class="br0">&#93;</span></code> to force the <code class="objc"><span class="kw5">NSUserDefaults</span></code> to write these changes to disk immediately, so they won’t get lost if we kill the app from Xcode before it had a chance to save. This is important because we don’t want two or more <code class="objc">ChecklistItem</code>s to get the same ID.</p>

<p><strong>&raquo;</strong> Add a default value for “ChecklistItemId” to the <code class="objc">registerDefaults</code> method:</p>

<figure class="code"><figcaption>DataModel.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>registerDefaults
<span class="br0">&#123;</span>
    <span class="kw5">NSDictionary</span> <span class="sy0">*</span>dictionary <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSDictionary</span> dictionaryWithObjectsAndKeys<span class="sy0">:</span>
        <span class="br0">&#91;</span><span class="kw5">NSNumber</span> numberWithInt<span class="sy0">:-</span><span class="nu0">1</span><span class="br0">&#93;</span>, <span class="co3">@</span><span class="st0">&quot;ChecklistIndex&quot;</span>,
        <span class="br0">&#91;</span><span class="kw5">NSNumber</span> numberWithBool<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>, <span class="co3">@</span><span class="st0">&quot;FirstTime&quot;</span>,
        <span class="br0">&#91;</span><span class="kw5">NSNumber</span> numberWithInt<span class="sy0">:</span><span class="nu0">0</span><span class="br0">&#93;</span>, <span class="co3">@</span><span class="st0">&quot;ChecklistItemId&quot;</span>,
        <span class="kw2">nil</span><span class="br0">&#93;</span>;
&nbsp;
    . . .
<span class="br0">&#125;</span></pre></figure>

<p>The first time <code class="objc">nextChecklistItemId</code> is called it will return the ID <code class="objc"><span class="nu0">0</span></code>. The second time it is called it will return the ID <code class="objc"><span class="nu0">1</span></code>, the third time it will return the ID <code class="objc"><span class="nu0">2</span></code>, and so on. The number is incremented by one each time. You can call this method a few billion times before we run out of unique IDs.</p>

<aside>
<h3>Class methods vs instance methods</h3>

<p>If you are wondering why we wrote:</p>

<pre class="objc no-border"><span class="sy0">+</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>nextChecklistItemId</pre>

<p>and not:</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>nextChecklistItemId</pre>

<p>then I’m glad you’re paying attention. :-) Using the <code class="objc"><span class="sy0">+</span></code> instead of the <code class="objc"><span class="sy0">-</span></code> means that we can call this method without having a reference to the <code class="objc">DataModel</code> object.</p>

<p>Remember, we did:</p>

<pre class="objc no-border"><span class="kw1">self</span>.itemId <span class="sy0">=</span> <span class="br0">&#91;</span>DataModel nextChecklistItemId<span class="br0">&#93;</span>;</pre>

<p>instead of:</p>

<pre class="objc no-border"><span class="kw1">self</span>.itemId <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dataModel nextChecklistItemId<span class="br0">&#93;</span>;</pre>

<p>This is because <code class="objc">ChecklistItem</code> objects at this moment do not have  a reference to the <code class="objc">DataModel</code> object. We could certainly give them such a reference, but I decided that using a <em>class method</em> was easier.</p>

<p>The name of a class method begins with a <code class="objc"><span class="sy0">+</span></code>. This kind of method applies to the class as a whole. So far we’ve been using <em>instance methods</em>. They begin with a <code class="objc"><span class="sy0">-</span></code> and work only on a specific instance of that class. We haven’t discussed the difference between classes and instances before, and we’ll get into that in more detail in the next tutorial. For now, just remember that a method starting with a <code class="objc"><span class="sy0">+</span></code> allows you to call methods on an object even when you don’t have a reference to that object.</p>

<p>I had to make a trade-off. Is it worth giving each <code class="objc">ChecklistItem</code> object a reference to the <code class="objc">DataModel</code> object, or can I get away with a simple class method? To keep things simple, I chose the latter but it’s very well possible that, if we were to develop this app further, it would make more sense to use the references instead.</p>

</aside>

<p>For a quick test to see if assigning these IDs works, we can put them inside the text that is shown in the <code class="objc">ChecklistItem</code> cell label. This is just a temporary thing for testing purposes as users couldn’t care less about the internal identifier of our objects.</p>

<p><strong>&raquo;</strong> In ChecklistViewController.m, change the <code class="objc">configureTextForCell</code> method to:</p>

<figure class="code"><figcaption>ChecklistViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>configureTextForCell<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>cell withChecklistItem<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>item
<span class="br0">&#123;</span>
    <span class="kw7">UILabel</span> <span class="sy0">*</span>label <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span>;
    <span class="co2">//label.text = item.text;</span>
    label.text <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSString</span> stringWithFormat<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;%d: %@&quot;</span>, item.itemId, item.text<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>I have commented out the original line because we want to put that back later. The new line uses <code class="objc">stringWithFormat</code> to add the to-do item’s <code class="objc">itemId</code> property into the text.</p>

<p><strong>&raquo;</strong> Before you run the app, make sure to delete it from the Simulator first. We have changed the format of the Checklists.plist file again and reading an incompatible file may cause weird crashes.</p>

<p><strong>&raquo;</strong> Run the app and add some checklist items. Each new item should get a unique identifier. Press Home (to make sure everything is saved properly) and stop the app. Run the app again and add some new items; the IDs for these new items should start counting at where we left off.</p>

<figure class="image"><figcaption>The items with their IDs. Note that the item with ID 3 was deleted in this example.</figcaption><img src="HTML/Figures/Items_with_IDs.png" alt="The items with their IDs. Note that the item with ID 3 was deleted in this example."/></figure>

<p>OK, that takes care of the IDs. Now lets add the “due date” and “should remind” fields to the Add/Edit Item screen. (Keep <code class="objc">configureTextForCell</code> the way it is for the time being; that will come in handy with testing the notifications.)</p>

<p><strong>&raquo;</strong> Add the following outlets to ItemDetailViewController.h:</p>

<figure class="code"><figcaption>ItemDetailViewController.h</figcaption><pre class="objc"><span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw4">IBOutlet</span> <span class="kw7">UISwitch</span> <span class="sy0">*</span>switchControl;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw4">IBOutlet</span> <span class="kw7">UILabel</span> <span class="sy0">*</span>dueDateLabel;</pre></figure>

<p><strong>&raquo;</strong> Go to the Storyboard editor and select the Table View Section in the Item Detail View Controller. In the Attributes Inspector, set the number of rows to 3. This is a quick way to add new static cells. It will duplicate the existing cell including its text field. We don’t want text fields in these two new rows, so delete them from the second and third row.</p>

<p><strong>&raquo;</strong> Design the new cells to look as follows:</p>

<figure class="image"><figcaption>The new design of the Add/Edit Item screen</figcaption><img src="HTML/Figures/Add_Item_screen_new_design.png" alt="The new design of the Add/Edit Item screen"/></figure>

<p><strong>&raquo;</strong> Add a label to the second cell and give it the text “Remind Me”. Font is System Bold, 18. Uncheck Autoshrink and use the Size to Fit command (Cmd =) to make the text fit the label.</p>

<p><strong>&raquo;</strong> Drag a Switch control into the cell. Hook this switch up to the <code class="objc">switchControl</code> outlet. (I would have preferred to call this outlet simply “switch”, but that is a reserved keyword in the Objective-C language.)</p>

<p><strong>&raquo;</strong> The third cell has two labels: “Due Date” on the left and the label that will hold the actual chosen date on the right. The Due Date label has a System Bold font, size 18. Set this label’s Highlighted color to white.</p>

<p><strong>&raquo;</strong> The label on the right should be hooked up to the <code class="objc">dueDateLabel</code> outlet and is right-aligned. I put a fake date in here just so we know the label is big enough. Make this label as big as possible. For this label, make sure Autoshrink is checked. Font is System, 17. Color is blue (Red: 56, Green: 84, Blue: 135). Set its Highlighted color to white.</p>

<p><strong>&raquo;</strong> Give the cell a Disclosure Indicator accessory. Set the cell’s Selection attribute to Blue.</p>

<p>If you run the app now and press + to add a checklist item, the app crashes with the following error message:</p>

<pre>
*** Terminating app due to uncaught exception 'NSUnknownKeyException', reason:
'[&lt;ItemDetailViewController 0x6a4bbd0&gt; setValue:forUndefinedKey:]: this class
is not key value coding-compliant for the key dueDateLabel.'
</pre>

<p>I just wanted to show you this because from time to time this happens. We managed to hook up something in Interface Builder or the Storyboard Editor to a property, but when you run the app it turns out this property doesn’t actually exist. Which is correct because we haven’t synthesized <code class="objc">dueDateLabel</code> yet. Now you know what is going on when you get that kind of error.</p>

<p>Note: The app will not crash if you’re using Xcode 4.4 or better. The latest versions of the Objective-C compiler automatically synthesize properties for you if you do not specify a <code class="objc"><span class="kw1">@synthesize</span></code> statement.</p>

<p><strong>&raquo;</strong> Add the proper <code class="objc"><span class="kw1">@synthesize</span></code> statements in ItemDetailViewController.m:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> switchControl;
<span class="kw1">@synthesize</span> dueDateLabel;</pre></figure>

<p><strong>&raquo;</strong> Change the <code class="objc">viewDidLoad</code> method to the following:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.itemToEdit <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.title <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Edit Item&quot;</span>;
        <span class="kw1">self</span>.textField.text <span class="sy0">=</span> <span class="kw1">self</span>.itemToEdit.text;
        <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="kw2">YES</span>;
        <span class="kw1">self</span>.switchControl.on <span class="sy0">=</span> <span class="kw1">self</span>.itemToEdit.shouldRemind;
        dueDate <span class="sy0">=</span> <span class="kw1">self</span>.itemToEdit.dueDate;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.switchControl.on <span class="sy0">=</span> <span class="kw2">NO</span>;
        dueDate <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSDate</span> date<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> updateDueDateLabel<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>If we already have an existing <code class="objc">ChecklistItem</code> object, we set the switch control on or off, depending on the value of the object’s <code class="objc">shouldRemind</code> property. If we’re adding a new item, we always set the switch to off.</p>

<p>For a new item, the due date is right now, <code class="objc"><span class="br0">&#91;</span><span class="kw5">NSDate</span> date<span class="br0">&#93;</span></code>. That might not make much sense because by the time you have completed the rest of the fields and pressed Done, that due date will be past. But we do have to suggest something here. An alternative default value could be this time tomorrow, but in most cases the user will have to pick their own due date anyway.</p>

<p>The <code class="objc">updateDueDateLabel</code> method is new. Add it above <code class="objc">viewDidLoad</code>:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>updateDueDateLabel
<span class="br0">&#123;</span>
    <span class="kw5">NSDateFormatter</span> <span class="sy0">*</span>formatter <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSDateFormatter</span> alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>formatter setDateStyle<span class="sy0">:</span>NSDateFormatterMediumStyle<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>formatter setTimeStyle<span class="sy0">:</span>NSDateFormatterShortStyle<span class="br0">&#93;</span>;
    <span class="kw1">self</span>.dueDateLabel.text <span class="sy0">=</span> <span class="br0">&#91;</span>formatter stringFromDate<span class="sy0">:</span>dueDate<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>To convert the <code class="objc"><span class="kw5">NSDate</span></code> value to text, we use the <code class="objc"><span class="kw5">NSDateFormatter</span></code> object. The way it works is very straightforward, we give it a style for the date component and a separate style for the time component, and then ask it to format our <code class="objc"><span class="kw5">NSDate</span></code> object. You can play with different styles here but space in the label is limited so we can’t fit in the full month name, for example.</p>

<p>The cool thing about <code class="objc"><span class="kw5">NSDateFormatter</span></code> is that it takes the current locale into consideration so the time will look good to the user no matter where he is on the globe.</p>

<p>The <code class="objc">dueDate</code> variable is actually an instance variable, so declare it at the top:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> ItemDetailViewController <span class="br0">&#123;</span>
    <span class="kw5">NSDate</span> <span class="sy0">*</span>dueDate;
<span class="br0">&#125;</span></pre></figure>

<p>I want to keep track of this date object separately from the text in the <code class="objc">dueDateLabel</code> because then we don’t have to convert back from text in order to get an <code class="objc"><span class="kw5">NSDate</span></code> object.</p>

<p>The last thing to change in this file is the <code class="objc">done</code> action.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">done</code> method to:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.itemToEdit <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        item.text <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
        item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
        item.shouldRemind <span class="sy0">=</span> <span class="kw1">self</span>.switchControl.on;
        item.dueDate <span class="sy0">=</span> dueDate;
&nbsp;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate itemDetailViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishAddingItem<span class="sy0">:</span>item<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.itemToEdit.text <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
        <span class="kw1">self</span>.itemToEdit.shouldRemind <span class="sy0">=</span> <span class="kw1">self</span>.switchControl.on;
        <span class="kw1">self</span>.itemToEdit.dueDate <span class="sy0">=</span> dueDate;
&nbsp;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate itemDetailViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishEditingItem<span class="sy0">:</span><span class="kw1">self</span>.itemToEdit<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>Here we put the value of the switch control and the <code class="objc">dueDate</code> ivar back into the <code class="objc">ChecklistItem</code> object when the user presses the Done button.</p>

<p><strong>&raquo;</strong> Run the app and change the position of the switch control. The app will remember this setting when you terminate it (but be sure to press the Home button first).</p>

<p>The due date row doesn’t really do anything yet, however. In order to make that work, we first have to create a date picker.</p>

<h3>The date picker</h3>

<p><strong>&raquo;</strong> Add a new <code class="objc"><span class="kw7">UIViewController</span></code> subclass to the project. This time it is a subclass of <code class="objc"><span class="kw7">UIViewController</span></code>, not <code class="objc"><span class="kw7">UITableViewController</span></code>. No nib for user interface. Name it “DatePickerViewController”.</p>

<p><strong>&raquo;</strong> Change the DatePickerViewController.h file to look like this:</p>

<figure class="code"><figcaption>DatePickerViewController.h</figcaption><pre class="objc"><span class="co1">#import &lt;UIKit/UIKit.h&gt;</span>
&nbsp;
<span class="kw1">@class</span> DatePickerViewController;
&nbsp;
<span class="kw1">@protocol</span> DatePickerViewControllerDelegate &lt;NSObject&gt;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>datePickerDidCancel<span class="sy0">:</span><span class="br0">&#40;</span>DatePickerViewController <span class="sy0">*</span><span class="br0">&#41;</span>picker;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>datePicker<span class="sy0">:</span><span class="br0">&#40;</span>DatePickerViewController <span class="sy0">*</span><span class="br0">&#41;</span>picker didPickDate<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSDate</span> <span class="sy0">*</span><span class="br0">&#41;</span>date;
<span class="kw1">@end</span>
&nbsp;
<span class="kw1">@interface</span> DatePickerViewController <span class="sy0">:</span> <span class="kw7">UIViewController</span> &lt;<span class="kw8">UITableViewDataSource</span>, UITableViewDelegate&gt;
&nbsp;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw4">IBOutlet</span> <span class="kw7">UITableView</span> <span class="sy0">*</span>tableView;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw4">IBOutlet</span> <span class="kw7">UIDatePicker</span> <span class="sy0">*</span>datePicker;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">weak</span><span class="br0">&#41;</span> <span class="kw4">id</span> &lt;DatePickerViewControllerDelegate&gt; delegate;
<span class="kw1">@property</span> <span class="br0">&#40;</span><span class="kw1">nonatomic</span>, <span class="kw1">strong</span><span class="br0">&#41;</span> <span class="kw5">NSDate</span> <span class="sy0">*</span>date;
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>cancel;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>dateChanged;
&nbsp;
<span class="kw1">@end</span></pre></figure>

<p>This should look familiar. We’ve declared a delegate protocol that the date picker view controller will use to communicate back to the Item Detail View Controller.</p>

<p>The date picker has two outlet properties, <code class="objc">tableView</code> and <code class="objc">datePicker</code>, that we’ll connect to views inside the Storyboard editor. It also has two regular properties: the <code class="objc">delegate</code> and a <code class="objc">date</code>, which is the date we’ll initially display on the picker.</p>

<p>The date picker will look like this once it is finished:</p>

<figure class="image"><figcaption>The date picker screen</figcaption><img src="HTML/Figures/Date_picker_screen.png" alt="The date picker screen"/></figure>

<p>Let’s build the UI for the date picker.</p>

<p><strong>&raquo;</strong> Go to the Storyboard editor and drag a regular View Controller into the canvas, next to the Item Detail View Controller. In the Identity Inspector, set the Class of the new view controller to “DatePickerViewController”.</p>

<p><strong>&raquo;</strong> Ctrl-drag from the Due Date table view cell in the Item Detail View Controller to the new view controller and add a segue. Set the segue style to Modal and give it the identifier “PickDate”.</p>

<p>That’s right, we’re going to show the date picker as a modal screen on top of the Add/Edit Item screen, which itself is also modal. There’s nothing wrong with that, although you don’t want to stack too many modal screens on top of each other.</p>

<p>In the screenshot of the finished date picker above you can see it has a navigation bar and a Cancel and Done button. We could embed it in a navigation controller as we have done before, but this time let’s fake it.</p>

<p><strong>&raquo;</strong> From the Object Library drag a Navigation Bar into the Date Picker View Controller. Set its title to “Choose Date”. Drag two Bar Button Items onto the bar and set the left one’s identifier to Cancel and the right one to Done. Use the Connections Inspector to hook up the “selector” from these buttons with their respective actions.</p>

<p>Before we create the rest of this controller, let’s make sure we can open this screen and close it again.</p>

<p><strong>&raquo;</strong> In DatePickerViewController.m, synthesize the properties:</p>

<figure class="code"><figcaption>DatePickerViewController.m</figcaption><pre class="objc"><span class="kw1">@synthesize</span> tableView;
<span class="kw1">@synthesize</span> datePicker;
<span class="kw1">@synthesize</span> delegate;
<span class="kw1">@synthesize</span> date;</pre></figure>

<p><strong>&raquo;</strong> Add the <code class="objc">cancel</code> and <code class="objc">done</code> actions:</p>

<figure class="code"><figcaption>DatePickerViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>cancel
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.delegate datePickerDidCancel<span class="sy0">:</span><span class="kw1">self</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span>.delegate datePicker<span class="sy0">:</span><span class="kw1">self</span> didPickDate<span class="sy0">:</span><span class="kw1">self</span>.date<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We will make the <code class="objc">ItemDetailViewController</code> the delegate for this date picker.</p>

<p><strong>&raquo;</strong> Change the following in ItemDetailViewController.h:</p>

<figure class="code"><figcaption>ItemDetailViewController.h</figcaption><pre class="objc"><span class="co1">#import &quot;DatePickerViewController.h&quot;</span>
&nbsp;
. . .
&nbsp;
<span class="kw1">@interface</span> ItemDetailViewController <span class="sy0">:</span> <span class="kw7">UITableViewController</span> &lt;<span class="kw8">UITextFieldDelegate</span>, DatePickerViewControllerDelegate&gt;</pre></figure>

<p><strong>&raquo;</strong> Add the following method to ItemDetailViewController.m:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>prepareForSegue<span class="sy0">:</span><span class="br0">&#40;</span>UIStoryboardSegue <span class="sy0">*</span><span class="br0">&#41;</span>segue sender<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>sender
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>segue.identifier isEqualToString<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;PickDate&quot;</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        DatePickerViewController <span class="sy0">*</span>controller <span class="sy0">=</span> segue.destinationViewController;
        controller.delegate <span class="sy0">=</span> <span class="kw1">self</span>;
        controller.date <span class="sy0">=</span> dueDate;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>This sets up the connection with the delegate and we also pass the current date (from the <code class="objc">dueDate</code> ivar) to the date picker.</p>

<p>What remains is a skeleton implementation of the delegate methods that for now will simply close the date picker screen.</p>

<p><strong>&raquo;</strong> Add these methods to the bottom of ItemDetailViewController.m:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>datePickerDidCancel<span class="sy0">:</span><span class="br0">&#40;</span>DatePickerViewController <span class="sy0">*</span><span class="br0">&#41;</span>picker
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>datePicker<span class="sy0">:</span><span class="br0">&#40;</span>DatePickerViewController <span class="sy0">*</span><span class="br0">&#41;</span>picker didPickDate<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSDate</span> <span class="sy0">*</span><span class="br0">&#41;</span>date
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>There is one more thing we need to do. When we first created the  Add/Edit Item screen, we disabled taps on the rows because that interfered with the text field. We still want to keep it that way, except for the row with the due date in it. The user should be able to tap that in order to open the date picker. (That’s what the disclosure indicator signifies.)</p>

<p><strong>&raquo;</strong> Change the method <code class="objc">willSelectRowAtIndexPath</code> to the following, so that taps on the Due Date row are enabled again:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView willSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>indexPath.row <span class="sy0">==</span> <span class="nu0">2</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> indexPath;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="kw2">nil</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Run the app and verify that it works. When you tap on the due date row, the date picker will show up. You should also be able to dismiss the date picker with Cancel and Done.</p>

<p>Let’s finish the design of the date picker screen.</p>

<p><strong>&raquo;</strong> Take a Date Picker wheel from the Object Library and drop it into the view controller. Connect it to the <code class="objc">datePicker</code> outlet. Also connect its Value Changed event to the <code class="objc">dateChanged</code> action.</p>

<p><strong>&raquo;</strong> In the DatePickerViewController.m, implement these methods:</p>

<figure class="code"><figcaption>DatePickerViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewWillAppear<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>animated
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewWillAppear<span class="sy0">:</span>animated<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span>.datePicker setDate<span class="sy0">:</span><span class="kw1">self</span>.date animated<span class="sy0">:</span><span class="kw2">YES</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>dateChanged
<span class="br0">&#123;</span>
    <span class="kw1">self</span>.date <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.datePicker date<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>In <code class="objc">viewWillAppear</code> we set the current date that will be shown in the <code class="objc"><span class="kw7">UIDatePicker</span></code> view to the value from the <code class="objc">date</code> property. In <code class="objc">dateChanged</code> we do the opposite and we store the date picker’s chosen date back into the property.</p>

<p><strong>&raquo;</strong> In ItemDetailViewController.m, change the date picker delegate method to:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>datePicker<span class="sy0">:</span><span class="br0">&#40;</span>DatePickerViewController <span class="sy0">*</span><span class="br0">&#41;</span>picker didPickDate<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSDate</span> <span class="sy0">*</span><span class="br0">&#41;</span>date
<span class="br0">&#123;</span>
    dueDate <span class="sy0">=</span> date;
    <span class="br0">&#91;</span><span class="kw1">self</span> updateDueDateLabel<span class="br0">&#93;</span>;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> dismissViewControllerAnimated<span class="sy0">:</span><span class="kw2">YES</span> completion<span class="sy0">:</span><span class="kw2">nil</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>We put the date picker’s date into our own <code class="objc">dueDate</code> ivar and update the corresponding label.</p>

<p><strong>&raquo;</strong> Try it out. Run the app and pick a due date. It should now be remembered along with the <code class="objc">ChecklistItem</code> even when you quit the app.</p>

<p>(If the app crashes at this point, then remove it from the Simulator and try again. Because the format of the Checklists.plist file has changed a while back, the <code class="objc">dueDate</code> field may be read as <code class="objc"><span class="kw2">nil</span></code> and the date picker doesn’t like it when we give it a <code class="objc"><span class="kw2">nil</span></code> <code class="objc"><span class="kw5">NSDate</span></code> object in the <code class="objc">viewWillAppear</code> method. This won’t happen with a Checklists.plist file that is up-to-date but it can occur if you’re still using an older version.)</p>

<p>The date picker view controller still looks a little bare, so let’s return to the Storyboard editor and dress it up.</p>

<p><strong>&raquo;</strong> Drag a Table View into the white part of the view controller. You’ll have to resize the table view so that it only takes up the top part of the screen (make it 200 points high). We’ll be using this table view to show the picked date, it doesn’t have any other function at all.</p>

<p><strong>&raquo;</strong> Connect the table view to the <code class="objc">tableView</code> outlet. Connect the <code class="objc">dataSource</code> and <code class="objc">delegate</code> outlets to the view controller. Set the table view style to Grouped.</p>

<p>This would be an ideal situation for using static cells, we only need one cell with a label. One problem: static cells only work if the view controller is a <code class="objc"><span class="kw7">UITableViewController</span></code> and ours isn’t. We can’t really make it one either because a table view controller assumes that it has just one view: the table view. But this screen has a date picker view as well, so static cells are out the window and we’ll just have to make do with a prototype cell.</p>

<p><strong>&raquo;</strong> Drag a label into the prototype cell and make it stretch the entire width. Set the following attributes. Alignment: Center. Font: System, size 17. Text Color: the dark blue we used before (pick it from the Recently Used Colors list). Tag: 1000.</p>

<p><strong>&raquo;</strong> Select the table view cell. Set its Reuse Identifier to “DateCell”. Set the cell’s Selection property to None.</p>

<p><strong>&raquo;</strong> Select the table view. Uncheck the Scrolling Enabled attribute. Now the user can no longer “bounce” the table view. It will just appear in a fixed position.</p>

<p>The final design of the Date Picker View Controller should look like this:</p>

<figure class="image"><figcaption>The design of the date picker screen</figcaption><img src="HTML/Figures/Design_of_the_date_picker_view_controller.png" alt="The design of the date picker screen"/></figure>

<p><strong>&raquo;</strong> In DatePickerViewController.m, add the following methods:</p>

<figure class="code"><figcaption>DatePickerViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView numberOfRowsInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="nu0">1</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UITableViewCell</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>theTableView cellForRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw7">UITableViewCell</span> <span class="sy0">*</span>cell <span class="sy0">=</span> <span class="br0">&#91;</span>theTableView dequeueReusableCellWithIdentifier<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;DateCell&quot;</span><span class="br0">&#93;</span>;
&nbsp;
    dateLabel <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw7">UILabel</span> <span class="sy0">*</span><span class="br0">&#41;</span><span class="br0">&#91;</span>cell viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span> updateDateLabel<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">return</span> cell;
<span class="br0">&#125;</span>
&nbsp;
<span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>theTableView willSelectRowAtIndexPath<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSIndexPath</span> <span class="sy0">*</span><span class="br0">&#41;</span>indexPath
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">nil</span>;
<span class="br0">&#125;</span></pre></figure>

<p>These are the data source and delegate methods for the table view. Any taps on the row will be ignored.</p>

<p>The <code class="objc">cellForRowAtIndexPath</code> method does something special, it looks up the label with tag 1000 and then puts it into the <code class="objc">dateLabel</code> ivar.</p>

<p><strong>&raquo;</strong> Add this ivar to the <code class="objc"><span class="kw1">@implementation</span></code> section:</p>

<figure class="code"><figcaption>DatePickerViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> DatePickerViewController <span class="br0">&#123;</span>
    <span class="kw7">UILabel</span> <span class="sy0">*</span>dateLabel;
<span class="br0">&#125;</span></pre></figure>

<p>We’re not storing <code class="objc">dateLabel</code> in a property because it’s not really an outlet. We’re just using it for convenience so that we can refer to this label directly from now on without having to find the table view cell first and doing <code class="objc"><span class="br0">&#91;</span>viewWithTag<span class="sy0">:</span><span class="nu0">1000</span><span class="br0">&#93;</span></code> again.</p>

<p><strong>&raquo;</strong> Above <code class="objc">dateChanged</code>, add the following method:</p>

<figure class="code"><figcaption>DatePickerViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>updateDateLabel
<span class="br0">&#123;</span>
    <span class="kw5">NSDateFormatter</span> <span class="sy0">*</span>formatter <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw5">NSDateFormatter</span> alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>formatter setDateStyle<span class="sy0">:</span>NSDateFormatterLongStyle<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span>formatter setTimeStyle<span class="sy0">:</span>NSDateFormatterShortStyle<span class="br0">&#93;</span>;
    dateLabel.text <span class="sy0">=</span> <span class="br0">&#91;</span>formatter stringFromDate<span class="sy0">:</span><span class="kw1">self</span>.date<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This is similar to the date formatting we did in <code class="objc">ItemDetailViewController</code>, except this time we use the long style for the date.</p>

<p><strong>&raquo;</strong> Update the <code class="objc">dateChanged</code> action to call this method:</p>

<figure class="code"><figcaption>DatePickerViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>dateChanged
<span class="br0">&#123;</span>
    <span class="kw1">self</span>.date <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span>.datePicker date<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span> updateDateLabel<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>If you run the app now, everything should work. Except for a small detail: the label is positioned at the top of the screen and it would be nicer to have it vertically centered in the table view.</p>

<p><strong>&raquo;</strong> Add the following method to DatePickerViewController.m:</p>

<figure class="code"><figcaption>DatePickerViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">CGFloat</span><span class="br0">&#41;</span>tableView<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITableView</span> <span class="sy0">*</span><span class="br0">&#41;</span>tableView heightForHeaderInSection<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSInteger</span><span class="br0">&#41;</span>section
<span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="nu0">77</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This is another method from the table view delegate protocol. Each section of a table can have a header. We only have one section and the header is empty, but with this method we can determine how tall that header is. In effect, this lets us add 77 points of empty space above our one and only row, centering it inside the table view.</p>

<p>And that should do it.</p>

<aside>

<p>Note that you can take this date picker and drop it into any other project without too much trouble. It is not tied to the data model of this particular app. It doesn’t depend on <code class="objc">ChecklistItem</code> objects, only on <code class="objc"><span class="kw5">NSDate</span></code>. That is a good design.</p>

<p>You should always be thinking: can I turn this object into something that I can easily re-use in other projects? Picking dates is a common thing so it’s good to have a component like this in your library. You only have to write it once and then you can plug it into all your future projects.</p>

</aside>

<h3>Scheduling the local notifications</h3>

<p>One of the principles of Object-Oriented Programming is that objects can do as much as possible themselves. Therefore, it makes sense that the <code class="objc">ChecklistItem</code> object can schedule its own notifications.</p>

<p><strong>&raquo;</strong> Add the following method declaration to ChecklistItem.h:</p>

<figure class="code"><figcaption>ChecklistItem.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>scheduleNotification;</pre></figure>

<p><strong>&raquo;</strong> Add the method itself to ChecklistItem.m:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>scheduleNotification
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.shouldRemind <span class="sy0">&amp;&amp;</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dueDate compare<span class="sy0">:</span><span class="br0">&#91;</span><span class="kw5">NSDate</span> date<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy0">!=</span> NSOrderedAscending<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="co3">@</span><span class="st0">&quot;We should schedule a notification&quot;</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>This compares the due date on the item with the current date. If the due date is in the past, then the <code class="objc"><span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="br0">&#41;</span></code> will not be performed. Note the use of the <code class="objc"><span class="sy0">&amp;&amp;</span></code> “and” operator. We only print the text when the Remind Me switch is set to “on” <em>and</em> the due date is in the future.</p>

<p>We will call this method when the user presses the Done button after adding or editing a to-do item.</p>

<p><strong>&raquo;</strong> Change the <code class="objc">done</code> action in ItemDetailViewController.m:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>done
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.itemToEdit <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        ChecklistItem <span class="sy0">*</span>item <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>ChecklistItem alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        item.text <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
        item.checked <span class="sy0">=</span> <span class="kw2">NO</span>;
        item.shouldRemind <span class="sy0">=</span> <span class="kw1">self</span>.switchControl.on;
        item.dueDate <span class="sy0">=</span> dueDate;
        <span class="br0">&#91;</span>item scheduleNotification<span class="br0">&#93;</span>;
&nbsp;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate itemDetailViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishAddingItem<span class="sy0">:</span>item<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.itemToEdit.text <span class="sy0">=</span> <span class="kw1">self</span>.textField.text;
        <span class="kw1">self</span>.itemToEdit.shouldRemind <span class="sy0">=</span> <span class="kw1">self</span>.switchControl.on;
        <span class="kw1">self</span>.itemToEdit.dueDate <span class="sy0">=</span> dueDate;
        <span class="br0">&#91;</span><span class="kw1">self</span>.itemToEdit scheduleNotification<span class="br0">&#93;</span>;
&nbsp;
        <span class="br0">&#91;</span><span class="kw1">self</span>.delegate itemDetailViewController<span class="sy0">:</span><span class="kw1">self</span> didFinishEditingItem<span class="sy0">:</span><span class="kw1">self</span>.itemToEdit<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>Only the lines with <code class="objc"><span class="br0">&#91;</span>scheduleNotification<span class="br0">&#93;</span></code> are new.</p>

<p><strong>&raquo;</strong> Run the app and try it out. Add a new item, set the switch to ON but don’t change the due date. Press Done. There should be no message in the Debug Area because the due date has already passed.</p>

<p><strong>&raquo;</strong> Add another item, set the switch to ON, and choose a due date in the future. When you press Done now, there should be an <code class="objc"><span class="kw3">NSLog</span></code> (“We should schedule a notification”) in the Debug Area.</p>

<p>Now that we’ve verified the method is called in the proper place, let’s actually schedule a new <code class="objc"><span class="kw7">UILocalNotification</span></code> object. We will first consider the case of a new to-do item being added.</p>

<p><strong>&raquo;</strong> In ChecklistItem.m, change <code class="objc">scheduleNotification</code> to:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>scheduleNotification
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.shouldRemind <span class="sy0">&amp;&amp;</span> <span class="br0">&#91;</span><span class="kw1">self</span>.dueDate compare<span class="sy0">:</span><span class="br0">&#91;</span><span class="kw5">NSDate</span> date<span class="br0">&#93;</span><span class="br0">&#93;</span> <span class="sy0">!=</span> NSOrderedAscending<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
        <span class="kw7">UILocalNotification</span> <span class="sy0">*</span>localNotification <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UILocalNotification</span> alloc<span class="br0">&#93;</span> init<span class="br0">&#93;</span>;
        localNotification.fireDate <span class="sy0">=</span> <span class="kw1">self</span>.dueDate;
        localNotification.timeZone <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSTimeZone</span> defaultTimeZone<span class="br0">&#93;</span>;
        localNotification.alertBody <span class="sy0">=</span> <span class="kw1">self</span>.text;
        localNotification.soundName <span class="sy0">=</span> UILocalNotificationDefaultSoundName;
        localNotification.userInfo <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSDictionary</span> dictionaryWithObject<span class="sy0">:</span><span class="br0">&#91;</span><span class="kw5">NSNumber</span> numberWithInt<span class="sy0">:</span><span class="kw1">self</span>.itemId<span class="br0">&#93;</span> forKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ItemID&quot;</span><span class="br0">&#93;</span>;
&nbsp;
        <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UIApplication</span> sharedApplication<span class="br0">&#93;</span> scheduleLocalNotification<span class="sy0">:</span>localNotification<span class="br0">&#93;</span>;
&nbsp;
        <span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="co3">@</span><span class="st0">&quot;Scheduled notification %@ for itemId %d&quot;</span>, localNotification, <span class="kw1">self</span>.itemId<span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>You’ve seen this code before. We create a <code class="objc"><span class="kw7">UILocalNotification</span></code> object. This time, however, we use the <code class="objc">ChecklistItem</code>’s <code class="objc">dueDate</code> and <code class="objc">text</code>. We also add a <code class="objc">userInfo</code> dictionary with the item’s ID as the only contents. That is how we’ll be able to find this notification later in case we need to cancel it.</p>

<p><strong>&raquo;</strong> Test it out. Run the app, add a new checklist item, set the due date a minute into the future, press Done and tap the Home button on the Simulator. Now wait one minute and the notification should appear. Pretty cool!</p>

<aside>

<p>The date picker doesn’t show you seconds but they still are there (just watch the <code class="objc"><span class="kw3">NSLog</span></code> output). If you set the due date to 10:16 PM when it’s currently 10:15:54 PM, you’ll have to wait until exactly 10:16:54 for the event to fire. It would probably be a better user experience if you always set the seconds to 0, but that’s a topic for another day.</p>

</aside>

<p>That takes care of the case where we’re adding a new notification. There are two situations left: the user edits an existing item and the user deletes an item. Let’s do editing first.</p>

<p>When the user edits an item, the following situations can occur:</p>

<ul>
<li>Remind Me was switched off and is now switched on. We have to schedule a new notification.</li>
<li>Remind Me was switched on and is now switched off. We have to cancel the existing notification.</li>
<li>Remind Me stays switched on but the due date changes. We have to cancel the existing notification and schedule a new one.</li>
<li>Remind Me stays switched on but the due date doesn’t change. We don’t have to do anything.</li>
<li>Remind Me stays switched off. Here we also don’t have to do anything.</li>
</ul>

<p>Of course, in all those situations we’ll only schedule the notification if the due date is in the future.</p>

<p>Phew, that’s quite a list. It’s always a good idea to take stock of all possible scenarios before you start programming because this gives you a clear picture of everything you need to tackle.</p>

<p>It may seem like we need to write a lot of logic here to deal with all these situations, but actually it turns out to be quite simple. First we’ll look if there is an existing notification for this to-do item. If there is, we simply cancel it. Then we determine whether the item should have a notification and if so, we schedule a new one. That should take care of all the above situations, even if sometimes we simply could have left the existing notification alone. Crude, but effective.</p>

<p><strong>&raquo;</strong> Add the following to the top of <code class="objc">scheduleNotification</code>:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>scheduleNotification
<span class="br0">&#123;</span>
    <span class="kw7">UILocalNotification</span> <span class="sy0">*</span>existingNotification <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span> notificationForThisItem<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>existingNotification <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="co3">@</span><span class="st0">&quot;Found an existing notification %@&quot;</span>, existingNotification<span class="br0">&#41;</span>;
        <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UIApplication</span> sharedApplication<span class="br0">&#93;</span> cancelLocalNotification<span class="sy0">:</span>existingNotification<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    . . .
<span class="br0">&#125;</span></pre></figure>

<p>This calls a method <code class="objc">notificationForThisItem</code>, which we’ll add in a second. If that method returns a valid <code class="objc"><span class="kw7">UILocalNotification</span></code> object (i.e. not <code class="objc"><span class="kw2">nil</span></code>), then we dump some debug info using <code class="objc"><span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="br0">&#41;</span></code> and then ask the <code class="objc"><span class="kw7">UIApplication</span></code> object to cancel this notification.</p>

<p><strong>&raquo;</strong> Add the new <code class="objc">notificationForThisItem</code> method above <code class="objc">scheduleNotification</code>:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw7">UILocalNotification</span> <span class="sy0">*</span><span class="br0">&#41;</span>notificationForThisItem
<span class="br0">&#123;</span>
    <span class="kw5">NSArray</span> <span class="sy0">*</span>allNotifications <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UIApplication</span> sharedApplication<span class="br0">&#93;</span> scheduledLocalNotifications<span class="br0">&#93;</span>;
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw7">UILocalNotification</span> <span class="sy0">*</span>notification <span class="kw1">in</span> allNotifications<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw5">NSNumber</span> <span class="sy0">*</span>number <span class="sy0">=</span> <span class="br0">&#91;</span>notification.userInfo objectForKey<span class="sy0">:</span><span class="co3">@</span><span class="st0">&quot;ItemID&quot;</span><span class="br0">&#93;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>number <span class="sy0">!=</span> <span class="kw2">nil</span> <span class="sy0">&amp;&amp;</span> <span class="br0">&#91;</span>number intValue<span class="br0">&#93;</span> <span class="sy0">==</span> <span class="kw1">self</span>.itemId<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw1">return</span> notification;
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw2">nil</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This asks <code class="objc"><span class="kw7">UIApplication</span></code> for a list of all scheduled notifications. Then we loop through that list and look at each notification one-by-one. It should have an “ItemID” value inside the <code class="objc">userInfo</code> dictionary. If that value exists and equals our item ID, then we’ve found a notification that belongs to this <code class="objc">ChecklistItem</code>. If none of the local notifications match, or there aren’t any to begin with, the method returns <code class="objc"><span class="kw2">nil</span></code>.</p>

<p>This is a common pattern that you’ll see in a lot of code. Something returns an array of items and you loop through the array to find the first item that matches what you’re looking for, in this case the item ID. Once you’ve found it, you can exit the loop.</p>

<p><strong>&raquo;</strong> Run the app and try it out. Add a to-do item with a due date a few days into the future. A new notification will be scheduled. Edit the item and change the due date. The old notification will be removed and a new one scheduled for the new date.</p>

<p><strong>&raquo;</strong> Edit the to-do item again but now set the switch to OFF. The old notification will be removed and no new notification will be scheduled. Edit again and don’t change anything; no new notification will be scheduled because the switch is still off. This should also work if you terminate the app in between.</p>

<p>One last case to handle: deletion of the <code class="objc">ChecklistItem</code> object. This can happen in two ways: 1) the user can delete an individual item using swipe-to-delete; 2) the user can delete an entire checklist in which case all its <code class="objc">ChecklistItem</code> objects are also deleted.</p>

<p>An object is notified when it is about to be deleted using the <code class="objc">dealloc</code> message. We can simply implement this method, look if there is a scheduled notification for this item and then cancel it.</p>

<p><strong>&raquo;</strong> Add the following to the bottom of ChecklistItem.m:</p>

<figure class="code"><figcaption>ChecklistItem.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>dealloc
<span class="br0">&#123;</span>
    <span class="kw7">UILocalNotification</span> <span class="sy0">*</span>existingNotification <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">self</span> notificationForThisItem<span class="br0">&#93;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>existingNotification <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="co3">@</span><span class="st0">&quot;Removing existing notification %@&quot;</span>, existingNotification<span class="br0">&#41;</span>;
        <span class="br0">&#91;</span><span class="br0">&#91;</span><span class="kw7">UIApplication</span> sharedApplication<span class="br0">&#93;</span> cancelLocalNotification<span class="sy0">:</span>existingNotification<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>That’s all we have to do. The <code class="objc">dealloc</code> method will be invoked when we delete an individual <code class="objc">ChecklistItem</code> but also when we delete a whole <code class="objc">Checklist</code> (because then all its <code class="objc">ChecklistItem</code>s will be destroyed as well, as the array they are in is deallocated).</p>

<p><strong>&raquo;</strong> Run the app and try it out. First schedule some notifications far into the future (so they won’t be fired when you’re testing) and then remove that to-do item or its entire checklist. You should now see a message in the Debug Area.</p>

<p>Once you’re convinced everything works, you can remove the <code class="objc"><span class="kw3">NSLog</span><span class="br0">&#40;</span><span class="br0">&#41;</span></code> statements. They are only temporary for debugging purposes. You probably don’t want to leave them in the final app. (They won’t hurt any, but the end user can’t see those messages anyway.)</p>

<p><strong>&raquo;</strong> You should also remove the item ID from the label in the <code class="objc">ChecklistViewController</code>, we no longer need that.</p>

<p>You can find the project files for the app up to this point under “11 - Local Notifications” in the tutorial’s Source Code folder.</p>

<p><strong>Exercise:</strong> Put the due date in a label on the table view cells under the text of the to-do item. <strong>◼</strong></p>

<p><strong>Exercise:</strong> Sort the to-do items list based on the due date. This is similar to what we did with the list of <code class="objc">Checklist</code>s except that now you’re sorting <code class="objc">ChecklistItem</code> objects and you’ll be comparing <code class="objc"><span class="kw5">NSDate</span></code> objects instead of <code class="objc"><span class="kw5">NSString</span></code>s. (<code class="objc"><span class="kw5">NSDate</span></code> does not have a <code class="objc">localizedStandardCompare</code> method but it does have a regular <code class="objc">compare</code>). <strong>◼</strong></p>

<h3>One last bug...</h3>

<p>The app may seem to work perfectly now, but I’m afraid there is still a bug if you run it on iOS 5 &mdash; but not on iOS 6.0 or higher. This bug is not something that will make the app crash, but it could potentially upset or confuse users. Here’s how to reproduce it:</p>

<p><strong>&raquo;</strong> Run the app. Add a new to-do item. Type something for the name of the item. Set Remind Me to ON. Tap on the Due Date row to open the date picker. From the Simulator’s menubar choose Hardware → Simulate Memory Warning.</p>

<p>The Debug Area will now say something like:</p>

<pre>
Checklists[1417:207] Received memory warning.
</pre>

<p><strong>&raquo;</strong> Press Cancel to close the date picker screen. When you return to the Add Item screen, the text you previously typed is gone and Remind Me is back to the OFF state.</p>

<p>What happened here? When your app gets a low memory warning, UIKit will unload the views of any controllers that are not currently visible. When you’re interacting with the date picker screen and a low memory warning comes in, UIKit will unload the views of the Add/Edit Item screen, the Checklist screen and the All Lists screen. That is, it throws away the table view, the text field, the switch control, and their contents.</p>

<p>Note: UIKit only unloads views in low memory situations on iOS 5 but it no longer does so on iOS 6. Apple decided that this mechanism was too confusing and they simplified how UIKit deals with memory running low. That’s why this bug doesn’t appear on iOS 6.0 or later. Still, if you want your apps to be compatible with iOS 5, it’s worth handling these sorts of situations.</p>

<p>In a previous version of the iOS Apprentice, I always recommended that you set your outlet properties to <code class="objc"><span class="kw2">nil</span></code> in the <code class="objc">viewDidUnload</code> method. If you don’t set your outlet properties to <code class="objc"><span class="kw2">nil</span></code>, then not all memory can be properly released when the view is unloaded. UIKit is pretty smart about releasing memory but it can’t know what to do with outlet properties that you have created. As long as you’re keeping a reference to a <code class="objc"><span class="kw7">UITextField</span></code>, for example, that text field object stays in memory. Only when all references to it are dropped can the text field be deallocated.</p>

<p>To make sure UIKit is not longer keeping references to these objects, we’re responsible for setting our outlet properties to <code class="objc"><span class="kw2">nil</span></code>. That used to be the purpose of <code class="objc">viewDidUnload</code>, it gave us a chance to clean up. However, Apple has deprecated this method and as of iOS 6 it will no longer be called. Because we still want the Checklists app to do the right thing on iOS 5, I will show you the new recommended way for catching low memory warnings and dealing with them.</p>

<p><strong>&raquo;</strong> Add the following method to ItemDetailViewController.m:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>didReceiveMemoryWarning
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> didReceiveMemoryWarning<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span><span class="kw1">self</span> isViewLoaded<span class="br0">&#93;</span> <span class="sy0">&amp;&amp;</span> <span class="kw1">self</span>.view.window <span class="sy0">==</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.view <span class="sy0">=</span> <span class="kw2">nil</span>;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span><span class="br0">&#91;</span><span class="kw1">self</span> isViewLoaded<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.textField <span class="sy0">=</span> <span class="kw2">nil</span>;
        <span class="kw1">self</span>.doneBarButton <span class="sy0">=</span> <span class="kw2">nil</span>;
        <span class="kw1">self</span>.switchControl <span class="sy0">=</span> <span class="kw2">nil</span>;
        <span class="kw1">self</span>.dueDateLabel <span class="sy0">=</span> <span class="kw2">nil</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>The <code class="objc">didReceiveMemoryWarning</code> method is called when memory gets low. You can override it to free up any memory you no longer need. By the time we get here on iOS 5, the view has already been unloaded and we just need to set the outlet properties to <code class="objc"><span class="kw2">nil</span></code> as well. However, on iOS 6 we first force the view to unload itself by setting <code class="objc"><span class="kw1">self</span>.view</code> to <code class="objc"><span class="kw2">nil</span></code>, so that the app works the same across all versions of iOS. Try it out on the iOS 6 Simulator; after simulating a low memory warning, the text field is empty here too.</p>

<p>When you press Cancel to go back to the Add/Edit Item screen, UIKit will reload the view for that screen and resets it to its default state. It also calls <code class="objc">viewDidLoad</code> again, which either empties out the contents of the text field and sets the switch to “off” (when adding a new item) or overwrites the contents of the text field and switch control with the values from the <code class="objc">ChecklistItem</code> object (when editing an existing item). Either way, whatever we typed into the text field is gone.</p>

<p>Loading data into your controls inside <code class="objc">viewDidLoad</code> works fine if you never open a new view controller on top of this one because then UIKit will never unload the view in a low-memory situation (it would be strange if the current screen simply disappeared). But now that we open the date picker screen, our view can be unloaded at any time and there is nothing we can do (or should do!) to stop it.</p>

<p>We need to make the <code class="objc">ItemDetailViewController</code> a little smarter so that it doesn’t throw away the changes the user has made when this happens.</p>

<p><strong>&raquo;</strong> Change <code class="objc">viewDidLoad</code> to the following:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>viewDidLoad
<span class="br0">&#123;</span>
    <span class="br0">&#91;</span><span class="kw1">super</span> viewDidLoad<span class="br0">&#93;</span>;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">self</span>.itemToEdit <span class="sy0">!=</span> <span class="kw2">nil</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">self</span>.title <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;Edit Item&quot;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">self</span>.textField.text <span class="sy0">=</span> text;
    <span class="kw1">self</span>.switchControl.on <span class="sy0">=</span> shouldRemind;
&nbsp;
    <span class="br0">&#91;</span><span class="kw1">self</span> updateDoneBarButton<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span> updateDueDateLabel<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>From now on, we will store the name of the <code class="objc">ChecklistItem</code> in the new <code class="objc">text</code> ivar and the state of the switch control in <code class="objc">shouldRemind</code>. (We already kept a copy of the date in the <code class="objc">dueDate</code> ivar.) When the view is loaded, we put those values into the UI controls.</p>

<p>The idea is that when the view gets unloaded out from under us, we still have the proper values in the <code class="objc">text</code>, <code class="objc">shouldRemind</code> and <code class="objc">dueDate</code> ivars. When the view gets restored again, we put those values back in the text field and the switch control and it will seem like nothing ever happened.</p>

<p><strong>&raquo;</strong> The <code class="objc">updateDoneBarButton</code> method is new. Add it above <code class="objc">viewDidLoad</code>:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>updateDoneBarButton
<span class="br0">&#123;</span>
    <span class="kw1">self</span>.doneBarButton.enabled <span class="sy0">=</span> <span class="br0">&#40;</span><span class="br0">&#91;</span>text length<span class="br0">&#93;</span> &gt; <span class="nu0">0</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Change the text field delegate method to:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">BOOL</span><span class="br0">&#41;</span>textField<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITextField</span> <span class="sy0">*</span><span class="br0">&#41;</span>theTextField shouldChangeCharactersInRange<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSRange</span><span class="br0">&#41;</span>range replacementString<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSString</span> <span class="sy0">*</span><span class="br0">&#41;</span>string
<span class="br0">&#123;</span>
    text <span class="sy0">=</span> <span class="br0">&#91;</span>theTextField.text stringByReplacingCharactersInRange<span class="sy0">:</span>range withString<span class="sy0">:</span>string<span class="br0">&#93;</span>;
    <span class="br0">&#91;</span><span class="kw1">self</span> updateDoneBarButton<span class="br0">&#93;</span>;
    <span class="kw1">return</span> <span class="kw2">YES</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This now copies the contents of the text field into the <code class="objc">text</code> ivar and automatically enables or disables the Done button if necessary. The <code class="objc">text</code> ivar will always have a backup copy of what is in the text field, so we will remember those contents when the view gets unloaded.</p>

<p><strong>&raquo;</strong> Add the following method:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>textFieldDidEndEditing<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UITextField</span> <span class="sy0">*</span><span class="br0">&#41;</span>theTextField
<span class="br0">&#123;</span>
    text <span class="sy0">=</span> theTextField.text;
    <span class="br0">&#91;</span><span class="kw1">self</span> updateDoneBarButton<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre></figure>

<p>This is also a text field delegate method. We need it for the following situation: If there is a spelling suggestion and you press Done on the keyboard, then the text in the text field does change but we do not get a <code class="objc">shouldChangeCharactersInRange</code> notification for some reason. So we handle that situation in <code class="objc">textFieldDidEndEditing</code>.</p>

<p><strong>&raquo;</strong> Add the following method declaration to ItemDetailViewController.h:</p>

<figure class="code"><figcaption>ItemDetailViewController.h</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>switchChanged<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UISwitch</span> <span class="sy0">*</span><span class="br0">&#41;</span>sender;</pre></figure>

<p><strong>&raquo;</strong> In the Storyboard editor, hook up the switch control’s Value Changed event to this action method.</p>

<p><strong>&raquo;</strong> Add the method implementation to ItemDetailViewController.m:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">IBAction</span><span class="br0">&#41;</span>switchChanged<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw7">UISwitch</span> <span class="sy0">*</span><span class="br0">&#41;</span>sender
<span class="br0">&#123;</span>
    shouldRemind <span class="sy0">=</span> sender.on;
<span class="br0">&#125;</span></pre></figure>

<p>Now the contents of the <code class="objc">text</code> and <code class="objc">shouldRemind</code> ivars always mirror what is visible on the screen. We still need to add the actual ivars and give them initial values.</p>

<p><strong>&raquo;</strong> Add the instance variables:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="kw1">@implementation</span> ItemDetailViewController <span class="br0">&#123;</span>
    <span class="kw5">NSString</span> <span class="sy0">*</span>text;
    <span class="kw4">BOOL</span> shouldRemind;
    <span class="kw5">NSDate</span> <span class="sy0">*</span>dueDate;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> Add the <code class="objc">initWithCoder</code> method:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw4">id</span><span class="br0">&#41;</span>initWithCoder<span class="sy0">:</span><span class="br0">&#40;</span><span class="kw5">NSCoder</span> <span class="sy0">*</span><span class="br0">&#41;</span>aDecoder
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw1">self</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw1">super</span> initWithCoder<span class="sy0">:</span>aDecoder<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        text <span class="sy0">=</span> <span class="co3">@</span><span class="st0">&quot;&quot;</span>;
        shouldRemind <span class="sy0">=</span> <span class="kw2">NO</span>;
        dueDate <span class="sy0">=</span> <span class="br0">&#91;</span><span class="kw5">NSDate</span> date<span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">self</span>;
<span class="br0">&#125;</span></pre></figure>

<p><strong>&raquo;</strong> You can remove <code class="objc">initWithStyle</code> as that method is never used.</p>

<p><strong>&raquo;</strong> Run the app and add a new to-do item. Type something in the Name field, toggle the Remind Me switch to ON, and click Due Date. When the date picker appears, choose Simulate Memory Warning from the Simulator’s Hardware menu. Now press Cancel to close the date picker. Lo and behold: this time the Add Item screen did remember the text and the state of the Remind Me switch.</p>

<p>There is one more thing we need to do. When you tap an existing item to edit it, the text field is empty, the Remind Me switch is always OFF, and the Due Date is always today’s date and the current time. That ain’t right! Due to the recent changes in <code class="objc">viewDidLoad</code>, we never load the <code class="objc">ChecklistItem</code>’s values into the UI controls anymore.</p>

<p>We’re going to use a little trick to solve this problem.</p>

<p><strong>&raquo;</strong> Add the following method to ItemDetailViewController.m:</p>

<figure class="code"><figcaption>ItemDetailViewController.m</figcaption><pre class="objc"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>setItemToEdit<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>newItem
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>itemToEdit <span class="sy0">!=</span> newItem<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        itemToEdit <span class="sy0">=</span> newItem;
        text <span class="sy0">=</span> itemToEdit.text;
        shouldRemind <span class="sy0">=</span> itemToEdit.shouldRemind;
        dueDate <span class="sy0">=</span> itemToEdit.dueDate;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre></figure>

<p>When this method is called, it takes a <code class="objc">ChecklistItem</code> object and puts it into the <code class="objc">itemToEdit</code> ivar. It also copies the item’s <code class="objc">text</code>, <code class="objc">shouldRemind</code> and <code class="objc">dueDate</code> properties in the temporary ivars that we have recently introduced.</p>

<p>So what is the trick? The <code class="objc">setItemToEdit</code> method is a so-called <em>setter</em>. This method is invoked automatically when you do:</p>

<pre class="objc">controller.itemToEdit <span class="sy0">=</span> anItem;</pre>

<p>That is exactly what we do in <code class="objc">ChecklistViewController</code> when we perform the segue to <code class="objc">ItemDetailViewController</code> (in the <code class="objc">prepareForSegue</code> method). When you set a property to a new value, the corresponding setter method is invoked.</p>

<p>Normally you don’t have to write setter methods, as that is what <code class="objc"><span class="kw1">@synthesize</span></code> provides for you. In this case, however, we don’t just want to put a new value into the <code class="objc">itemToEdit</code> property, we also want to fill in the <code class="objc">ItemDetailViewController</code>’s <code class="objc">text</code>, <code class="objc">shouldRemind</code> and <code class="objc">dueDate</code> variables. By making our own setter, we can do that conveniently in one place, and before <code class="objc">viewDidLoad</code> happens.</p>

<p><strong>&raquo;</strong> Run the app and verify that everything now works again.</p>

<p>If the iPhone runs out of available memory while the date picker is showing, then the <code class="objc">ItemDetailViewController</code>’s view may get unloaded but at least we keep track of the data that the user entered. In other words, we’ve taken the responsibility for remembering the data out of the views (the text field and switch control) and used a mini-data model to remember them (the new instance variables).</p>

<p>This is how I like to write all my modal view controllers: put all the data into separate ivars and update these ivars when the user changes something in the UI.</p>

<p><strong>Exercise:</strong> <code class="objc">ListDetailViewController</code> has a similar problem if you’re inside the Icon Picker and a low memory warning occurs. I’m sure you can fix that issue now you know how. <strong>◼</strong></p>

<p>You can find the final project files for the Checklists app under “12 - Low Memory” in the tutorial’s Source Code folder.</p>

<aside>

<p>I’ve pointed out a few times already that users of Xcode 4.4 or better no longer need to type <code class="objc"><span class="kw1">@synthesize</span></code> for their properties. But if you’ve been skipping the synthesize statements, then the compiler now gives a bunch of errors on the new <code class="objc">setItemToEdit<span class="sy0">:</span></code> method.</p>

<p>To fix this, change the code to:</p>

<pre class="objc no-border"><span class="sy0">-</span> <span class="br0">&#40;</span><span class="kw1">void</span><span class="br0">&#41;</span>setItemToEdit<span class="sy0">:</span><span class="br0">&#40;</span>ChecklistItem <span class="sy0">*</span><span class="br0">&#41;</span>newItem
<span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>_itemToEdit <span class="sy0">!=</span> newItem<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        _itemToEdit <span class="sy0">=</span> newItem;
        text <span class="sy0">=</span> _itemToEdit.text;
        shouldRemind <span class="sy0">=</span> _itemToEdit.shouldRemind;
        dueDate <span class="sy0">=</span> _itemToEdit.dueDate;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>This method tried to use the <code class="objc">itemToEdit</code> instance variable but that ivar does not exist if you depend on automatic property synthesis. When you write <code class="objc"><span class="kw1">@synthesize</span> itemToEdit;</code>, the compiler creates a backing ivar with the same name as the property, <code class="objc">itemToEdit</code>. But the name for the instance variable that automatic synthesize creates is slightly different, it has an additional underscore in front: <code class="objc">_itemToEdit</code>. Gotcha!</p>

</aside>

<hr>

<h2>That’s a wrap!</h2>

<p>Things should be starting to make sense by now. I’ve sort of thrown you into the deep end by writing an entire app from scratch, and we’ve touched on a number of advanced topics already, but hopefully you were able to follow along quite well with what I’m doing. If not, then sleep on it for a bit and  keep tinkering with the code. Programming requires its own way of thinking and you won’t learn that overnight.</p>

<p>This lesson focused mainly on UIKit and its most important controls and patterns. In the <a href="http://www.raywenderlich.com/ios-apprentice">next lesson</a> we’ll take a few steps back to talk more about the Objective-C language itself and of course we’ll build another cool app.</p>

<p>Here is the final storyboard for Checklists:</p>

<figure class="image"><figcaption>The final storyboard</figcaption><a href="HTML/Figures/The_final_storyboard.png" target="_blank"><img src="HTML/Figures/Thumbnail-The_final_storyboard.png" alt="The final storyboard"/></a><br><span class="enlarge-image"><a href="HTML/Figures/The_final_storyboard.png" target="_blank">(Click to enlarge)</a></span></figure>

<p>I had trouble fitting that on my screen!</p>

<p>You can find the full source code of the app in the “Source Code” folder for this tutorial.</p>

<p>For more info about table views, see the <a href="http://developer.apple.com/library/ios/#documentation/UserExperience/Conceptual/TableView_iPhone/AboutTableViewsiPhone/AboutTableViewsiPhone.html">Table View Programming Guide for iOS</a>.</p>

<p>For more info about local notifications, see the <a href="http://developer.apple.com/library/ios/#documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction/Introduction.html">Local and Push Notification Programming Guide</a>.</p>

<p>Icons by <a href="http://thenounproject.com/">The Noun Project</a>.</p>



<h3>About the author</h3>

<p>Matthijs Hollemans is an independent iPad and iPhone developer and designer from the Netherlands. He writes about the technical and non-technical aspects of developing iOS apps on his blog, <a href="http://www.hollance.com">www.hollance.com</a>. He also writes tutorials for <a href="http://www.raywenderlich.com">raywenderlich.com</a>.</p>

<p>Feel free to <a href="mailto:mail@hollance.com">send Matthijs an email</a> if you have any questions or comments about these tutorials. And of course you’re welcome to <a href="http://www.raywenderlich.com/forums/viewforum.php?f=9">visit the forums</a> for some good conversation.</p>

<p>Thanks for reading!</p>

<h3>Revision history</h3>

<ul>
<li>v1.4 (14 Aug 2012) - Updated for iOS 6. Removed explanation of <code class="objc">viewDidUnload</code>, as its use is no longer recommended by Apple.</li>
<li>v1.3 (6 June 2012) - Updated for Xcode 4.3. Added PDF version.</li>
<li>v1.2 (18 Dec 2011) - Added tutorial 4, StoreSearch</li>
<li>v1.1 (18 Sept 2011) - Updated for iOS 5</li>
<li>v1.0 (5 July 2011) - First version (iOS 4)</li>
</ul>

<p>© 2011-2012 M.I. Hollemans</p>


</article>
</section>
</body>
</html>